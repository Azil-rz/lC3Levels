[{"leetCodeID": "0001", "level": "easy", "question_description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.", "examples": ["Example 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n", "Example 2:\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n", "Example 3:\nInput: nums = [3,3], target = 6\nOutput: [0,1]\n"], "constraints": "\nConstraints:\n2 <= nums.length <= 104\n-109 <= nums[i] <= 109\n-109 <= target <= 109\nOnly one valid answer exists.\n", "java_context": "\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @param {number} target\n* @return {number[]}\n*/\nvar twoSum = function (nums, target) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int[] twoSum(int[] nums, int target) {\nMap<Integer, Integer> m = new HashMap<>();\nfor (int i = 0;; ++i) {\nint x = nums[i];\nint y = target - x;\nif (m.containsKey(y)) {\nreturn new int[] {m.get(y), i};\n}\nm.put(x, i);\n}\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @param {number} target\n* @return {number[]}\n*/\nvar twoSum = function (nums, target) {\nconst m = new Map();\nfor (let i = 0; ; ++i) {\nconst x = nums[i];\nconst y = target - x;\nif (m.has(y)) {\nreturn [m.get(y), i];\n}\nm.set(x, i);\n}\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> twoSum(vector<int>& nums, int target) {\nunordered_map<int, int> m;\nfor (int i = 0;; ++i) {\nint x = nums[i];\nint y = target - x;\nif (m.count(y)) {\nreturn {m[y], i};\n}\nm[x] = i;\n}\n}\n};\n"]}, {"leetCodeID": "0009", "level": "easy", "question_description": "Given an integer x, return true if x is a palindrome, and false otherwise.", "examples": ["Example 1:\nInput: x = 121\nOutput: true\nExplanation: 121 reads as 121 from left to right and from right to left.\n", "Example 2:\nInput: x = -121\nOutput: false\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\n", "Example 3:\nInput: x = 10\nOutput: false\nExplanation: Reads 01 from right to left. Therefore it is not a palindrome.\n"], "constraints": "\nConstraints:\n-231&nbsp;<= x <= 231&nbsp;- 1\n", "java_context": "\nclass Solution {\n    public boolean isPalindrome(int x) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number} x\n* @return {boolean}\n*/\nvar isPalindrome = function (x) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    bool isPalindrome(int x) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic boolean isPalindrome(int x) {\nif (x < 0 || (x > 0 && x % 10 == 0)) {\nreturn false;\n}\nint y = 0;\nfor (; y < x; x /= 10) {\ny = y * 10 + x % 10;\n}\nreturn x == y || x == y / 10;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number} x\n* @return {boolean}\n*/\nvar isPalindrome = function (x) {\nif (x < 0 || (x > 0 && x % 10 === 0)) {\nreturn false;\n}\nlet y = 0;\nfor (; y < x; x = ~~(x / 10)) {\ny = y * 10 + (x % 10);\n}\nreturn x === y || x === ~~(y / 10);\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nbool isPalindrome(int x) {\nif (x < 0 || (x && x % 10 == 0)) {\nreturn false;\n}\nint y = 0;\nfor (; y < x; x /= 10) {\ny = y * 10 + x % 10;\n}\nreturn x == y || x == y / 10;\n}\n};\n"]}, {"leetCodeID": "0013", "level": "easy", "question_description": "Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\nFor example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\nI can be placed before V (5) and X (10) to make 4 and 9. \nX can be placed before L (50) and C (100) to make 40 and 90. \nC can be placed before D (500) and M (1000) to make 400 and 900.\nGiven a roman numeral, convert it to an integer.", "examples": ["Example 1:\nInput: s = &quot;III&quot;\nOutput: 3\nExplanation: III = 3.\n", "Example 2:\nInput: s = &quot;LVIII&quot;\nOutput: 58\nExplanation: L = 50, V= 5, III = 3.\n", "Example 3:\nInput: s = &quot;MCMXCIV&quot;\nOutput: 1994\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n"], "constraints": "\nConstraints:\n1 <= s.length <= 15\ns contains only&nbsp;the characters (&#39;I&#39;, &#39;V&#39;, &#39;X&#39;, &#39;L&#39;, &#39;C&#39;, &#39;D&#39;, &#39;M&#39;).\nIt is guaranteed&nbsp;that s is a valid roman numeral in the range [1, 3999].\n", "java_context": "\nclass Solution {\n    public int romanToInt(String s) {\n        // your code\n    }\n}", "js_context": "\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int romanToInt(string s) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int romanToInt(String s) {\nString cs = \"IVXLCDM\";\nint[] vs = {1, 5, 10, 50, 100, 500, 1000};\nMap<Character, Integer> d = new HashMap<>();\nfor (int i = 0; i < vs.length; ++i) {\nd.put(cs.charAt(i), vs[i]);\n}\nint n = s.length();\nint ans = d.get(s.charAt(n - 1));\nfor (int i = 0; i < n - 1; ++i) {\nint sign = d.get(s.charAt(i)) < d.get(s.charAt(i + 1)) ? -1 : 1;\nans += sign * d.get(s.charAt(i));\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\nconst romanToInt = function (s) {\nconst d = {\nI: 1,\nV: 5,\nX: 10,\nL: 50,\nC: 100,\nD: 500,\nM: 1000,\n};\nlet ans = d[s[s.length - 1]];\nfor (let i = 0; i < s.length - 1; ++i) {\nconst sign = d[s[i]] < d[s[i + 1]] ? -1 : 1;\nans += sign * d[s[i]];\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint romanToInt(string s) {\nunordered_map<char, int> nums{\n{'I', 1},\n{'V', 5},\n{'X', 10},\n{'L', 50},\n{'C', 100},\n{'D', 500},\n{'M', 1000},\n};\nint ans = nums[s.back()];\nfor (int i = 0; i < s.size() - 1; ++i) {\nint sign = nums[s[i]] < nums[s[i + 1]] ? -1 : 1;\nans += sign * nums[s[i]];\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0014", "level": "easy", "question_description": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string &quot;&quot;.", "examples": ["Example 1:\nInput: strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]\nOutput: &quot;fl&quot;\n", "Example 2:\nInput: strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]\nOutput: &quot;&quot;\nExplanation: There is no common prefix among the input strings.\n"], "constraints": "\nConstraints:\n1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only lowercase English letters.\n", "java_context": "\nclass Solution {\n    public String longestCommonPrefix(String[] strs) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string[]} strs\n* @return {string}\n*/\nvar longestCommonPrefix = function (strs) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic String longestCommonPrefix(String[] strs) {\nint n = strs.length;\nfor (int i = 0; i < strs[0].length(); ++i) {\nfor (int j = 1; j < n; ++j) {\nif (strs[j].length() <= i || strs[j].charAt(i) != strs[0].charAt(i)) {\nreturn strs[0].substring(0, i);\n}\n}\n}\nreturn strs[0];\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string[]} strs\n* @return {string}\n*/\nvar longestCommonPrefix = function (strs) {\nfor (let j = 0; j < strs[0].length; j++) {\nfor (let i = 0; i < strs.length; i++) {\nif (strs[0][j] !== strs[i][j]) {\nreturn strs[0].substring(0, j);\n}\n}\n}\nreturn strs[0];\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nstring longestCommonPrefix(vector<string>& strs) {\nint n = strs.size();\nfor (int i = 0; i < strs[0].size(); ++i) {\nfor (int j = 1; j < n; ++j) {\nif (strs[j].size() <= i || strs[j][i] != strs[0][i]) {\nreturn strs[0].substr(0, i);\n}\n}\n}\nreturn strs[0];\n}\n};\n"]}, {"leetCodeID": "0020", "level": "easy", "question_description": "Given a string s containing just the characters &#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;, determine if the input string is valid.\nAn input string is valid if:\nOpen brackets must be closed by the same type of brackets.\nOpen brackets must be closed in the correct order.\nEvery close bracket has a corresponding open bracket of the same type.", "examples": ["Example 1:\nInput: s = &quot;()&quot;\nOutput: true\n", "Example 2:\nInput: s = &quot;()[]{}&quot;\nOutput: true\n", "Example 3:\nInput: s = &quot;(]&quot;\nOutput: false\n"], "constraints": "\nConstraints:\n1 <= s.length <= 104\ns consists of parentheses only &#39;()[]{}&#39;.\n", "java_context": "\nclass Solution {\n    public boolean isValid(String s) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} s\n* @return {boolean}\n*/\nvar isValid = function (s) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    bool isValid(string s) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic boolean isValid(String s) {\nDeque<Character> stk = new ArrayDeque<>();\nfor (char c : s.toCharArray()) {\nif (c == '(' || c == '{' || c == '[') {\nstk.push(c);\n} else if (stk.isEmpty() || !match(stk.pop(), c)) {\nreturn false;\n}\n}\nreturn stk.isEmpty();\n}\n\nprivate boolean match(char l, char r) {\nreturn (l == '(' && r == ')') || (l == '{' && r == '}') || (l == '[' && r == ']');\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} s\n* @return {boolean}\n*/\nvar isValid = function (s) {\nlet stk = [];\nfor (const c of s) {\nif (c == '(' || c == '{' || c == '[') {\nstk.push(c);\n} else if (stk.length == 0 || !match(stk[stk.length - 1], c)) {\nreturn false;\n} else {\nstk.pop();\n}\n}\nreturn stk.length == 0;\n};\n\nfunction match(l, r) {\nreturn (l == '(' && r == ')') || (l == '[' && r == ']') || (l == '{' && r == '}');\n}\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nbool isValid(string s) {\nstring stk;\nfor (char c : s) {\nif (c == '(' || c == '{' || c == '[')\nstk.push_back(c);\nelse if (stk.empty() || !match(stk.back(), c))\nreturn false;\nelse\nstk.pop_back();\n}\nreturn stk.empty();\n}\n\nbool match(char l, char r) {\nreturn (l == '(' && r == ')') || (l == '[' && r == ']') || (l == '{' && r == '}');\n}\n};\n"]}, {"leetCodeID": "0021", "level": "easy", "question_description": "You are given the heads of two sorted linked lists list1 and list2.\nMerge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.\nReturn the head of the merged linked list.", "examples": ["Example 1:\n\n\nInput: list1 = [1,2,4], list2 = [1,3,4]\nOutput: [1,1,2,3,4,4]\n\n\nExample 2:\nInput: list1 = [], list2 = []\nOutput: []\n", "Example 3:\nInput: list1 = [], list2 = [0]\nOutput: [0]\n"], "constraints": "\nConstraints:\nThe number of nodes in both lists is in the range [0, 50].\n-100 <= Node.val <= 100\nBoth list1 and list2 are sorted in non-decreasing order.\n", "java_context": "\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode() {}\n*     ListNode(int val) { this.val = val; }\n*     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n* }\n*/\nclass Solution {\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for singly-linked list.\n* function ListNode(val, next) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.next = (next===undefined ? null : next)\n* }\n*/\n/**\n* @param {ListNode} list1\n* @param {ListNode} list2\n* @return {ListNode}\n*/\nvar mergeTwoLists = function (list1, list2) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode() {}\n*     ListNode(int val) { this.val = val; }\n*     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n* }\n*/\nclass Solution {\npublic ListNode mergeTwoLists(ListNode list1, ListNode list2) {\nif (list1 == null) {\nreturn list2;\n}\nif (list2 == null) {\nreturn list1;\n}\nif (list1.val <= list2.val) {\nlist1.next = mergeTwoLists(list1.next, list2);\nreturn list1;\n} else {\nlist2.next = mergeTwoLists(list1, list2.next);\nreturn list2;\n}\n}\n}\n", "\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode() {}\n*     ListNode(int val) { this.val = val; }\n*     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n* }\n*/\nclass Solution {\npublic ListNode mergeTwoLists(ListNode list1, ListNode list2) {\nListNode dummy = new ListNode();\nListNode curr = dummy;\nwhile (list1 != null && list2 != null) {\nif (list1.val <= list2.val) {\ncurr.next = list1;\nlist1 = list1.next;\n} else {\ncurr.next = list2;\nlist2 = list2.next;\n}\ncurr = curr.next;\n}\ncurr.next = list1 == null ? list2 : list1;\nreturn dummy.next;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for singly-linked list.\n* function ListNode(val, next) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.next = (next===undefined ? null : next)\n* }\n*/\n/**\n* @param {ListNode} list1\n* @param {ListNode} list2\n* @return {ListNode}\n*/\nvar mergeTwoLists = function (list1, list2) {\nif (!list1 || !list2) {\nreturn list1 || list2;\n}\nif (list1.val <= list2.val) {\nlist1.next = mergeTwoLists(list1.next, list2);\nreturn list1;\n} else {\nlist2.next = mergeTwoLists(list1, list2.next);\nreturn list2;\n}\n};\n", "\n/**\n* Definition for singly-linked list.\n* function ListNode(val, next) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.next = (next===undefined ? null : next)\n* }\n*/\n/**\n* @param {ListNode} list1\n* @param {ListNode} list2\n* @return {ListNode}\n*/\nvar mergeTwoLists = function (list1, list2) {\nconst dummy = new ListNode();\nlet curr = dummy;\nwhile (list1 && list2) {\nif (list1.val <= list2.val) {\ncurr.next = list1;\nlist1 = list1.next;\n} else {\ncurr.next = list2;\nlist2 = list2.next;\n}\ncurr = curr.next;\n}\ncurr.next = list1 || list2;\nreturn dummy.next;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\nclass Solution {\npublic:\nListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\nif (!list1) return list2;\nif (!list2) return list1;\nif (list1->val <= list2->val) {\nlist1->next = mergeTwoLists(list1->next, list2);\nreturn list1;\n} else {\nlist2->next = mergeTwoLists(list1, list2->next);\nreturn list2;\n}\n}\n};\n", "\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\nclass Solution {\npublic:\nListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\nListNode* dummy = new ListNode();\nListNode* curr = dummy;\nwhile (list1 && list2) {\nif (list1->val <= list2->val) {\ncurr->next = list1;\nlist1 = list1->next;\n} else {\ncurr->next = list2;\nlist2 = list2->next;\n}\ncurr = curr->next;\n}\ncurr->next = list1 ? list1 : list2;\nreturn dummy->next;\n}\n};\n"]}, {"leetCodeID": "0026", "level": "easy", "question_description": "Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.\nConsider the number of unique elements of nums to be k, to get accepted, you need to do the following things:\nChange the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums.\nReturn k.\nCustom Judge:\nThe judge will test your solution with the following code:\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\nint k = removeDuplicates(nums); // Calls your implementation\nassert k == expectedNums.length;\nfor (int i = 0; i &lt; k; i++) {\nassert nums[i] == expectedNums[i];\n}\nIf all assertions pass, then your solution will be accepted.", "examples": ["Example 1:\nInput: nums = [1,1,2]\nOutput: 2, nums = [1,2,_]\nExplanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n", "Example 2:\nInput: nums = [0,0,1,1,1,2,2,3,3,4]\nOutput: 5, nums = [0,1,2,3,4,_,_,_,_,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 3 * 104\n-100 <= nums[i] <= 100\nnums is sorted in non-decreasing order.\n", "java_context": "\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar removeDuplicates = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int removeDuplicates(int[] nums) {\nint k = 0;\nfor (int x : nums) {\nif (k == 0 || x != nums[k - 1]) {\nnums[k++] = x;\n}\n}\nreturn k;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar removeDuplicates = function (nums) {\nlet k = 0;\nfor (const x of nums) {\nif (k === 0 || x !== nums[k - 1]) {\nnums[k++] = x;\n}\n}\nreturn k;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint removeDuplicates(vector<int>& nums) {\nint k = 0;\nfor (int x : nums) {\nif (k == 0 || x != nums[k - 1]) {\nnums[k++] = x;\n}\n}\nreturn k;\n}\n};\n", "\nclass Solution {\npublic:\nint removeDuplicates(vector<int>& nums) {\nnums.erase(unique(nums.begin(), nums.end()), nums.end());\nreturn nums.size();\n}\n};\n"]}, {"leetCodeID": "0027", "level": "easy", "question_description": "Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.\nConsider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:\nChange the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums.\nReturn k.\nCustom Judge:\nThe judge will test your solution with the following code:\nint[] nums = [...]; // Input array\nint val = ...; // Value to remove\nint[] expectedNums = [...]; // The expected answer with correct length.\n// It is sorted with no values equaling val.\nint k = removeElement(nums, val); // Calls your implementation\nassert k == expectedNums.length;\nsort(nums, 0, k); // Sort the first k elements of nums\nfor (int i = 0; i &lt; actualLength; i++) {\nassert nums[i] == expectedNums[i];\n}\nIf all assertions pass, then your solution will be accepted.", "examples": ["Example 1:\nInput: nums = [3,2,2,3], val = 3\nOutput: 2, nums = [2,2,_,_]\nExplanation: Your function should return k = 2, with the first two elements of nums being 2.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n", "Example 2:\nInput: nums = [0,1,2,2,3,0,4,2], val = 2\nOutput: 5, nums = [0,1,4,0,3,_,_,_]\nExplanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\nNote that the five elements can be returned in any order.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n"], "constraints": "\nConstraints:\n0 <= nums.length <= 100\n0 <= nums[i] <= 50\n0 <= val <= 100\n", "java_context": "\nclass Solution {\n    public int removeElement(int[] nums, int val) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @param {number} val\n* @return {number}\n*/\nvar removeElement = function (nums, val) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int removeElement(vector<int>& nums, int val) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int removeElement(int[] nums, int val) {\nint k = 0;\nfor (int x : nums) {\nif (x != val) {\nnums[k++] = x;\n}\n}\nreturn k;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @param {number} val\n* @return {number}\n*/\nvar removeElement = function (nums, val) {\nlet k = 0;\nfor (const x of nums) {\nif (x !== val) {\nnums[k++] = x;\n}\n}\nreturn k;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint removeElement(vector<int>& nums, int val) {\nint k = 0;\nfor (int x : nums) {\nif (x != val) {\nnums[k++] = x;\n}\n}\nreturn k;\n}\n};\n"]}, {"leetCodeID": "0028", "level": "easy", "question_description": "Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.", "examples": ["Example 1:\nInput: haystack = &quot;sadbutsad&quot;, needle = &quot;sad&quot;\nOutput: 0\nExplanation: &quot;sad&quot; occurs at index 0 and 6.\nThe first occurrence is at index 0, so we return 0.\n", "Example 2:\nInput: haystack = &quot;leetcode&quot;, needle = &quot;leeto&quot;\nOutput: -1\nExplanation: &quot;leeto&quot; did not occur in &quot;leetcode&quot;, so we return -1.\n"], "constraints": "\nConstraints:\n1 <= haystack.length, needle.length <= 104\nhaystack and needle consist of only lowercase English characters.\n", "java_context": "\nclass Solution {\n    public int strStr(String haystack, String needle) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} haystack\n* @param {string} needle\n* @return {number}\n*/\nvar strStr = function (haystack, needle) {\n    // your code\n};", "cpp_context": "\nclass Solution {\nprivate:\n    vector<int> Next(string str) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int strStr(String haystack, String needle) {\nif (\"\".equals(needle)) {\nreturn 0;\n}\n\nint len1 = haystack.length();\nint len2 = needle.length();\nint p = 0;\nint q = 0;\nwhile (p < len1) {\nif (haystack.charAt(p) == needle.charAt(q)) {\nif (len2 == 1) {\nreturn p;\n}\n++p;\n++q;\n} else {\np -= q - 1;\nq = 0;\n}\n\nif (q == len2) {\nreturn p - q;\n}\n}\nreturn -1;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} haystack\n* @param {string} needle\n* @return {number}\n*/\nvar strStr = function (haystack, needle) {\nconst slen = haystack.length;\nconst plen = needle.length;\nif (slen == plen) {\nreturn haystack == needle ? 0 : -1;\n}\nfor (let i = 0; i <= slen - plen; i++) {\nlet j;\nfor (j = 0; j < plen; j++) {\nif (haystack[i + j] != needle[j]) {\nbreak;\n}\n}\nif (j == plen) return i;\n}\nreturn -1;\n};\n"], "cpp_solutions": ["\nclass Solution {\nprivate:\nvector<int> Next(string str) {\nvector<int> n(str.length());\nn[0] = -1;\nint i = 0, pre = -1;\nint len = str.length();\nwhile (i < len) {\nwhile (pre >= 0 && str[i] != str[pre])\npre = n[pre];\n++i, ++pre;\nif (i >= len)\nbreak;\nif (str[i] == str[pre])\nn[i] = n[pre];\nelse\nn[i] = pre;\n}\nreturn n;\n}\n\npublic:\nint strStr(string haystack, string needle) {\nif (0 == needle.length())\nreturn 0;\n\nvector<int> n(Next(needle));\n\nint len = haystack.length() - needle.length() + 1;\nfor (int i = 0; i < len; ++i) {\nint j = 0, k = i;\nwhile (j < needle.length() && k < haystack.length()) {\nif (haystack[k] != needle[j]) {\nif (n[j] >= 0) {\nj = n[j];\ncontinue;\n} else\nbreak;\n}\n++k, ++j;\n}\nif (j >= needle.length())\nreturn k - j;\n}\n\nreturn -1;\n}\n};\n"]}, {"leetCodeID": "0035", "level": "easy", "question_description": "Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\nYou must write an algorithm with O(log n) runtime complexity.", "examples": ["Example 1:\nInput: nums = [1,3,5,6], target = 5\nOutput: 2\n", "Example 2:\nInput: nums = [1,3,5,6], target = 2\nOutput: 1\n", "Example 3:\nInput: nums = [1,3,5,6], target = 7\nOutput: 4\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 104\n-104 <= nums[i] <= 104\nnums contains distinct values sorted in ascending order.\n-104 <= target <= 104\n", "java_context": "\nclass Solution {\n    public int searchInsert(int[] nums, int target) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @param {number} target\n* @return {number}\n*/\nvar searchInsert = function (nums, target) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int searchInsert(vector<int>& nums, int target) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int searchInsert(int[] nums, int target) {\nint left = 0, right = nums.length;\nwhile (left < right) {\nint mid = (left + right) >>> 1;\nif (nums[mid] >= target) {\nright = mid;\n} else {\nleft = mid + 1;\n}\n}\nreturn left;\n}\n}\n", "\nclass Solution {\npublic int searchInsert(int[] nums, int target) {\nint i = Arrays.binarySearch(nums, target);\nreturn i < 0 ? -i - 1 : i;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @param {number} target\n* @return {number}\n*/\nvar searchInsert = function (nums, target) {\nlet left = 0;\nlet right = nums.length;\nwhile (left < right) {\nconst mid = (left + right) >> 1;\nif (nums[mid] >= target) {\nright = mid;\n} else {\nleft = mid + 1;\n}\n}\nreturn left;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint searchInsert(vector<int>& nums, int target) {\nint left = 0, right = nums.size();\nwhile (left < right) {\nint mid = left + right >> 1;\nif (nums[mid] >= target)\nright = mid;\nelse\nleft = mid + 1;\n}\nreturn left;\n}\n};\n", "\nclass Solution {\npublic:\nint searchInsert(vector<int>& nums, int target) {\nreturn lower_bound(nums.begin(), nums.end(), target) - nums.begin();\n}\n};\n"]}, {"leetCodeID": "0058", "level": "easy", "question_description": "Given a string s consisting of words and spaces, return the length of the last word in the string.\nA word is a maximal substring consisting of non-space characters only.", "examples": ["Example 1:\nInput: s = &quot;Hello World&quot;\nOutput: 5\nExplanation: The last word is &quot;World&quot; with length 5.\n", "Example 2:\nInput: s = &quot;   fly me   to   the moon  &quot;\nOutput: 4\nExplanation: The last word is &quot;moon&quot; with length 4.\n", "Example 3:\nInput: s = &quot;luffy is still joyboy&quot;\nOutput: 6\nExplanation: The last word is &quot;joyboy&quot; with length 6.\n"], "constraints": "\nConstraints:\n1 <= s.length <= 104\ns consists of only English letters and spaces &#39; &#39;.\nThere will be at least one word in s.\n", "java_context": "\nclass Solution {\n    public int lengthOfLastWord(String s) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} s\n* @return {number}\n*/\nvar lengthOfLastWord = function (s) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int lengthOfLastWord(string s) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int lengthOfLastWord(String s) {\nint i = s.length() - 1;\nwhile (i >= 0 && s.charAt(i) == ' ') {\n--i;\n}\nint j = i;\nwhile (j >= 0 && s.charAt(j) != ' ') {\n--j;\n}\nreturn i - j;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} s\n* @return {number}\n*/\nvar lengthOfLastWord = function (s) {\nlet i = s.length - 1;\nwhile (i >= 0 && s[i] === ' ') {\n--i;\n}\nlet j = i;\nwhile (j >= 0 && s[j] !== ' ') {\n--j;\n}\nreturn i - j;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint lengthOfLastWord(string s) {\nint i = s.size() - 1;\nwhile (~i && s[i] == ' ') {\n--i;\n}\nint j = i;\nwhile (~j && s[j] != ' ') {\n--j;\n}\nreturn i - j;\n}\n};\n"]}, {"leetCodeID": "0066", "level": "easy", "question_description": "You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0&#39;s.\nIncrement the large integer by one and return the resulting array of digits.", "examples": ["Example 1:\nInput: digits = [1,2,3]\nOutput: [1,2,4]\nExplanation: The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be [1,2,4].\n", "Example 2:\nInput: digits = [4,3,2,1]\nOutput: [4,3,2,2]\nExplanation: The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be [4,3,2,2].\n", "Example 3:\nInput: digits = [9]\nOutput: [1,0]\nExplanation: The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be [1,0].\n"], "constraints": "\nConstraints:\n1 <= digits.length <= 100\n0 <= digits[i] <= 9\ndigits does not contain any leading 0&#39;s.\n", "java_context": "\nclass Solution {\n    public int[] plusOne(int[] digits) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} digits\n* @return {number[]}\n*/\nvar plusOne = function (digits) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> plusOne(vector<int>& digits) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int[] plusOne(int[] digits) {\nint n = digits.length;\nfor (int i = n - 1; i >= 0; --i) {\n++digits[i];\ndigits[i] %= 10;\nif (digits[i] != 0) {\nreturn digits;\n}\n}\ndigits = new int[n + 1];\ndigits[0] = 1;\nreturn digits;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} digits\n* @return {number[]}\n*/\nvar plusOne = function (digits) {\nfor (let i = digits.length - 1; i >= 0; --i) {\n++digits[i];\ndigits[i] %= 10;\nif (digits[i] != 0) {\nreturn digits;\n}\n}\nreturn [1, ...digits];\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> plusOne(vector<int>& digits) {\nfor (int i = digits.size() - 1; i >= 0; --i) {\n++digits[i];\ndigits[i] %= 10;\nif (digits[i] != 0) return digits;\n}\ndigits.insert(digits.begin(), 1);\nreturn digits;\n}\n};\n"]}, {"leetCodeID": "0069", "level": "easy", "question_description": "Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.\nYou must not use any built-in exponent function or operator.\nFor example, do not use pow(x, 0.5) in c++ or x ** 0.5 in python.", "examples": ["Example 1:\nInput: x = 4\nOutput: 2\nExplanation: The square root of 4 is 2, so we return 2.\n", "Example 2:\nInput: x = 8\nOutput: 2\nExplanation: The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned.\n"], "constraints": "\nConstraints:\n0 <= x <= 231 - 1\n", "java_context": "\nclass Solution {\n    public int mySqrt(int x) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number} x\n* @return {number}\n*/\nvar mySqrt = function (x) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int mySqrt(int x) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int mySqrt(int x) {\nint l = 0, r = x;\nwhile (l < r) {\nint mid = (l + r + 1) >>> 1;\nif (mid > x / mid) {\nr = mid - 1;\n} else {\nl = mid;\n}\n}\nreturn l;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number} x\n* @return {number}\n*/\nvar mySqrt = function (x) {\nlet [l, r] = [0, x];\nwhile (l < r) {\nconst mid = (l + r + 1) >> 1;\nif (mid > x / mid) {\nr = mid - 1;\n} else {\nl = mid;\n}\n}\nreturn l;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint mySqrt(int x) {\nint l = 0, r = x;\nwhile (l < r) {\nint mid = (l + r + 1ll) >> 1;\nif (mid > x / mid) {\nr = mid - 1;\n} else {\nl = mid;\n}\n}\nreturn l;\n}\n};\n"]}, {"leetCodeID": "0070", "level": "easy", "question_description": "You are climbing a staircase. It takes n steps to reach the top.\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?", "examples": ["Example 1:\nInput: n = 2\nOutput: 2\nExplanation: There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps\n", "Example 2:\nInput: n = 3\nOutput: 3\nExplanation: There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n"], "constraints": "\nConstraints:\n1 <= n <= 45\n", "java_context": "\nclass Solution {\n    public int climbStairs(int n) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number} n\n* @return {number}\n*/\nvar climbStairs = function (n) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int climbStairs(int n) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int climbStairs(int n) {\nint a = 0, b = 1;\nfor (int i = 0; i < n; ++i) {\nint c = a + b;\na = b;\nb = c;\n}\nreturn b;\n}\n}\n", "\nclass Solution {\nprivate final int[][] a = {{1, 1}, {1, 0}};\n\npublic int climbStairs(int n) {\nreturn pow(a, n - 1)[0][0];\n}\n\nprivate int[][] mul(int[][] a, int[][] b) {\nint m = a.length, n = b[0].length;\nint[][] c = new int[m][n];\nfor (int i = 0; i < m; ++i) {\nfor (int j = 0; j < n; ++j) {\nfor (int k = 0; k < a[0].length; ++k) {\nc[i][j] += a[i][k] * b[k][j];\n}\n}\n}\nreturn c;\n}\n\nprivate int[][] pow(int[][] a, int n) {\nint[][] res = {{1, 1}, {0, 0}};\nwhile (n > 0) {\nif ((n & 1) == 1) {\nres = mul(res, a);\n}\nn >>= 1;\na = mul(a, a);\n}\nreturn res;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number} n\n* @return {number}\n*/\nvar climbStairs = function (n) {\nlet a = 0,\nb = 1;\nfor (let i = 0; i < n; ++i) {\nconst c = a + b;\na = b;\nb = c;\n}\nreturn b;\n};\n", "\n/**\n* @param {number} n\n* @return {number}\n*/\nvar climbStairs = function (n) {\nconst a = [\n[1, 1],\n[1, 0],\n];\nreturn pow(a, n - 1)[0][0];\n};\n\nfunction mul(a, b) {\nconst [m, n] = [a.length, b[0].length];\nconst c = Array(m)\n.fill(0)\n.map(() => Array(n).fill(0));\nfor (let i = 0; i < m; ++i) {\nfor (let j = 0; j < n; ++j) {\nfor (let k = 0; k < a[0].length; ++k) {\nc[i][j] += a[i][k] * b[k][j];\n}\n}\n}\nreturn c;\n}\n\nfunction pow(a, n) {\nlet res = [\n[1, 1],\n[0, 0],\n];\nwhile (n) {\nif (n & 1) {\nres = mul(res, a);\n}\na = mul(a, a);\nn >>= 1;\n}\nreturn res;\n}\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint climbStairs(int n) {\nint a = 0, b = 1;\nfor (int i = 0; i < n; ++i) {\nint c = a + b;\na = b;\nb = c;\n}\nreturn b;\n}\n};\n", "\nclass Solution {\npublic:\nint climbStairs(int n) {\nvector<vector<long long>> a = {{1, 1}, {1, 0}};\nreturn pow(a, n - 1)[0][0];\n}\n\nprivate:\nvector<vector<long long>> mul(vector<vector<long long>>& a, vector<vector<long long>>& b) {\nint m = a.size(), n = b[0].size();\nvector<vector<long long>> res(m, vector<long long>(n));\nfor (int i = 0; i < m; ++i) {\nfor (int j = 0; j < n; ++j) {\nfor (int k = 0; k < a[0].size(); ++k) {\nres[i][j] += a[i][k] * b[k][j];\n}\n}\n}\nreturn res;\n}\n\nvector<vector<long long>> pow(vector<vector<long long>>& a, int n) {\nvector<vector<long long>> res = {{1, 1}, {0, 0}};\nwhile (n) {\nif (n & 1) {\nres = mul(res, a);\n}\na = mul(a, a);\nn >>= 1;\n}\nreturn res;\n}\n};\n"]}, {"leetCodeID": "0083", "level": "easy", "question_description": "Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.", "examples": [], "constraints": "\nConstraints:\nThe number of nodes in the list is in the range [0, 300].\n-100 <= Node.val <= 100\nThe list is guaranteed to be sorted in ascending order.\n", "java_context": "\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode() {}\n*     ListNode(int val) { this.val = val; }\n*     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n* }\n*/\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for singly-linked list.\n* function ListNode(val) {\n*     this.val = val;\n*     this.next = null;\n* }\n*/\n/**\n* @param {ListNode} head\n* @return {ListNode}\n*/\nvar deleteDuplicates = function (head) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode() {}\n*     ListNode(int val) { this.val = val; }\n*     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n* }\n*/\nclass Solution {\npublic ListNode deleteDuplicates(ListNode head) {\nListNode cur = head;\nwhile (cur != null && cur.next != null) {\nif (cur.val == cur.next.val) {\ncur.next = cur.next.next;\n} else {\ncur = cur.next;\n}\n}\nreturn head;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for singly-linked list.\n* function ListNode(val) {\n*     this.val = val;\n*     this.next = null;\n* }\n*/\n/**\n* @param {ListNode} head\n* @return {ListNode}\n*/\nvar deleteDuplicates = function (head) {\nlet cur = head;\nwhile (cur && cur.next) {\nif (cur.next.val === cur.val) {\ncur.next = cur.next.next;\n} else {\ncur = cur.next;\n}\n}\nreturn head;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\nclass Solution {\npublic:\nListNode* deleteDuplicates(ListNode* head) {\nListNode* cur = head;\nwhile (cur != nullptr && cur->next != nullptr) {\nif (cur->val == cur->next->val) {\ncur->next = cur->next->next;\n} else {\ncur = cur->next;\n}\n}\nreturn head;\n}\n};\n"]}, {"leetCodeID": "0088", "level": "easy", "question_description": "You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\nMerge nums1 and nums2 into a single array sorted in non-decreasing order.\nThe final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.", "examples": ["Example 1:\nInput: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\nOutput: [1,2,2,3,5,6]\nExplanation: The arrays we are merging are [1,2,3] and [2,5,6].\nThe result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.\n", "Example 2:\nInput: nums1 = [1], m = 1, nums2 = [], n = 0\nOutput: [1]\nExplanation: The arrays we are merging are [1] and [].\nThe result of the merge is [1].\n", "Example 3:\nInput: nums1 = [0], m = 0, nums2 = [1], n = 1\nOutput: [1]\nExplanation: The arrays we are merging are [] and [1].\nThe result of the merge is [1].\nNote that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.\n"], "constraints": "\nConstraints:\nnums1.length == m + n\nnums2.length == n\n0 <= m, n <= 200\n1 <= m + n <= 200\n-109 <= nums1[i], nums2[j] <= 109\n", "java_context": "\nclass Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums1\n* @param {number} m\n* @param {number[]} nums2\n* @param {number} n\n* @return {void} Do not return anything, modify nums1 in-place instead.\n*/\nvar merge = function (nums1, m, nums2, n) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic void merge(int[] nums1, int m, int[] nums2, int n) {\nfor (int i = m - 1, j = n - 1, k = m + n - 1; j >= 0; --k) {\nnums1[k] = i >= 0 && nums1[i] > nums2[j] ? nums1[i--] : nums2[j--];\n}\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums1\n* @param {number} m\n* @param {number[]} nums2\n* @param {number} n\n* @return {void} Do not return anything, modify nums1 in-place instead.\n*/\nvar merge = function (nums1, m, nums2, n) {\nfor (let i = m - 1, j = n - 1, k = m + n - 1; j >= 0; --k) {\nnums1[k] = i >= 0 && nums1[i] > nums2[j] ? nums1[i--] : nums2[j--];\n}\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvoid merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\nfor (int i = m - 1, j = n - 1, k = m + n - 1; ~j; --k) {\nnums1[k] = i >= 0 && nums1[i] > nums2[j] ? nums1[i--] : nums2[j--];\n}\n}\n};\n"]}, {"leetCodeID": "0094", "level": "easy", "question_description": "Given the root of a binary tree, return the inorder traversal of its nodes&#39; values.", "examples": ["Example 1:\n\n\nInput: root = [1,null,2,3]\nOutput: [1,3,2]\n\n\nExample 2:\nInput: root = []\nOutput: []\n", "Example 3:\nInput: root = [1]\nOutput: [1]\n"], "constraints": "\nConstraints:\nThe number of nodes in the tree is in the range [0, 100].\n-100 <= Node.val <= 100\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\n    private List<Integer> ans = new ArrayList<>();\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {number[]}\n*/\nvar inorderTraversal = function (root) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    vector<int> inorderTraversal(TreeNode* root) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\nprivate List<Integer> ans = new ArrayList<>();\n\npublic List<Integer> inorderTraversal(TreeNode root) {\ndfs(root);\nreturn ans;\n}\n\nprivate void dfs(TreeNode root) {\nif (root == null) {\nreturn;\n}\ndfs(root.left);\nans.add(root.val);\ndfs(root.right);\n}\n}\n", "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\npublic List<Integer> inorderTraversal(TreeNode root) {\nList<Integer> ans = new ArrayList<>();\nDeque<TreeNode> stk = new ArrayDeque<>();\nwhile (root != null || !stk.isEmpty()) {\nif (root != null) {\nstk.push(root);\nroot = root.left;\n} else {\nroot = stk.pop();\nans.add(root.val);\nroot = root.right;\n}\n}\nreturn ans;\n}\n}\n", "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\npublic List<Integer> inorderTraversal(TreeNode root) {\nList<Integer> ans = new ArrayList<>();\nwhile (root != null) {\nif (root.left == null) {\nans.add(root.val);\nroot = root.right;\n} else {\nTreeNode prev = root.left;\nwhile (prev.right != null && prev.right != root) {\nprev = prev.right;\n}\nif (prev.right == null) {\nprev.right = root;\nroot = root.left;\n} else {\nans.add(root.val);\nprev.right = null;\nroot = root.right;\n}\n}\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {number[]}\n*/\nvar inorderTraversal = function (root) {\nconst ans = [];\nconst dfs = root => {\nif (!root) {\nreturn;\n}\ndfs(root.left);\nans.push(root.val);\ndfs(root.right);\n};\ndfs(root);\nreturn ans;\n};\n", "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {number[]}\n*/\nvar inorderTraversal = function (root) {\nconst stk = [];\nconst ans = [];\nwhile (root || stk.length > 0) {\nif (root) {\nstk.push(root);\nroot = root.left;\n} else {\nroot = stk.pop();\nans.push(root.val);\nroot = root.right;\n}\n}\nreturn ans;\n};\n", "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {number[]}\n*/\nvar inorderTraversal = function (root) {\nconst ans = [];\nwhile (root) {\nif (!root.left) {\nans.push(root.val);\nroot = root.right;\n} else {\nlet prev = root.left;\nwhile (prev.right && prev.right != root) {\nprev = prev.right;\n}\nif (!prev.right) {\nprev.right = root;\nroot = root.left;\n} else {\nans.push(root.val);\nprev.right = null;\nroot = root.right;\n}\n}\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nvector<int> inorderTraversal(TreeNode* root) {\nvector<int> ans;\nfunction<void(TreeNode*)> dfs = [&](TreeNode* root) {\nif (!root) {\nreturn;\n}\ndfs(root->left);\nans.push_back(root->val);\ndfs(root->right);\n};\ndfs(root);\nreturn ans;\n}\n};\n", "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nvector<int> inorderTraversal(TreeNode* root) {\nvector<int> ans;\nstack<TreeNode*> stk;\nwhile (root || stk.size()) {\nif (root) {\nstk.push(root);\nroot = root->left;\n} else {\nroot = stk.top();\nstk.pop();\nans.push_back(root->val);\nroot = root->right;\n}\n}\nreturn ans;\n}\n};\n", "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nvector<int> inorderTraversal(TreeNode* root) {\nvector<int> ans;\nwhile (root) {\nif (!root->left) {\nans.push_back(root->val);\nroot = root->right;\n} else {\nTreeNode* prev = root->left;\nwhile (prev->right && prev->right != root) {\nprev = prev->right;\n}\nif (!prev->right) {\nprev->right = root;\nroot = root->left;\n} else {\nans.push_back(root->val);\nprev->right = nullptr;\nroot = root->right;\n}\n}\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0100", "level": "easy", "question_description": "Given the roots of two binary trees p and q, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.", "examples": [], "constraints": "\nConstraints:\nThe number of nodes in both trees is in the range [0, 100].\n-104 <= Node.val <= 104\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} p\n* @param {TreeNode} q\n* @return {boolean}\n*/\nvar isSameTree = function (p, q) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\npublic boolean isSameTree(TreeNode p, TreeNode q) {\nif (p == q) return true;\nif (p == null || q == null || p.val != q.val) return false;\nreturn isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n}\n}\n", "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\npublic boolean isSameTree(TreeNode p, TreeNode q) {\nif (p == q) {\nreturn true;\n}\nif (p == null || q == null) {\nreturn false;\n}\nDeque<TreeNode> q1 = new ArrayDeque<>();\nDeque<TreeNode> q2 = new ArrayDeque<>();\nq1.offer(p);\nq2.offer(q);\nwhile (!q1.isEmpty() && !q2.isEmpty()) {\np = q1.poll();\nq = q2.poll();\nif (p.val != q.val) {\nreturn false;\n}\nTreeNode la = p.left, ra = p.right;\nTreeNode lb = q.left, rb = q.right;\nif ((la != null && lb == null) || (lb != null && la == null)) {\nreturn false;\n}\nif ((ra != null && rb == null) || (rb != null && ra == null)) {\nreturn false;\n}\nif (la != null) {\nq1.offer(la);\nq2.offer(lb);\n}\nif (ra != null) {\nq1.offer(ra);\nq2.offer(rb);\n}\n}\nreturn true;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} p\n* @param {TreeNode} q\n* @return {boolean}\n*/\nvar isSameTree = function (p, q) {\nif (!p && !q) return true;\nif (p && q) {\nreturn p.val === q.val && isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n}\nreturn false;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nbool isSameTree(TreeNode* p, TreeNode* q) {\nif (p == q) return true;\nif (!p || !q || p->val != q->val) return false;\nreturn isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n}\n};\n", "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nbool isSameTree(TreeNode* p, TreeNode* q) {\nif (p == q) return true;\nif (!p || !q) return false;\nqueue<TreeNode*> q1{{p}};\nqueue<TreeNode*> q2{{q}};\nwhile (!q1.empty() && !q2.empty()) {\np = q1.front();\nq = q2.front();\nif (p->val != q->val) return false;\nq1.pop();\nq2.pop();\nTreeNode *la = p->left, *ra = p->right;\nTreeNode *lb = q->left, *rb = q->right;\nif ((la && !lb) || (lb && !la)) return false;\nif ((ra && !rb) || (rb && !ra)) return false;\nif (la) {\nq1.push(la);\nq2.push(lb);\n}\nif (ra) {\nq1.push(ra);\nq2.push(rb);\n}\n}\nreturn true;\n}\n};\n"]}, {"leetCodeID": "0101", "level": "easy", "question_description": "Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).", "examples": [], "constraints": "\nConstraints:\nThe number of nodes in the tree is in the range [1, 1000].\n-100 <= Node.val <= 100\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\n    public boolean isSymmetric(TreeNode root) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {boolean}\n*/\nvar isSymmetric = function (root) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    bool isSymmetric(TreeNode* root) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\npublic boolean isSymmetric(TreeNode root) {\nreturn dfs(root, root);\n}\n\nprivate boolean dfs(TreeNode root1, TreeNode root2) {\nif (root1 == null && root2 == null) {\nreturn true;\n}\nif (root1 == null || root2 == null || root1.val != root2.val) {\nreturn false;\n}\nreturn dfs(root1.left, root2.right) && dfs(root1.right, root2.left);\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {boolean}\n*/\nvar isSymmetric = function (root) {\nfunction dfs(root1, root2) {\nif (!root1 && !root2) return true;\nif (!root1 || !root2 || root1.val != root2.val) return false;\nreturn dfs(root1.left, root2.right) && dfs(root1.right, root2.left);\n}\nreturn dfs(root, root);\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nbool isSymmetric(TreeNode* root) {\nfunction<bool(TreeNode*, TreeNode*)> dfs = [&](TreeNode* root1, TreeNode* root2) -> bool {\nif (!root1 && !root2) return true;\nif (!root1 || !root2 || root1->val != root2->val) return false;\nreturn dfs(root1->left, root2->right) && dfs(root1->right, root2->left);\n};\nreturn dfs(root, root);\n}\n};\n"]}, {"leetCodeID": "0104", "level": "easy", "question_description": "Given the root of a binary tree, return its maximum depth.\nA binary tree&#39;s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.", "examples": ["Example 1:\n\n\nInput: root = [3,9,20,null,null,15,7]\nOutput: 3\n\n\nExample 2:\nInput: root = [1,null,2]\nOutput: 2\n"], "constraints": "\nConstraints:\nThe number of nodes in the tree is in the range [0, 104].\n-100 <= Node.val <= 100\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {number}\n*/\nvar maxDepth = function (root) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\npublic int maxDepth(TreeNode root) {\nif (root == null) {\nreturn 0;\n}\nint l = maxDepth(root.left);\nint r = maxDepth(root.right);\nreturn 1 + Math.max(l, r);\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {number}\n*/\nvar maxDepth = function (root) {\nif (!root) return 0;\nconst l = maxDepth(root.left);\nconst r = maxDepth(root.right);\nreturn 1 + Math.max(l, r);\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nint maxDepth(TreeNode* root) {\nif (!root) return 0;\nint l = maxDepth(root->left), r = maxDepth(root->right);\nreturn 1 + max(l, r);\n}\n};\n"]}, {"leetCodeID": "0108", "level": "easy", "question_description": "Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.", "examples": [], "constraints": "\nConstraints:\n1 <= nums.length <= 104\n-104 <= nums[i] <= 104\nnums is sorted in a strictly increasing order.\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\n    private int[] nums;\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {number[]} nums\n* @return {TreeNode}\n*/\nvar sortedArrayToBST = function (nums) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    TreeNode* sortedArrayToBST(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\nprivate int[] nums;\n\npublic TreeNode sortedArrayToBST(int[] nums) {\nthis.nums = nums;\nreturn dfs(0, nums.length - 1);\n}\n\nprivate TreeNode dfs(int l, int r) {\nif (l > r) {\nreturn null;\n}\nint mid = (l + r) >> 1;\nTreeNode left = dfs(l, mid - 1);\nTreeNode right = dfs(mid + 1, r);\nreturn new TreeNode(nums[mid], left, right);\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {number[]} nums\n* @return {TreeNode}\n*/\nvar sortedArrayToBST = function (nums) {\nconst dfs = (l, r) => {\nif (l > r) {\nreturn null;\n}\nconst mid = (l + r) >> 1;\nconst left = dfs(l, mid - 1);\nconst right = dfs(mid + 1, r);\nreturn new TreeNode(nums[mid], left, right);\n};\nreturn dfs(0, nums.length - 1);\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nTreeNode* sortedArrayToBST(vector<int>& nums) {\nfunction<TreeNode*(int, int)> dfs = [&](int l, int r) -> TreeNode* {\nif (l > r) {\nreturn nullptr;\n}\nint mid = (l + r) >> 1;\nauto left = dfs(l, mid - 1);\nauto right = dfs(mid + 1, r);\nreturn new TreeNode(nums[mid], left, right);\n};\nreturn dfs(0, nums.size() - 1);\n}\n};\n"]}, {"leetCodeID": "0110", "level": "easy", "question_description": "Given a binary tree, determine if it is height-balanced.", "examples": ["Example 1:\n\n\nInput: root = [3,9,20,null,null,15,7]\nOutput: true\n\n\nExample 2:\n\n\nInput: root = [1,2,2,3,3,null,null,4,4]\nOutput: false\n\n\nExample 3:\nInput: root = []\nOutput: true\n"], "constraints": "\nConstraints:\nThe number of nodes in the tree is in the range [0, 5000].\n-104 <= Node.val <= 104\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\n    public boolean isBalanced(TreeNode root) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {boolean}\n*/\nvar isBalanced = function (root) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    bool isBalanced(TreeNode* root) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\npublic boolean isBalanced(TreeNode root) {\nreturn height(root) >= 0;\n}\n\nprivate int height(TreeNode root) {\nif (root == null) {\nreturn 0;\n}\nint l = height(root.left);\nint r = height(root.right);\nif (l == -1 || r == -1 || Math.abs(l - r) > 1) {\nreturn -1;\n}\nreturn 1 + Math.max(l, r);\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {boolean}\n*/\nvar isBalanced = function (root) {\nconst height = root => {\nif (!root) {\nreturn 0;\n}\nconst l = height(root.left);\nconst r = height(root.right);\nif (l == -1 || r == -1 || Math.abs(l - r) > 1) {\nreturn -1;\n}\nreturn 1 + Math.max(l, r);\n};\nreturn height(root) >= 0;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nbool isBalanced(TreeNode* root) {\nfunction<int(TreeNode*)> height = [&](TreeNode* root) {\nif (!root) {\nreturn 0;\n}\nint l = height(root->left);\nint r = height(root->right);\nif (l == -1 || r == -1 || abs(l - r) > 1) {\nreturn -1;\n}\nreturn 1 + max(l, r);\n};\nreturn height(root) >= 0;\n}\n};\n"]}, {"leetCodeID": "0111", "level": "easy", "question_description": "Given a binary tree, find its minimum depth.\nThe minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.\nNote: A leaf is a node with no children.", "examples": ["Example 1:\n\n\nInput: root = [3,9,20,null,null,15,7]\nOutput: 2\n\n\nExample 2:\nInput: root = [2,null,3,null,4,null,5,null,6]\nOutput: 5\n"], "constraints": "\nConstraints:\nThe number of nodes in the tree is in the range [0, 105].\n-1000 <= Node.val <= 1000\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\n    public int minDepth(TreeNode root) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {number}\n*/\nvar minDepth = function (root) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    int minDepth(TreeNode* root) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\npublic int minDepth(TreeNode root) {\nif (root == null) {\nreturn 0;\n}\nif (root.left == null) {\nreturn 1 + minDepth(root.right);\n}\nif (root.right == null) {\nreturn 1 + minDepth(root.left);\n}\nreturn 1 + Math.min(minDepth(root.left), minDepth(root.right));\n}\n}\n", "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\npublic int minDepth(TreeNode root) {\nif (root == null) {\nreturn 0;\n}\nDeque<TreeNode> q = new ArrayDeque<>();\nq.offer(root);\nint ans = 0;\nwhile (true) {\n++ans;\nfor (int n = q.size(); n > 0; n--) {\nTreeNode node = q.poll();\nif (node.left == null && node.right == null) {\nreturn ans;\n}\nif (node.left != null) {\nq.offer(node.left);\n}\nif (node.right != null) {\nq.offer(node.right);\n}\n}\n}\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {number}\n*/\nvar minDepth = function (root) {\nif (!root) {\nreturn 0;\n}\nif (!root.left) {\nreturn 1 + minDepth(root.right);\n}\nif (!root.right) {\nreturn 1 + minDepth(root.left);\n}\nreturn 1 + Math.min(minDepth(root.left), minDepth(root.right));\n};\n", "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {number}\n*/\nvar minDepth = function (root) {\nif (!root) {\nreturn 0;\n}\nconst q = [root];\nlet ans = 0;\nwhile (1) {\n++ans;\nfor (let n = q.length; n; --n) {\nconst node = q.shift();\nif (!node.left && !node.right) {\nreturn ans;\n}\nif (node.left) {\nq.push(node.left);\n}\nif (node.right) {\nq.push(node.right);\n}\n}\n}\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nint minDepth(TreeNode* root) {\nif (!root) {\nreturn 0;\n}\nif (!root->left) {\nreturn 1 + minDepth(root->right);\n}\nif (!root->right) {\nreturn 1 + minDepth(root->left);\n}\nreturn 1 + min(minDepth(root->left), minDepth(root->right));\n}\n};\n", "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nint minDepth(TreeNode* root) {\nif (!root) {\nreturn 0;\n}\nqueue<TreeNode*> q{{root}};\nint ans = 0;\nwhile (1) {\n++ans;\nfor (int n = q.size(); n; --n) {\nauto node = q.front();\nq.pop();\nif (!node->left && !node->right) {\nreturn ans;\n}\nif (node->left) {\nq.push(node->left);\n}\nif (node->right) {\nq.push(node->right);\n}\n}\n}\n}\n};\n"]}, {"leetCodeID": "0112", "level": "easy", "question_description": "Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.\nA leaf is a node with no children.", "examples": ["Example 1:\n\n\nInput: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22\nOutput: true\nExplanation: The root-to-leaf path with the target sum is shown.\n\n\nExample 2:\n\n\nInput: root = [1,2,3], targetSum = 5\nOutput: false\nExplanation: There two root-to-leaf paths in the tree:\n(1 --&gt; 2): The sum is 3.\n(1 --&gt; 3): The sum is 4.\nThere is no root-to-leaf path with sum = 5.\n\n\nExample 3:\nInput: root = [], targetSum = 0\nOutput: false\nExplanation: Since the tree is empty, there are no root-to-leaf paths.\n"], "constraints": "\nConstraints:\nThe number of nodes in the tree is in the range [0, 5000].\n-1000 <= Node.val <= 1000\n-1000 <= targetSum <= 1000\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\n    public boolean hasPathSum(TreeNode root, int targetSum) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @param {number} targetSum\n* @return {boolean}\n*/\nvar hasPathSum = function (root, targetSum) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    bool hasPathSum(TreeNode* root, int targetSum) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\npublic boolean hasPathSum(TreeNode root, int targetSum) {\nreturn dfs(root, targetSum);\n}\n\nprivate boolean dfs(TreeNode root, int s) {\nif (root == null) {\nreturn false;\n}\ns -= root.val;\nif (root.left == null && root.right == null && s == 0) {\nreturn true;\n}\nreturn dfs(root.left, s) || dfs(root.right, s);\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @param {number} targetSum\n* @return {boolean}\n*/\nvar hasPathSum = function (root, targetSum) {\nfunction dfs(root, s) {\nif (!root) return false;\ns += root.val;\nif (!root.left && !root.right && s == targetSum) return true;\nreturn dfs(root.left, s) || dfs(root.right, s);\n}\nreturn dfs(root, 0);\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nbool hasPathSum(TreeNode* root, int targetSum) {\nfunction<bool(TreeNode*, int)> dfs = [&](TreeNode* root, int s) -> int {\nif (!root) return false;\ns += root->val;\nif (!root->left && !root->right && s == targetSum) return true;\nreturn dfs(root->left, s) || dfs(root->right, s);\n};\nreturn dfs(root, 0);\n}\n};\n"]}, {"leetCodeID": "0118", "level": "easy", "question_description": "Given an integer numRows, return the first numRows of Pascal&#39;s triangle.\nIn Pascal&#39;s triangle, each number is the sum of the two numbers directly above it as shown:", "examples": ["Example 1:Input: numRows = 5\nOutput: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n", "Example 2:Input: numRows = 1\nOutput: [[1]]\n"], "constraints": "\nConstraints:\n1 <= numRows <= 30\n", "java_context": "\nclass Solution {\n    public List<List<Integer>> generate(int numRows) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number} numRows\n* @return {number[][]}\n*/\nvar generate = function (numRows) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<vector<int>> generate(int numRows) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic List<List<Integer>> generate(int numRows) {\nList<List<Integer>> f = new ArrayList<>();\nf.add(List.of(1));\nfor (int i = 0; i < numRows - 1; ++i) {\nList<Integer> g = new ArrayList<>();\ng.add(1);\nfor (int j = 0; j < f.get(i).size() - 1; ++j) {\ng.add(f.get(i).get(j) + f.get(i).get(j + 1));\n}\ng.add(1);\nf.add(g);\n}\nreturn f;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number} numRows\n* @return {number[][]}\n*/\nvar generate = function (numRows) {\nconst f = [[1]];\nfor (let i = 0; i < numRows - 1; ++i) {\nconst g = [1];\nfor (let j = 0; j < f[i].length - 1; ++j) {\ng.push(f[i][j] + f[i][j + 1]);\n}\ng.push(1);\nf.push(g);\n}\nreturn f;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<vector<int>> generate(int numRows) {\nvector<vector<int>> f;\nf.push_back(vector<int>(1, 1));\nfor (int i = 0; i < numRows - 1; ++i) {\nvector<int> g;\ng.push_back(1);\nfor (int j = 0; j < f[i].size() - 1; ++j) {\ng.push_back(f[i][j] + f[i][j + 1]);\n}\ng.push_back(1);\nf.push_back(g);\n}\nreturn f;\n}\n};\n"]}, {"leetCodeID": "0121", "level": "easy", "question_description": "You are given an array prices where prices[i] is the price of a given stock on the ith day.\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.", "examples": ["Example 1:\nInput: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\n", "Example 2:\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transactions are done and the max profit = 0.\n"], "constraints": "\nConstraints:\n1 <= prices.length <= 105\n0 <= prices[i] <= 104\n", "java_context": "\nclass Solution {\n    public int maxProfit(int[] prices) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} prices\n* @return {number}\n*/\nvar maxProfit = function (prices) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int maxProfit(int[] prices) {\nint ans = 0, mi = prices[0];\nfor (int v : prices) {\nans = Math.max(ans, v - mi);\nmi = Math.min(mi, v);\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} prices\n* @return {number}\n*/\nvar maxProfit = function (prices) {\nlet ans = 0;\nlet mi = prices[0];\nfor (const v of prices) {\nans = Math.max(ans, v - mi);\nmi = Math.min(mi, v);\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint maxProfit(vector<int>& prices) {\nint ans = 0, mi = prices[0];\nfor (int& v : prices) {\nans = max(ans, v - mi);\nmi = min(mi, v);\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0125", "level": "easy", "question_description": "A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\nGiven a string s, return true if it is a palindrome, or false otherwise.", "examples": ["Example 1:\nInput: s = &quot;A man, a plan, a canal: Panama&quot;\nOutput: true\nExplanation: &quot;amanaplanacanalpanama&quot; is a palindrome.\n", "Example 2:\nInput: s = &quot;race a car&quot;\nOutput: false\nExplanation: &quot;raceacar&quot; is not a palindrome.\n", "Example 3:\nInput: s = &quot; &quot;\nOutput: true\nExplanation: s is an empty string &quot;&quot; after removing non-alphanumeric characters.\nSince an empty string reads the same forward and backward, it is a palindrome.\n"], "constraints": "\nConstraints:\n1 <= s.length <= 2 * 105\ns consists only of printable ASCII characters.\n", "java_context": "\nclass Solution {\n    public boolean isPalindrome(String s) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} s\n* @return {boolean}\n*/\nvar isPalindrome = function (s) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    bool isPalindrome(string s) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic boolean isPalindrome(String s) {\nint i = 0, j = s.length() - 1;\nwhile (i < j) {\nif (!Character.isLetterOrDigit(s.charAt(i))) {\n++i;\n} else if (!Character.isLetterOrDigit(s.charAt(j))) {\n--j;\n} else if (Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) {\nreturn false;\n} else {\n++i;\n--j;\n}\n}\nreturn true;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} s\n* @return {boolean}\n*/\nvar isPalindrome = function (s) {\nlet i = 0;\nlet j = s.length - 1;\nwhile (i < j) {\nif (!/[a-zA-Z0-9]/.test(s[i])) {\n++i;\n} else if (!/[a-zA-Z0-9]/.test(s[j])) {\n--j;\n} else if (s[i].toLowerCase() !== s[j].toLowerCase()) {\nreturn false;\n} else {\n++i;\n--j;\n}\n}\nreturn true;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nbool isPalindrome(string s) {\nint i = 0, j = s.size() - 1;\nwhile (i < j) {\nif (!isalnum(s[i])) {\n++i;\n} else if (!isalnum(s[j])) {\n--j;\n} else if (tolower(s[i]) != tolower(s[j])) {\nreturn false;\n} else {\n++i;\n--j;\n}\n}\nreturn true;\n}\n};\n"]}, {"leetCodeID": "0136", "level": "easy", "question_description": "Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.\nYou must implement a solution with a linear runtime complexity and use only constant extra space.", "examples": ["Example 1:Input: nums = [2,2,1]\nOutput: 1\n", "Example 2:Input: nums = [4,1,2,1,2]\nOutput: 4\n", "Example 3:Input: nums = [1]\nOutput: 1\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 3 * 104\n-3 * 104 <= nums[i] <= 3 * 104\nEach element in the array appears twice except for one element which appears only once.\n", "java_context": "\nclass Solution {\n    public int singleNumber(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar singleNumber = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int singleNumber(int[] nums) {\nint ans = 0;\nfor (int v : nums) {\nans ^= v;\n}\nreturn ans;\n}\n}\n", "\nclass Solution {\npublic int singleNumber(int[] nums) {\nreturn Arrays.stream(nums).reduce(0, (a, b) -> a ^ b);\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar singleNumber = function (nums) {\nreturn nums.reduce((a, b) => a ^ b);\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint singleNumber(vector<int>& nums) {\nint ans = 0;\nfor (int v : nums) {\nans ^= v;\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0141", "level": "easy", "question_description": "Given head, the head of a linked list, determine if the linked list has a cycle in it.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail&#39;s next pointer is connected to. Note that pos is not passed as a parameter.\nReturn true if there is a cycle in the linked list. Otherwise, return false.", "examples": [], "constraints": "\nConstraints:\nThe number of the nodes in the list is in the range [0, 104].\n-105 <= Node.val <= 105\npos is -1 or a valid index in the linked-list.\n", "java_context": "    \n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for singly-linked list.\n* function ListNode(val) {\n*     this.val = val;\n*     this.next = null;\n* }\n*/\n\n/**\n* @param {ListNode} head\n* @return {boolean}\n*/\nvar hasCycle = function (head) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode(int x) : val(x), next(NULL) {}\n* };\n*/\nclass Solution {\npublic:\n    bool hasCycle(ListNode* head) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for singly-linked list.\n* class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode(int x) {\n*         val = x;\n*         next = null;\n*     }\n* }\n*/\npublic class Solution {\npublic boolean hasCycle(ListNode head) {\nSet<ListNode> s = new HashSet<>();\nfor (; head != null; head = head.next) {\nif (!s.add(head)) {\nreturn true;\n}\n}\nreturn false;\n}\n}\n", "\n/**\n* Definition for singly-linked list.\n* class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode(int x) {\n*         val = x;\n*         next = null;\n*     }\n* }\n*/\npublic class Solution {\npublic boolean hasCycle(ListNode head) {\nListNode slow = head;\nListNode fast = head;\nwhile (fast != null && fast.next != null) {\nslow = slow.next;\nfast = fast.next.next;\nif (slow == fast) {\nreturn true;\n}\n}\nreturn false;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for singly-linked list.\n* function ListNode(val) {\n*     this.val = val;\n*     this.next = null;\n* }\n*/\n\n/**\n* @param {ListNode} head\n* @return {boolean}\n*/\nvar hasCycle = function (head) {\nlet slow = head;\nlet fast = head;\nwhile (fast && fast.next) {\nslow = slow.next;\nfast = fast.next.next;\nif (slow === fast) {\nreturn true;\n}\n}\nreturn false;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode(int x) : val(x), next(NULL) {}\n* };\n*/\nclass Solution {\npublic:\nbool hasCycle(ListNode* head) {\nunordered_set<ListNode*> s;\nfor (; head; head = head->next) {\nif (s.contains(head)) {\nreturn true;\n}\ns.insert(head);\n}\nreturn false;\n}\n};\n", "\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode(int x) : val(x), next(NULL) {}\n* };\n*/\nclass Solution {\npublic:\nbool hasCycle(ListNode* head) {\nListNode* slow = head;\nListNode* fast = head;\nwhile (fast && fast->next) {\nslow = slow->next;\nfast = fast->next->next;\nif (slow == fast) {\nreturn true;\n}\n}\nreturn false;\n}\n};\n"]}, {"leetCodeID": "0160", "level": "easy", "question_description": "Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.\nFor example, the following two linked lists begin to intersect at node c1:\nThe test cases are generated such that there are no cycles anywhere in the entire linked structure.\nNote that the linked lists must retain their original structure after the function returns.\nCustom Judge:\nThe inputs to the judge are given as follows (your program is not given these inputs):\nintersectVal - The value of the node where the intersection occurs. This is 0 if there is no intersected node.\nlistA - The first linked list.\nlistB - The second linked list.\nskipA - The number of nodes to skip ahead in listA (starting from the head) to get to the intersected node.\nskipB - The number of nodes to skip ahead in listB (starting from the head) to get to the intersected node.\nThe judge will then create the linked structure based on these inputs and pass the two heads, headA and headB to your program. If you correctly return the intersected node, then your solution will be accepted.", "examples": [], "constraints": "\nConstraints:\nThe number of nodes of listA is in the m.\nThe number of nodes of listB is in the n.\n1 <= m, n <= 3 * 104\n1 <= Node.val <= 105\n0 <= skipA <&nbsp;m\n0 <= skipB <&nbsp;n\nintersectVal is 0 if listA and listB do not intersect.\nintersectVal == listA[skipA] == listB[skipB] if listA and listB intersect.\n", "java_context": "    \n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for singly-linked list.\n* function ListNode(val) {\n*     this.val = val;\n*     this.next = null;\n* }\n*/\n\n/**\n* @param {ListNode} headA\n* @param {ListNode} headB\n* @return {ListNode}\n*/\nvar getIntersectionNode = function (headA, headB) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode(int x) : val(x), next(NULL) {}\n* };\n*/\nclass Solution {\npublic:\n    ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode(int x) {\n*         val = x;\n*         next = null;\n*     }\n* }\n*/\npublic class Solution {\npublic ListNode getIntersectionNode(ListNode headA, ListNode headB) {\nListNode a = headA, b = headB;\nwhile (a != b) {\na = a == null ? headB : a.next;\nb = b == null ? headA : b.next;\n}\nreturn a;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for singly-linked list.\n* function ListNode(val) {\n*     this.val = val;\n*     this.next = null;\n* }\n*/\n\n/**\n* @param {ListNode} headA\n* @param {ListNode} headB\n* @return {ListNode}\n*/\nvar getIntersectionNode = function (headA, headB) {\nlet a = headA;\nlet b = headB;\nwhile (a != b) {\na = a ? a.next : headB;\nb = b ? b.next : headA;\n}\nreturn a;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode(int x) : val(x), next(NULL) {}\n* };\n*/\nclass Solution {\npublic:\nListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {\nListNode *a = headA, *b = headB;\nwhile (a != b) {\na = a ? a->next : headB;\nb = b ? b->next : headA;\n}\nreturn a;\n}\n};\n"]}, {"leetCodeID": "0169", "level": "easy", "question_description": "Given an array nums of size n, return the majority element.\nThe majority element is the element that appears more than &lfloor;n / 2&rfloor; times. You may assume that the majority element always exists in the array.", "examples": ["Example 1:Input: nums = [3,2,3]\nOutput: 3\n", "Example 2:Input: nums = [2,2,1,1,1,2,2]\nOutput: 2\n"], "constraints": "\nConstraints:\nn == nums.length\n1 <= n <= 5 * 104\n-109 <= nums[i] <= 109\n", "java_context": "\nclass Solution {\n    public int majorityElement(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar majorityElement = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int majorityElement(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int majorityElement(int[] nums) {\nint cnt = 0, m = 0;\nfor (int x : nums) {\nif (cnt == 0) {\nm = x;\ncnt = 1;\n} else {\ncnt += m == x ? 1 : -1;\n}\n}\nreturn m;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar majorityElement = function (nums) {\nlet cnt = 0;\nlet m = 0;\nfor (const x of nums) {\nif (cnt === 0) {\nm = x;\ncnt = 1;\n} else {\ncnt += m === x ? 1 : -1;\n}\n}\nreturn m;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint majorityElement(vector<int>& nums) {\nint cnt = 0, m = 0;\nfor (int& x : nums) {\nif (cnt == 0) {\nm = x;\ncnt = 1;\n} else {\ncnt += m == x ? 1 : -1;\n}\n}\nreturn m;\n}\n};\n"]}, {"leetCodeID": "0190", "level": "easy", "question_description": "Reverse bits of a given 32 bits unsigned integer.\nNote:\nNote that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer&#39;s internal binary representation is the same, whether it is signed or unsigned.\nIn Java, the compiler represents the signed integers using 2&#39;s complement notation. Therefore, in Example 2 above, the input represents the signed integer -3 and the output represents the signed integer -1073741825.", "examples": ["Example 1:\nInput: n = 00000010100101000001111010011100\nOutput:    964176192 (00111001011110000010100101000000)\nExplanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.\n", "Example 2:\nInput: n = 11111111111111111111111111111101\nOutput:   3221225471 (10111111111111111111111111111111)\nExplanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111.\n"], "constraints": "\nConstraints:\nThe input must be a binary string of length 32\n", "java_context": "    \n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number} n - a positive integer\n* @return {number} - a positive integer\n*/\nvar reverseBits = function (n) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    uint32_t reverseBits(uint32_t n) {\n        // your code\n    }\n};", "java_solutions": ["\npublic class Solution {\n// you need treat n as an unsigned value\npublic int reverseBits(int n) {\nint ans = 0;\nfor (int i = 0; i < 32 && n != 0; ++i) {\nans |= (n & 1) << (31 - i);\nn >>>= 1;\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number} n - a positive integer\n* @return {number} - a positive integer\n*/\nvar reverseBits = function (n) {\nlet ans = 0;\nfor (let i = 0; i < 32 && n; ++i) {\nans |= (n & 1) << (31 - i);\nn >>= 1;\n}\nreturn ans >>> 0;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nuint32_t reverseBits(uint32_t n) {\nuint32_t ans = 0;\nfor (int i = 0; i < 32 && n; ++i) {\nans |= (n & 1) << (31 - i);\nn >>= 1;\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0191", "level": "easy", "question_description": "Write a function that takes the binary representation of a positive integer and returns the number of set bits it has (also known as the Hamming weight).", "examples": [], "constraints": "\nConstraints:\n1 <= n&nbsp;<= 231&nbsp;- 1\n", "java_context": "    \n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number} n - a positive integer\n* @return {number}\n*/\nvar hammingWeight = function (n) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int hammingWeight(uint32_t n) {\n        // your code\n    }\n};", "java_solutions": ["\npublic class Solution {\n// you need to treat n as an unsigned value\npublic int hammingWeight(int n) {\nint ans = 0;\nwhile (n != 0) {\nn &= n - 1;\n++ans;\n}\nreturn ans;\n}\n}\n", "\npublic class Solution {\n// you need to treat n as an unsigned value\npublic int hammingWeight(int n) {\nint ans = 0;\nwhile (n != 0) {\nn -= (n & -n);\n++ans;\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number} n - a positive integer\n* @return {number}\n*/\nvar hammingWeight = function (n) {\nlet ans = 0;\nwhile (n) {\nn &= n - 1;\n++ans;\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint hammingWeight(uint32_t n) {\nint ans = 0;\nwhile (n) {\nn &= n - 1;\n++ans;\n}\nreturn ans;\n}\n};\n", "\nclass Solution {\npublic:\nint hammingWeight(uint32_t n) {\nint ans = 0;\nwhile (n) {\nn -= (n & -n);\n++ans;\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0206", "level": "easy", "question_description": "Given the head of a singly linked list, reverse the list, and return the reversed list.", "examples": ["Example 1:\n\n\nInput: head = [1,2,3,4,5]\nOutput: [5,4,3,2,1]\n\n\nExample 2:\n\n\nInput: head = [1,2]\nOutput: [2,1]\n\n\nExample 3:\nInput: head = []\nOutput: []\n"], "constraints": "\nConstraints:\nThe number of nodes in the list is the range [0, 5000].\n-5000 <= Node.val <= 5000\n", "java_context": "\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode() {}\n*     ListNode(int val) { this.val = val; }\n*     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n* }\n*/\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for singly-linked list.\n* function ListNode(val, next) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.next = (next===undefined ? null : next)\n* }\n*/\n/**\n* @param {ListNode} head\n* @return {ListNode}\n*/\nvar reverseList = function (head) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode() {}\n*     ListNode(int val) { this.val = val; }\n*     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n* }\n*/\nclass Solution {\npublic ListNode reverseList(ListNode head) {\nListNode dummy = new ListNode();\nListNode curr = head;\nwhile (curr != null) {\nListNode next = curr.next;\ncurr.next = dummy.next;\ndummy.next = curr;\ncurr = next;\n}\nreturn dummy.next;\n}\n}\n", "\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode() {}\n*     ListNode(int val) { this.val = val; }\n*     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n* }\n*/\nclass Solution {\npublic ListNode reverseList(ListNode head) {\nif (head == null || head.next == null) {\nreturn head;\n}\nListNode ans = reverseList(head.next);\nhead.next.next = head;\nhead.next = null;\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for singly-linked list.\n* function ListNode(val, next) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.next = (next===undefined ? null : next)\n* }\n*/\n/**\n* @param {ListNode} head\n* @return {ListNode}\n*/\nvar reverseList = function (head) {\nlet dummy = new ListNode();\nlet curr = head;\nwhile (curr) {\nlet next = curr.next;\ncurr.next = dummy.next;\ndummy.next = curr;\ncurr = next;\n}\nreturn dummy.next;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\nclass Solution {\npublic:\nListNode* reverseList(ListNode* head) {\nListNode* dummy = new ListNode();\nListNode* curr = head;\nwhile (curr) {\nListNode* next = curr->next;\ncurr->next = dummy->next;\ndummy->next = curr;\ncurr = next;\n}\nreturn dummy->next;\n}\n};\n", "\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\nclass Solution {\npublic:\nListNode* reverseList(ListNode* head) {\nif (!head || !head->next) return head;\nListNode* ans = reverseList(head->next);\nhead->next->next = head;\nhead->next = nullptr;\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0217", "level": "easy", "question_description": "Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.", "examples": ["Example 1:Input: nums = [1,2,3,1]\nOutput: true\n", "Example 2:Input: nums = [1,2,3,4]\nOutput: false\n", "Example 3:Input: nums = [1,1,1,3,3,4,3,2,4,2]\nOutput: true\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 105\n-109 <= nums[i] <= 109\n", "java_context": "\nclass Solution {\n    public boolean containsDuplicate(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {boolean}\n*/\nvar containsDuplicate = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    bool containsDuplicate(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic boolean containsDuplicate(int[] nums) {\nArrays.sort(nums);\nfor (int i = 0; i < nums.length - 1; ++i) {\nif (nums[i] == nums[i + 1]) {\nreturn true;\n}\n}\nreturn false;\n}\n}\n", "\nclass Solution {\npublic boolean containsDuplicate(int[] nums) {\nSet<Integer> s = new HashSet<>();\nfor (int num : nums) {\nif (!s.add(num)) {\nreturn true;\n}\n}\nreturn false;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {boolean}\n*/\nvar containsDuplicate = function (nums) {\nreturn new Set(nums).size !== nums.length;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nbool containsDuplicate(vector<int>& nums) {\nsort(nums.begin(), nums.end());\nfor (int i = 0; i < nums.size() - 1; ++i) {\nif (nums[i] == nums[i + 1]) {\nreturn true;\n}\n}\nreturn false;\n}\n};\n", "\nclass Solution {\npublic:\nbool containsDuplicate(vector<int>& nums) {\nunordered_set<int> s(nums.begin(), nums.end());\nreturn s.size() < nums.size();\n}\n};\n"]}, {"leetCodeID": "0222", "level": "easy", "question_description": "Given the root of a complete binary tree, return the number of the nodes in the tree.\nAccording to Wikipedia, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h.\nDesign an algorithm that runs in less than O(n) time complexity.", "examples": ["Example 1:\n\n\nInput: root = [1,2,3,4,5,6]\nOutput: 6\n\n\nExample 2:\nInput: root = []\nOutput: 0\n", "Example 3:\nInput: root = [1]\nOutput: 1\n"], "constraints": "\nConstraints:\nThe number of nodes in the tree is in the range [0, 5 * 104].\n0 <= Node.val <= 5 * 104\nThe tree is guaranteed to be complete.\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\n    public int countNodes(TreeNode root) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {number}\n*/\nvar countNodes = function (root) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    int countNodes(TreeNode* root) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\npublic int countNodes(TreeNode root) {\nif (root == null) {\nreturn 0;\n}\nreturn 1 + countNodes(root.left) + countNodes(root.right);\n}\n}\n", "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\npublic int countNodes(TreeNode root) {\nif (root == null) {\nreturn 0;\n}\nint left = depth(root.left);\nint right = depth(root.right);\nif (left == right) {\nreturn (1 << left) + countNodes(root.right);\n}\nreturn (1 << right) + countNodes(root.left);\n}\n\nprivate int depth(TreeNode root) {\nint d = 0;\nfor (; root != null; root = root.left) {\n++d;\n}\nreturn d;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {number}\n*/\nvar countNodes = function (root) {\nif (!root) {\nreturn 0;\n}\nreturn 1 + countNodes(root.left) + countNodes(root.right);\n};\n", "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {number}\n*/\nvar countNodes = function (root) {\nconst depth = root => {\nlet d = 0;\nfor (; root; root = root.left) {\n++d;\n}\nreturn d;\n};\nif (!root) {\nreturn 0;\n}\nconst left = depth(root.left);\nconst right = depth(root.right);\nif (left == right) {\nreturn (1 << left) + countNodes(root.right);\n}\nreturn (1 << right) + countNodes(root.left);\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nint countNodes(TreeNode* root) {\nif (!root) {\nreturn 0;\n}\nreturn 1 + countNodes(root->left) + countNodes(root->right);\n}\n};\n", "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nint countNodes(TreeNode* root) {\nif (!root) {\nreturn 0;\n}\nint left = depth(root->left);\nint right = depth(root->right);\nif (left == right) {\nreturn (1 << left) + countNodes(root->right);\n}\nreturn (1 << right) + countNodes(root->left);\n}\n\nint depth(TreeNode* root) {\nint d = 0;\nfor (; root; root = root->left) {\n++d;\n}\nreturn d;\n}\n};\n"]}, {"leetCodeID": "0226", "level": "easy", "question_description": "Given the root of a binary tree, invert the tree, and return its root.", "examples": ["Example 1:\n\n\nInput: root = [4,2,7,1,3,6,9]\nOutput: [4,7,2,9,6,3,1]\n\n\nExample 2:\n\n\nInput: root = [2,1,3]\nOutput: [2,3,1]\n\n\nExample 3:\nInput: root = []\nOutput: []\n"], "constraints": "\nConstraints:\nThe number of nodes in the tree is in the range [0, 100].\n-100 <= Node.val <= 100\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\n    public TreeNode invertTree(TreeNode root) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {TreeNode}\n*/\nvar invertTree = function (root) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\npublic TreeNode invertTree(TreeNode root) {\ndfs(root);\nreturn root;\n}\n\nprivate void dfs(TreeNode root) {\nif (root == null) {\nreturn;\n}\nTreeNode t = root.left;\nroot.left = root.right;\nroot.right = t;\ndfs(root.left);\ndfs(root.right);\n}\n}\n", "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\npublic TreeNode invertTree(TreeNode root) {\nif (root == null) {\nreturn null;\n}\nTreeNode l = invertTree(root.left);\nTreeNode r = invertTree(root.right);\nroot.left = r;\nroot.right = l;\nreturn root;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {TreeNode}\n*/\nvar invertTree = function (root) {\nconst dfs = root => {\nif (!root) {\nreturn;\n}\n[root.left, root.right] = [root.right, root.left];\ndfs(root.left);\ndfs(root.right);\n};\ndfs(root);\nreturn root;\n};\n", "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {TreeNode}\n*/\nvar invertTree = function (root) {\nif (!root) {\nreturn root;\n}\nconst l = invertTree(root.left);\nconst r = invertTree(root.right);\nroot.left = r;\nroot.right = l;\nreturn root;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nTreeNode* invertTree(TreeNode* root) {\nfunction<void(TreeNode*)> dfs = [&](TreeNode* root) {\nif (!root) {\nreturn;\n}\nswap(root->left, root->right);\ndfs(root->left);\ndfs(root->right);\n};\ndfs(root);\nreturn root;\n}\n};\n", "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nTreeNode* invertTree(TreeNode* root) {\nif (!root) {\nreturn root;\n}\nTreeNode* l = invertTree(root->left);\nTreeNode* r = invertTree(root->right);\nroot->left = r;\nroot->right = l;\nreturn root;\n}\n};\n"]}, {"leetCodeID": "0231", "level": "easy", "question_description": "Given an integer n, return true if it is a power of two. Otherwise, return false.\nAn integer n is a power of two, if there exists an integer x such that n == 2x.", "examples": ["Example 1:\nInput: n = 1\nOutput: true\nExplanation: 20 = 1\n", "Example 2:\nInput: n = 16\nOutput: true\nExplanation: 24 = 16\n", "Example 3:\nInput: n = 3\nOutput: false\n"], "constraints": "\nConstraints:\n-231 <= n <= 231 - 1\n", "java_context": "\nclass Solution {\n    public boolean isPowerOfTwo(int n) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number} n\n* @return {boolean}\n*/\nvar isPowerOfTwo = function (n) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic boolean isPowerOfTwo(int n) {\nreturn n > 0 && (n & (n - 1)) == 0;\n}\n}\n", "\nclass Solution {\npublic boolean isPowerOfTwo(int n) {\nreturn n > 0 && n == (n & (-n));\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number} n\n* @return {boolean}\n*/\nvar isPowerOfTwo = function (n) {\nreturn n > 0 && (n & (n - 1)) == 0;\n};\n", "\n/**\n* @param {number} n\n* @return {boolean}\n*/\nvar isPowerOfTwo = function (n) {\nreturn n > 0 && n == (n & -n);\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nbool isPowerOfTwo(int n) {\nreturn n > 0 && (n & (n - 1)) == 0;\n}\n};\n", "\nclass Solution {\npublic:\nbool isPowerOfTwo(int n) {\nreturn n > 0 && n == (n & (-n));\n}\n};\n"]}, {"leetCodeID": "0234", "level": "easy", "question_description": "Given the head of a singly linked list, return true if it is a palindrome or false otherwise.", "examples": [], "constraints": "\nConstraints:\nThe number of nodes in the list is in the range [1, 105].\n0 <= Node.val <= 9\n", "java_context": "\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode() {}\n*     ListNode(int val) { this.val = val; }\n*     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n* }\n*/\nclass Solution {\n    public boolean isPalindrome(ListNode head) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for singly-linked list.\n* function ListNode(val, next) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.next = (next===undefined ? null : next)\n* }\n*/\n/**\n* @param {ListNode} head\n* @return {boolean}\n*/\nvar isPalindrome = function (head) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\nclass Solution {\npublic:\n    bool isPalindrome(ListNode* head) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode() {}\n*     ListNode(int val) { this.val = val; }\n*     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n* }\n*/\nclass Solution {\npublic boolean isPalindrome(ListNode head) {\nListNode slow = head;\nListNode fast = head.next;\nwhile (fast != null && fast.next != null) {\nslow = slow.next;\nfast = fast.next.next;\n}\nListNode cur = slow.next;\nslow.next = null;\nListNode pre = null;\nwhile (cur != null) {\nListNode t = cur.next;\ncur.next = pre;\npre = cur;\ncur = t;\n}\nwhile (pre != null) {\nif (pre.val != head.val) {\nreturn false;\n}\npre = pre.next;\nhead = head.next;\n}\nreturn true;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for singly-linked list.\n* function ListNode(val, next) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.next = (next===undefined ? null : next)\n* }\n*/\n/**\n* @param {ListNode} head\n* @return {boolean}\n*/\nvar isPalindrome = function (head) {\nlet slow = head;\nlet fast = head.next;\nwhile (fast && fast.next) {\nslow = slow.next;\nfast = fast.next.next;\n}\nlet cur = slow.next;\nslow.next = null;\nlet pre = null;\nwhile (cur) {\nlet t = cur.next;\ncur.next = pre;\npre = cur;\ncur = t;\n}\nwhile (pre) {\nif (pre.val !== head.val) {\nreturn false;\n}\npre = pre.next;\nhead = head.next;\n}\nreturn true;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\nclass Solution {\npublic:\nbool isPalindrome(ListNode* head) {\nListNode* slow = head;\nListNode* fast = head->next;\nwhile (fast && fast->next) {\nslow = slow->next;\nfast = fast->next->next;\n}\nListNode* pre = nullptr;\nListNode* cur = slow->next;\nwhile (cur) {\nListNode* t = cur->next;\ncur->next = pre;\npre = cur;\ncur = t;\n}\nwhile (pre) {\nif (pre->val != head->val) return false;\npre = pre->next;\nhead = head->next;\n}\nreturn true;\n}\n};\n"]}, {"leetCodeID": "0242", "level": "easy", "question_description": "Given two strings s and t, return true if t is an anagram of s, and false otherwise.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.", "examples": ["Example 1:Input: s = \"anagram\", t = \"nagaram\"\nOutput: true\n", "Example 2:Input: s = \"rat\", t = \"car\"\nOutput: false\n"], "constraints": "\nConstraints:\n1 <= s.length, t.length <= 5 * 104\ns and t consist of lowercase English letters.\n", "java_context": "\nclass Solution {\n    public boolean isAnagram(String s, String t) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} s\n* @param {string} t\n* @return {boolean}\n*/\nvar isAnagram = function (s, t) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic boolean isAnagram(String s, String t) {\nif (s.length() != t.length()) {\nreturn false;\n}\nint[] cnt = new int[26];\nfor (int i = 0; i < s.length(); ++i) {\n++cnt[s.charAt(i) - 'a'];\n--cnt[t.charAt(i) - 'a'];\n}\nfor (int i = 0; i < 26; ++i) {\nif (cnt[i] != 0) {\nreturn false;\n}\n}\nreturn true;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} s\n* @param {string} t\n* @return {boolean}\n*/\nvar isAnagram = function (s, t) {\nif (s.length !== t.length) {\nreturn false;\n}\nconst cnt = new Array(26).fill(0);\nfor (let i = 0; i < s.length; ++i) {\n++cnt[s.charCodeAt(i) - 'a'.charCodeAt(0)];\n--cnt[t.charCodeAt(i) - 'a'.charCodeAt(0)];\n}\nreturn cnt.every(x => x === 0);\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nbool isAnagram(string s, string t) {\nif (s.size() != t.size()) {\nreturn false;\n}\nvector<int> cnt(26);\nfor (int i = 0; i < s.size(); ++i) {\n++cnt[s[i] - 'a'];\n--cnt[t[i] - 'a'];\n}\nreturn all_of(cnt.begin(), cnt.end(), [](int x) { return x == 0; });\n}\n};\n"]}, {"leetCodeID": "0263", "level": "easy", "question_description": "An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\nGiven an integer n, return true if n is an ugly number.", "examples": ["Example 1:\nInput: n = 6\nOutput: true\nExplanation: 6 = 2 &times; 3\n", "Example 2:\nInput: n = 1\nOutput: true\nExplanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.\n", "Example 3:\nInput: n = 14\nOutput: false\nExplanation: 14 is not ugly since it includes the prime factor 7.\n"], "constraints": "\nConstraints:\n-231 <= n <= 231 - 1\n", "java_context": "\nclass Solution {\n    public boolean isUgly(int n) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number} n\n* @return {boolean}\n*/\nvar isUgly = function (n) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    bool isUgly(int n) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic boolean isUgly(int n) {\nif (n < 1) return false;\nwhile (n % 2 == 0) {\nn /= 2;\n}\nwhile (n % 3 == 0) {\nn /= 3;\n}\nwhile (n % 5 == 0) {\nn /= 5;\n}\nreturn n == 1;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number} n\n* @return {boolean}\n*/\nvar isUgly = function (n) {\nif (n < 1) return false;\nwhile (n % 2 === 0) {\nn /= 2;\n}\nwhile (n % 3 === 0) {\nn /= 3;\n}\nwhile (n % 5 === 0) {\nn /= 5;\n}\nreturn n === 1;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nbool isUgly(int n) {\nif (n < 1) return false;\nwhile (n % 2 == 0) {\nn /= 2;\n}\nwhile (n % 3 == 0) {\nn /= 3;\n}\nwhile (n % 5 == 0) {\nn /= 5;\n}\nreturn n == 1;\n}\n};\n"]}, {"leetCodeID": "0266", "level": "easy", "question_description": "Given a string s, return true if a permutation of the string could form a palindrome and false otherwise.", "examples": ["Example 1:\nInput: s = &quot;code&quot;\nOutput: false\n", "Example 2:\nInput: s = &quot;aab&quot;\nOutput: true\n", "Example 3:\nInput: s = &quot;carerac&quot;\nOutput: true\n"], "constraints": "\nConstraints:\n1 <= s.length <= 5000\ns consists of only lowercase English letters.\n", "java_context": "\nclass Solution {\n    public boolean canPermutePalindrome(String s) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} s\n* @return {boolean}\n*/\nvar canPermutePalindrome = function (s) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    bool canPermutePalindrome(string s) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic boolean canPermutePalindrome(String s) {\nint[] cnt = new int[26];\nfor (char c : s.toCharArray()) {\n++cnt[c - 'a'];\n}\nint odd = 0;\nfor (int x : cnt) {\nodd += x & 1;\n}\nreturn odd < 2;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} s\n* @return {boolean}\n*/\nvar canPermutePalindrome = function (s) {\nconst cnt = new Array(26).fill(0);\nfor (const c of s) {\n++cnt[c.charCodeAt() - 'a'.charCodeAt()];\n}\nreturn cnt.filter(c => c % 2 === 1).length < 2;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nbool canPermutePalindrome(string s) {\nvector<int> cnt(26);\nfor (char& c : s) {\n++cnt[c - 'a'];\n}\nint odd = 0;\nfor (int x : cnt) {\nodd += x & 1;\n}\nreturn odd < 2;\n}\n};\n"]}, {"leetCodeID": "0268", "level": "easy", "question_description": "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.", "examples": ["Example 1:\nInput: nums = [3,0,1]\nOutput: 2\nExplanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.\n", "Example 2:\nInput: nums = [0,1]\nOutput: 2\nExplanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.\n", "Example 3:\nInput: nums = [9,6,4,2,3,5,7,0,1]\nOutput: 8\nExplanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.\n"], "constraints": "\nConstraints:\nn == nums.length\n1 <= n <= 104\n0 <= nums[i] <= n\nAll the numbers of nums are unique.\n", "java_context": "\nclass Solution {\n    public int missingNumber(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar missingNumber = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int missingNumber(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int missingNumber(int[] nums) {\nint n = nums.length;\nint ans = n;\nfor (int i = 0; i < n; ++i) {\nans ^= (i ^ nums[i]);\n}\nreturn ans;\n}\n}\n", "\nclass Solution {\npublic int missingNumber(int[] nums) {\nint n = nums.length;\nint ans = n;\nfor (int i = 0; i < n; ++i) {\nans += i - nums[i];\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar missingNumber = function (nums) {\nconst n = nums.length;\nlet ans = n;\nfor (let i = 0; i < n; ++i) {\nans ^= i ^ nums[i];\n}\nreturn ans;\n};\n", "\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar missingNumber = function (nums) {\nconst n = nums.length;\nlet ans = n;\nfor (let i = 0; i < n; ++i) {\nans += i - nums[i];\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint missingNumber(vector<int>& nums) {\nint n = nums.size();\nint ans = n;\nfor (int i = 0; i < n; ++i) {\nans ^= (i ^ nums[i]);\n}\nreturn ans;\n}\n};\n", "\nclass Solution {\npublic:\nint missingNumber(vector<int>& nums) {\nint n = nums.size();\nreturn (1 + n) * n / 2 - accumulate(nums.begin(), nums.end(), 0);\n}\n};\n"]}, {"leetCodeID": "0270", "level": "easy", "question_description": "Given the root of a binary search tree and a target value, return the value in the BST that is closest to the target. If there are multiple answers, print the smallest.", "examples": ["Example 1:\n\n\nInput: root = [4,2,5,1,3], target = 3.714286\nOutput: 4\n\n\nExample 2:\nInput: root = [1], target = 4.428571\nOutput: 1\n"], "constraints": "\nConstraints:\nThe number of nodes in the tree is in the range [1, 104].\n0 <= Node.val <= 109\n-109 <= target <= 109\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\n    private int ans;\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @param {number} target\n* @return {number}\n*/\nvar closestValue = function (root, target) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    int closestValue(TreeNode* root, double target) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\nprivate int ans;\nprivate double target;\nprivate double mi = Double.MAX_VALUE;\n\npublic int closestValue(TreeNode root, double target) {\nthis.target = target;\ndfs(root);\nreturn ans;\n}\n\nprivate void dfs(TreeNode root) {\nif (root == null) {\nreturn;\n}\ndfs(root.left);\ndouble t = Math.abs(root.val - target);\nif (t < mi) {\nmi = t;\nans = root.val;\n}\ndfs(root.right);\n}\n}\n", "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\npublic int closestValue(TreeNode root, double target) {\nint ans = root.val;\ndouble mi = Double.MAX_VALUE;\nwhile (root != null) {\ndouble t = Math.abs(root.val - target);\nif (t < mi || (t == mi && root.val < ans)) {\nmi = t;\nans = root.val;\n}\nif (root.val > target) {\nroot = root.left;\n} else {\nroot = root.right;\n}\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @param {number} target\n* @return {number}\n*/\nvar closestValue = function (root, target) {\nlet mi = Infinity;\nlet ans = root.val;\nconst dfs = root => {\nif (!root) {\nreturn;\n}\ndfs(root.left);\nconst t = Math.abs(root.val - target);\nif (t < mi) {\nmi = t;\nans = root.val;\n}\ndfs(root.right);\n};\ndfs(root);\nreturn ans;\n};\n", "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @param {number} target\n* @return {number}\n*/\nvar closestValue = function (root, target) {\nlet ans = root.val;\nlet mi = Number.MAX_VALUE;\nwhile (root) {\nconst t = Math.abs(root.val - target);\nif (t < mi || (t === mi && root.val < ans)) {\nmi = t;\nans = root.val;\n}\nif (root.val > target) {\nroot = root.left;\n} else {\nroot = root.right;\n}\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nint closestValue(TreeNode* root, double target) {\nint ans = root->val;\ndouble mi = INT_MAX;\nfunction<void(TreeNode*)> dfs = [&](TreeNode* root) {\nif (!root) {\nreturn;\n}\ndfs(root->left);\ndouble t = abs(root->val - target);\nif (t < mi) {\nmi = t;\nans = root->val;\n}\ndfs(root->right);\n};\ndfs(root);\nreturn ans;\n}\n};\n", "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nint closestValue(TreeNode* root, double target) {\nint ans = root->val;\ndouble mi = INT_MAX;\nwhile (root) {\ndouble t = abs(root->val - target);\nif (t < mi || (t == mi && root->val < ans)) {\nmi = t;\nans = root->val;\n}\nif (root->val > target) {\nroot = root->left;\n} else {\nroot = root->right;\n}\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0278", "level": "easy", "question_description": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.", "examples": ["Example 1:\nInput: n = 5, bad = 4\nOutput: 4\nExplanation:\ncall isBadVersion(3) -&gt; false\ncall isBadVersion(5)&nbsp;-&gt; true\ncall isBadVersion(4)&nbsp;-&gt; true\nThen 4 is the first bad version.\n", "Example 2:\nInput: n = 1, bad = 1\nOutput: 1\n"], "constraints": "\nConstraints:\n1 <= bad <= n <= 231 - 1\n", "java_context": "    \n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for isBadVersion()\n*\n* @param {integer} version number\n* @return {boolean} whether the version is bad\n* isBadVersion = function(version) {\n*     ...\n* };\n*/\n\n/**\n* @param {function} isBadVersion()\n* @return {function}\n*/\nvar solution = function (isBadVersion) {\n    // your code\n};", "cpp_context": "\n// The API isBadVersion is defined for you.\n// bool isBadVersion(int version);\n\nclass Solution {\npublic:\n    int firstBadVersion(int n) {\n        // your code\n    }\n};", "java_solutions": ["\n/* The isBadVersion API is defined in the parent class VersionControl.\nboolean isBadVersion(int version); */\n\npublic class Solution extends VersionControl {\npublic int firstBadVersion(int n) {\nint left = 1, right = n;\nwhile (left < right) {\nint mid = (left + right) >>> 1;\nif (isBadVersion(mid)) {\nright = mid;\n} else {\nleft = mid + 1;\n}\n}\nreturn left;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for isBadVersion()\n*\n* @param {integer} version number\n* @return {boolean} whether the version is bad\n* isBadVersion = function(version) {\n*     ...\n* };\n*/\n\n/**\n* @param {function} isBadVersion()\n* @return {function}\n*/\nvar solution = function (isBadVersion) {\n/**\n* @param {integer} n Total versions\n* @return {integer} The first bad version\n*/\nreturn function (n) {\nlet left = 1;\nlet right = n;\nwhile (left < right) {\nconst mid = (left + right) >>> 1;\nif (isBadVersion(mid)) {\nright = mid;\n} else {\nleft = mid + 1;\n}\n}\nreturn left;\n};\n};\n"], "cpp_solutions": ["\n// The API isBadVersion is defined for you.\n// bool isBadVersion(int version);\n\nclass Solution {\npublic:\nint firstBadVersion(int n) {\nint left = 1, right = n;\nwhile (left < right) {\nint mid = left + ((right - left) >> 1);\nif (isBadVersion(mid)) {\nright = mid;\n} else {\nleft = mid + 1;\n}\n}\nreturn left;\n}\n};\n"]}, {"leetCodeID": "0283", "level": "easy", "question_description": "Given an integer array nums, move all 0&#39;s to the end of it while maintaining the relative order of the non-zero elements.\nNote that you must do this in-place without making a copy of the array.", "examples": ["Example 1:Input: nums = [0,1,0,3,12]\nOutput: [1,3,12,0,0]\n", "Example 2:Input: nums = [0]\nOutput: [0]\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 104\n-231 <= nums[i] <= 231 - 1\n", "java_context": "\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {void} Do not return anything, modify nums in-place instead.\n*/\nvar moveZeroes = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    void moveZeroes(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic void moveZeroes(int[] nums) {\nint i = -1, n = nums.length;\nfor (int j = 0; j < n; ++j) {\nif (nums[j] != 0) {\nint t = nums[++i];\nnums[i] = nums[j];\nnums[j] = t;\n}\n}\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {void} Do not return anything, modify nums in-place instead.\n*/\nvar moveZeroes = function (nums) {\nlet i = -1;\nfor (let j = 0; j < nums.length; ++j) {\nif (nums[j]) {\nconst t = nums[++i];\nnums[i] = nums[j];\nnums[j] = t;\n}\n}\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvoid moveZeroes(vector<int>& nums) {\nint i = -1, n = nums.size();\nfor (int j = 0; j < n; ++j) {\nif (nums[j]) {\nswap(nums[++i], nums[j]);\n}\n}\n}\n};\n"]}, {"leetCodeID": "0303", "level": "easy", "question_description": "Given an integer array nums, handle multiple queries of the following type:\nCalculate the sum of the elements of nums between indices left and right inclusive where left &lt;= right.\nImplement the NumArray class:\nNumArray(int[] nums) Initializes the object with the integer array nums.\nint sumRange(int left, int right) Returns the sum of the elements of nums between indices left and right inclusive (i.e. nums[left] + nums[left + 1] + ... + nums[right]).", "examples": ["Example 1:\nInput\n[&quot;NumArray&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;]\n[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]\nOutput\n[null, 1, -1, -3]\n\nExplanation\nNumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);\nnumArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1\nnumArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1\nnumArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 104\n-105 <= nums[i] <= 105\n0 <= left <= right < nums.length\nAt most 104 calls will be made to sumRange.\n", "java_context": "    \n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n*/\nvar NumArray = function (nums) {\n    // your code\n};", "cpp_context": "    \n        // your code\n    }\n};", "java_solutions": ["\nclass NumArray {\nprivate int[] s;\n\npublic NumArray(int[] nums) {\nint n = nums.length;\ns = new int[n + 1];\nfor (int i = 0; i < n; ++i) {\ns[i + 1] = s[i] + nums[i];\n}\n}\n\npublic int sumRange(int left, int right) {\nreturn s[right + 1] - s[left];\n}\n}\n\n/**\n* Your NumArray object will be instantiated and called as such:\n* NumArray obj = new NumArray(nums);\n* int param_1 = obj.sumRange(left,right);\n*/\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n*/\nvar NumArray = function (nums) {\nconst n = nums.length;\nthis.s = Array(n + 1).fill(0);\nfor (let i = 0; i < n; ++i) {\nthis.s[i + 1] = this.s[i] + nums[i];\n}\n};\n\n/**\n* @param {number} left\n* @param {number} right\n* @return {number}\n*/\nNumArray.prototype.sumRange = function (left, right) {\nreturn this.s[right + 1] - this.s[left];\n};\n\n/**\n* Your NumArray object will be instantiated and called as such:\n* var obj = new NumArray(nums)\n* var param_1 = obj.sumRange(left,right)\n*/\n"], "cpp_solutions": ["\nclass NumArray {\npublic:\nNumArray(vector<int>& nums) {\nint n = nums.size();\ns.resize(n + 1);\nfor (int i = 0; i < n; ++i) {\ns[i + 1] = s[i] + nums[i];\n}\n}\n\nint sumRange(int left, int right) {\nreturn s[right + 1] - s[left];\n}\n\nprivate:\nvector<int> s;\n};\n\n/**\n* Your NumArray object will be instantiated and called as such:\n* NumArray* obj = new NumArray(nums);\n* int param_1 = obj->sumRange(left,right);\n*/\n"]}, {"leetCodeID": "0326", "level": "easy", "question_description": "Given an integer n, return true if it is a power of three. Otherwise, return false.\nAn integer n is a power of three, if there exists an integer x such that n == 3x.", "examples": ["Example 1:\nInput: n = 27\nOutput: true\nExplanation: 27 = 33\n", "Example 2:\nInput: n = 0\nOutput: false\nExplanation: There is no x where 3x = 0.\n", "Example 3:\nInput: n = -1\nOutput: false\nExplanation: There is no x where 3x = (-1).\n"], "constraints": "\nConstraints:\n-231 <= n <= 231 - 1\n", "java_context": "\nclass Solution {\n    public boolean isPowerOfThree(int n) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number} n\n* @return {boolean}\n*/\nvar isPowerOfThree = function (n) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    bool isPowerOfThree(int n) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic boolean isPowerOfThree(int n) {\nwhile (n > 2) {\nif (n % 3 != 0) {\nreturn false;\n}\nn /= 3;\n}\nreturn n == 1;\n}\n}\n", "\nclass Solution {\npublic boolean isPowerOfThree(int n) {\nreturn n > 0 && 1162261467 % n == 0;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number} n\n* @return {boolean}\n*/\nvar isPowerOfThree = function (n) {\nreturn n > 0 && 1162261467 % n == 0;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nbool isPowerOfThree(int n) {\nwhile (n > 2) {\nif (n % 3) {\nreturn false;\n}\nn /= 3;\n}\nreturn n == 1;\n}\n};\n", "\nclass Solution {\npublic:\nbool isPowerOfThree(int n) {\nreturn n > 0 && 1162261467 % n == 0;\n}\n};\n"]}, {"leetCodeID": "0342", "level": "easy", "question_description": "Given an integer n, return true if it is a power of four. Otherwise, return false.\nAn integer n is a power of four, if there exists an integer x such that n == 4x.", "examples": ["Example 1:Input: n = 16\nOutput: true\n", "Example 2:Input: n = 5\nOutput: false\n", "Example 3:Input: n = 1\nOutput: true\n"], "constraints": "\nConstraints:\n-231 <= n <= 231 - 1\n", "java_context": "\nclass Solution {\n    public boolean isPowerOfFour(int n) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number} n\n* @return {boolean}\n*/\nvar isPowerOfFour = function (n) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    bool isPowerOfFour(int n) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic boolean isPowerOfFour(int n) {\nreturn n > 0 && (n & (n - 1)) == 0 && (n & 0xaaaaaaaa) == 0;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number} n\n* @return {boolean}\n*/\nvar isPowerOfFour = function (n) {\nreturn n > 0 && (n & (n - 1)) == 0 && (n & 0xaaaaaaaa) == 0;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nbool isPowerOfFour(int n) {\nreturn n > 0 && (n & (n - 1)) == 0 && (n & 0xaaaaaaaa) == 0;\n}\n};\n"]}, {"leetCodeID": "0344", "level": "easy", "question_description": "Write a function that reverses a string. The input string is given as an array of characters s.\nYou must do this by modifying the input array in-place with O(1) extra memory.", "examples": ["Example 1:Input: s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\n", "Example 2:Input: s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\n"], "constraints": "\nConstraints:\n1 <= s.length <= 105\ns[i] is a printable ascii character.\n", "java_context": "\nclass Solution {\n    public void reverseString(char[] s) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {character[]} s\n* @return {void} Do not return anything, modify s in-place instead.\n*/\nvar reverseString = function (s) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    void reverseString(vector<char>& s) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic void reverseString(char[] s) {\nfor (int i = 0, j = s.length - 1; i < j; ++i, --j) {\nchar t = s[i];\ns[i] = s[j];\ns[j] = t;\n}\n}\n}\n"], "js_solutions": ["\n/**\n* @param {character[]} s\n* @return {void} Do not return anything, modify s in-place instead.\n*/\nvar reverseString = function (s) {\nfor (let i = 0, j = s.length - 1; i < j; ++i, --j) {\n[s[i], s[j]] = [s[j], s[i]];\n}\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvoid reverseString(vector<char>& s) {\nfor (int i = 0, j = s.size() - 1; i < j;) {\nswap(s[i++], s[j--]);\n}\n}\n};\n"]}, {"leetCodeID": "0349", "level": "easy", "question_description": "Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.", "examples": ["Example 1:\nInput: nums1 = [1,2,2,1], nums2 = [2,2]\nOutput: [2]\n", "Example 2:\nInput: nums1 = [4,9,5], nums2 = [9,4,9,8,4]\nOutput: [9,4]\nExplanation: [4,9] is also accepted.\n"], "constraints": "\nConstraints:\n1 <= nums1.length, nums2.length <= 1000\n0 <= nums1[i], nums2[i] <= 1000\n", "java_context": "\nclass Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums1\n* @param {number[]} nums2\n* @return {number[]}\n*/\nvar intersection = function (nums1, nums2) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int[] intersection(int[] nums1, int[] nums2) {\nboolean[] s = new boolean[1001];\nfor (int x : nums1) {\ns[x] = true;\n}\nList<Integer> ans = new ArrayList<>();\nfor (int x : nums2) {\nif (s[x]) {\nans.add(x);\ns[x] = false;\n}\n}\nreturn ans.stream().mapToInt(Integer::intValue).toArray();\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums1\n* @param {number[]} nums2\n* @return {number[]}\n*/\nvar intersection = function (nums1, nums2) {\nconst s = Array(1001).fill(false);\nfor (const x of nums1) {\ns[x] = true;\n}\nconst ans = [];\nfor (const x of nums2) {\nif (s[x]) {\nans.push(x);\ns[x] = false;\n}\n}\nreturn ans;\n};\n", "\n/**\n* @param {number[]} nums1\n* @param {number[]} nums2\n* @return {number[]}\n*/\nvar intersection = function (nums1, nums2) {\nreturn Array.from(new Set(nums1)).filter(num => new Set(nums2).has(num));\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\nbool s[1001];\nmemset(s, false, sizeof(s));\nfor (int x : nums1) {\ns[x] = true;\n}\nvector<int> ans;\nfor (int x : nums2) {\nif (s[x]) {\nans.push_back(x);\ns[x] = false;\n}\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0350", "level": "easy", "question_description": "Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.", "examples": ["Example 1:\nInput: nums1 = [1,2,2,1], nums2 = [2,2]\nOutput: [2,2]\n", "Example 2:\nInput: nums1 = [4,9,5], nums2 = [9,4,9,8,4]\nOutput: [4,9]\nExplanation: [9,4] is also accepted.\n"], "constraints": "\nConstraints:\n1 <= nums1.length, nums2.length <= 1000\n0 <= nums1[i], nums2[i] <= 1000\n", "java_context": "\nclass Solution {\n    public int[] intersect(int[] nums1, int[] nums2) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums1\n* @param {number[]} nums2\n* @return {number[]}\n*/\nvar intersect = function (nums1, nums2) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int[] intersect(int[] nums1, int[] nums2) {\nMap<Integer, Integer> counter = new HashMap<>();\nfor (int num : nums1) {\ncounter.put(num, counter.getOrDefault(num, 0) + 1);\n}\nList<Integer> t = new ArrayList<>();\nfor (int num : nums2) {\nif (counter.getOrDefault(num, 0) > 0) {\nt.add(num);\ncounter.put(num, counter.get(num) - 1);\n}\n}\nint[] res = new int[t.size()];\nfor (int i = 0; i < res.length; ++i) {\nres[i] = t.get(i);\n}\nreturn res;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums1\n* @param {number[]} nums2\n* @return {number[]}\n*/\nvar intersect = function (nums1, nums2) {\nconst counter = {};\nfor (const num of nums1) {\ncounter[num] = (counter[num] || 0) + 1;\n}\nlet res = [];\nfor (const num of nums2) {\nif (counter[num] > 0) {\nres.push(num);\ncounter[num] -= 1;\n}\n}\nreturn res;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\nunordered_map<int, int> counter;\nfor (int num : nums1) ++counter[num];\nvector<int> res;\nfor (int num : nums2) {\nif (counter[num] > 0) {\n--counter[num];\nres.push_back(num);\n}\n}\nreturn res;\n}\n};\n"]}, {"leetCodeID": "0387", "level": "easy", "question_description": "Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.", "examples": ["Example 1:Input: s = \"leetcode\"\nOutput: 0\n", "Example 2:Input: s = \"loveleetcode\"\nOutput: 2\n", "Example 3:Input: s = \"aabb\"\nOutput: -1\n"], "constraints": "\nConstraints:\n1 <= s.length <= 105\ns consists of only lowercase English letters.\n", "java_context": "\nclass Solution {\n    public int firstUniqChar(String s) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} s\n* @return {number}\n*/\nvar firstUniqChar = function (s) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int firstUniqChar(string s) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int firstUniqChar(String s) {\nint[] cnt = new int[26];\nint n = s.length();\nfor (int i = 0; i < n; ++i) {\n++cnt[s.charAt(i) - 'a'];\n}\nfor (int i = 0; i < n; ++i) {\nif (cnt[s.charAt(i) - 'a'] == 1) {\nreturn i;\n}\n}\nreturn -1;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} s\n* @return {number}\n*/\nvar firstUniqChar = function (s) {\nconst cnt = new Array(26).fill(0);\nfor (const c of s) {\n++cnt[c.charCodeAt() - 'a'.charCodeAt()];\n}\nfor (let i = 0; i < s.length; ++i) {\nif (cnt[s[i].charCodeAt() - 'a'.charCodeAt()] === 1) {\nreturn i;\n}\n}\nreturn -1;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint firstUniqChar(string s) {\nint cnt[26]{};\nfor (char& c : s) {\n++cnt[c - 'a'];\n}\nint n = s.size();\nfor (int i = 0; i < n; ++i) {\nif (cnt[s[i] - 'a'] == 1) {\nreturn i;\n}\n}\nreturn -1;\n}\n};\n"]}, {"leetCodeID": "0412", "level": "easy", "question_description": "Given an integer n, return a string array answer (1-indexed) where:\nanswer[i] == &quot;FizzBuzz&quot; if i is divisible by 3 and 5.\nanswer[i] == &quot;Fizz&quot; if i is divisible by 3.\nanswer[i] == &quot;Buzz&quot; if i is divisible by 5.\nanswer[i] == i (as a string) if none of the above conditions are true.", "examples": ["Example 1:Input: n = 3\nOutput: [\"1\",\"2\",\"Fizz\"]\n", "Example 2:Input: n = 5\nOutput: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\"]\n", "Example 3:Input: n = 15\nOutput: [\"1\",\"2\",\"Fizz\",\"4\",\"Buzz\",\"Fizz\",\"7\",\"8\",\"Fizz\",\"Buzz\",\"11\",\"Fizz\",\"13\",\"14\",\"FizzBuzz\"]\n"], "constraints": "\nConstraints:\n1 <= n <= 104\n", "java_context": "\nclass Solution {\n    public List<String> fizzBuzz(int n) {\n        // your code\n    }\n}", "js_context": "\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<string> fizzBuzz(int n) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic List<String> fizzBuzz(int n) {\nList<String> ans = new ArrayList<>();\nfor (int i = 1; i <= n; ++i) {\nString s = \"\";\nif (i % 3 == 0) {\ns += \"Fizz\";\n}\nif (i % 5 == 0) {\ns += \"Buzz\";\n}\nif (s.length() == 0) {\ns += i;\n}\nans.add(s);\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\nconst fizzBuzz = function (n) {\nlet arr = [];\nfor (let i = 1; i <= n; i++) {\nif (i % 15 === 0) arr.push('FizzBuzz');\nelse if (i % 3 === 0) arr.push('Fizz');\nelse if (i % 5 === 0) arr.push('Buzz');\nelse arr.push(`${i}`);\n}\nreturn arr;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<string> fizzBuzz(int n) {\nvector<string> ans;\nfor (int i = 1; i <= n; ++i) {\nstring s = \"\";\nif (i % 3 == 0) s += \"Fizz\";\nif (i % 5 == 0) s += \"Buzz\";\nif (s.size() == 0) s = to_string(i);\nans.push_back(s);\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0415", "level": "easy", "question_description": "Given two non-negative integers, num1 and num2 represented as string, return the sum of num1 and num2 as a string.\nYou must solve the problem without using any built-in library for handling large integers (such as BigInteger). You must also not convert the inputs to integers directly.", "examples": ["Example 1:\nInput: num1 = &quot;11&quot;, num2 = &quot;123&quot;\nOutput: &quot;134&quot;\n", "Example 2:\nInput: num1 = &quot;456&quot;, num2 = &quot;77&quot;\nOutput: &quot;533&quot;\n", "Example 3:\nInput: num1 = &quot;0&quot;, num2 = &quot;0&quot;\nOutput: &quot;0&quot;\n"], "constraints": "\nConstraints:\n1 <= num1.length, num2.length <= 104\nnum1 and num2 consist of only digits.\nnum1 and num2 don&#39;t have any leading zeros except for the zero itself.\n", "java_context": "\nclass Solution {\n    public String addStrings(String num1, String num2) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} num1\n* @param {string} num2\n* @return {string}\n*/\nvar addStrings = function (num1, num2) {\nlet i = num1.length - 1;\nlet j = num2.length - 1;\nconst ans = [];\nfor (let c = 0; i >= 0 || j >= 0 || c; --i, --j) {\nc += i < 0 ? 0 : +num1[i];\nc += j < 0 ? 0 : +num2[j];\nans.push(c % 10);\nc = Math.floor(c / 10);\n}\nreturn ans.reverse().join('');\n};\n\n/**\n* @param {string} num1\n* @param {string} num2\n* @return {string}\n*/\nvar subStrings = function (num1, num2) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    string addStrings(string num1, string num2) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic String addStrings(String num1, String num2) {\nint i = num1.length() - 1, j = num2.length() - 1;\nStringBuilder ans = new StringBuilder();\nfor (int c = 0; i >= 0 || j >= 0 || c > 0; --i, --j) {\nint a = i < 0 ? 0 : num1.charAt(i) - '0';\nint b = j < 0 ? 0 : num2.charAt(j) - '0';\nc += a + b;\nans.append(c % 10);\nc /= 10;\n}\nreturn ans.reverse().toString();\n}\n\npublic String subStrings(String num1, String num2) {\nint m = num1.length(), n = num2.length();\nboolean neg = m < n || (m == n && num1.compareTo(num2) < 0);\nif (neg) {\nString t = num1;\nnum1 = num2;\nnum2 = t;\n}\nint i = num1.length() - 1, j = num2.length() - 1;\nStringBuilder ans = new StringBuilder();\nfor (int c = 0; i >= 0; --i, --j) {\nc = (num1.charAt(i) - '0') - c - (j < 0 ? 0 : num2.charAt(j) - '0');\nans.append((c + 10) % 10);\nc = c < 0 ? 1 : 0;\n}\nwhile (ans.length() > 1 && ans.charAt(ans.length() - 1) == '0') {\nans.deleteCharAt(ans.length() - 1);\n}\nif (neg) {\nans.append('-');\n}\nreturn ans.reverse().toString();\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} num1\n* @param {string} num2\n* @return {string}\n*/\nvar addStrings = function (num1, num2) {\nlet i = num1.length - 1;\nlet j = num2.length - 1;\nconst ans = [];\nfor (let c = 0; i >= 0 || j >= 0 || c; --i, --j) {\nc += i < 0 ? 0 : +num1[i];\nc += j < 0 ? 0 : +num2[j];\nans.push(c % 10);\nc = Math.floor(c / 10);\n}\nreturn ans.reverse().join('');\n};\n\n/**\n* @param {string} num1\n* @param {string} num2\n* @return {string}\n*/\nvar subStrings = function (num1, num2) {\nconst m = num1.length;\nconst n = num2.length;\nconst neg = m < n || (m == n && num1 < num2);\nif (neg) {\nconst t = num1;\nnum1 = num2;\nnum2 = t;\n}\nlet i = num1.length - 1;\nlet j = num2.length - 1;\nconst ans = [];\nfor (let c = 0; i >= 0; --i, --j) {\nc = +num1[i] - c;\nif (j >= 0) {\nc -= +num2[j];\n}\nans.push((c + 10) % 10);\nc = c < 0 ? 1 : 0;\n}\nwhile (ans.length > 1 && ans.at(-1) === 0) {\nans.pop();\n}\nreturn (neg ? '-' : '') + ans.reverse().join('');\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nstring addStrings(string num1, string num2) {\nint i = num1.size() - 1, j = num2.size() - 1;\nstring ans;\nfor (int c = 0; i >= 0 || j >= 0 || c; --i, --j) {\nint a = i < 0 ? 0 : num1[i] - '0';\nint b = j < 0 ? 0 : num2[j] - '0';\nc += a + b;\nans += to_string(c % 10);\nc /= 10;\n}\nreverse(ans.begin(), ans.end());\nreturn ans;\n}\n\nstring subStrings(string num1, string num2) {\nint m = num1.size(), n = num2.size();\nbool neg = m < n || (m == n && num1 < num2);\nif (neg) {\nswap(num1, num2);\n}\nint i = num1.size() - 1, j = num2.size() - 1;\nstring ans;\nfor (int c = 0; i >= 0; --i, --j) {\nc = (num1[i] - '0') - c - (j < 0 ? 0 : num2[j] - '0');\nans += to_string((c + 10) % 10);\nc = c < 0 ? 1 : 0;\n}\nwhile (ans.size() > 1 && ans.back() == '0') {\nans.pop_back();\n}\nif (neg) {\nans.push_back('-');\n}\nreverse(ans.begin(), ans.end());\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0455", "level": "easy", "question_description": "Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.\nEach child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] &gt;= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.", "examples": ["Example 1:\nInput: g = [1,2,3], s = [1,1]\nOutput: 1\nExplanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3.\nAnd even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.\nYou need to output 1.\n", "Example 2:\nInput: g = [1,2], s = [1,2,3]\nOutput: 2\nExplanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2.\nYou have 3 cookies and their sizes are big enough to gratify all of the children,\nYou need to output 2.\n"], "constraints": "\nConstraints:\n1 <= g.length <= 3 * 104\n0 <= s.length <= 3 * 104\n1 <= g[i], s[j] <= 231 - 1\n", "java_context": "\nclass Solution {\n    public int findContentChildren(int[] g, int[] s) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} g\n* @param {number[]} s\n* @return {number}\n*/\nvar findContentChildren = function (g, s) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int findContentChildren(vector<int>& g, vector<int>& s) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int findContentChildren(int[] g, int[] s) {\nArrays.sort(g);\nArrays.sort(s);\nint m = g.length;\nint n = s.length;\nfor (int i = 0, j = 0; i < m; ++i) {\nwhile (j < n && s[j] < g[i]) {\n++j;\n}\nif (j++ >= n) {\nreturn i;\n}\n}\nreturn m;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} g\n* @param {number[]} s\n* @return {number}\n*/\nvar findContentChildren = function (g, s) {\ng.sort((a, b) => a - b);\ns.sort((a, b) => a - b);\nconst m = g.length;\nconst n = s.length;\nfor (let i = 0, j = 0; i < m; ++i) {\nwhile (j < n && s[j] < g[i]) {\n++j;\n}\nif (j++ >= n) {\nreturn i;\n}\n}\nreturn m;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint findContentChildren(vector<int>& g, vector<int>& s) {\nsort(g.begin(), g.end());\nsort(s.begin(), s.end());\nint m = g.size(), n = s.size();\nfor (int i = 0, j = 0; i < m; ++i) {\nwhile (j < n && s[j] < g[i]) {\n++j;\n}\nif (j++ >= n) {\nreturn i;\n}\n}\nreturn m;\n}\n};\n"]}, {"leetCodeID": "0461", "level": "easy", "question_description": "The Hamming distance between two integers is the number of positions at which the corresponding bits are different.\nGiven two integers x and y, return the Hamming distance between them.", "examples": ["Example 1:\nInput: x = 1, y = 4\nOutput: 2\nExplanation:\n1   (0 0 0 1)\n4   (0 1 0 0)\n&uarr;   &uarr;\nThe above arrows point to positions where the corresponding bits are different.\n", "Example 2:\nInput: x = 3, y = 1\nOutput: 1\n"], "constraints": "\nConstraints:\n0 <=&nbsp;x, y <= 231 - 1\n", "java_context": "\nclass Solution {\n    public int hammingDistance(int x, int y) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number} x\n* @param {number} y\n* @return {number}\n*/\nvar hammingDistance = function (x, y) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int hammingDistance(int x, int y) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int hammingDistance(int x, int y) {\nreturn Integer.bitCount(x ^ y);\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number} x\n* @param {number} y\n* @return {number}\n*/\nvar hammingDistance = function (x, y) {\nx ^= y;\nlet ans = 0;\nwhile (x) {\nx -= x & -x;\n++ans;\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint hammingDistance(int x, int y) {\nreturn __builtin_popcount(x ^ y);\n}\n};\n"]}, {"leetCodeID": "0485", "level": "easy", "question_description": "Given a binary array nums, return the maximum number of consecutive 1&#39;s in the array.", "examples": ["Example 1:\nInput: nums = [1,1,0,1,1,1]\nOutput: 3\nExplanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3.\n", "Example 2:\nInput: nums = [1,0,1,1,0,1]\nOutput: 2\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 105\nnums[i] is either 0 or 1.\n", "java_context": "\nclass Solution {\n    public int findMaxConsecutiveOnes(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar findMaxConsecutiveOnes = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int findMaxConsecutiveOnes(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int findMaxConsecutiveOnes(int[] nums) {\nint cnt = 0, ans = 0;\nfor (int v : nums) {\nif (v == 1) {\n++cnt;\n} else {\nans = Math.max(ans, cnt);\ncnt = 0;\n}\n}\nreturn Math.max(cnt, ans);\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar findMaxConsecutiveOnes = function (nums) {\nlet res = 0,\nt = 0;\nfor (let num of nums) {\nif (num == 1) {\n++t;\n} else {\nres = Math.max(res, t);\nt = 0;\n}\n}\nreturn Math.max(res, t);\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint findMaxConsecutiveOnes(vector<int>& nums) {\nint cnt = 0, ans = 0;\nfor (int v : nums) {\nif (v == 1) {\n++cnt;\n} else {\nans = max(ans, cnt);\ncnt = 0;\n}\n}\nreturn max(ans, cnt);\n}\n};\n"]}, {"leetCodeID": "0496", "level": "easy", "question_description": "The next greater element of some element x in an array is the first greater element that is to the right of x in the same array.\nYou are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2.\nFor each 0 &lt;= i &lt; nums1.length, find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2. If there is no next greater element, then the answer for this query is -1.\nReturn an array ans of length nums1.length such that ans[i] is the next greater element as described above.", "examples": ["Example 1:\nInput: nums1 = [4,1,2], nums2 = [1,3,4,2]\nOutput: [-1,3,-1]\nExplanation: The next greater element for each value of nums1 is as follows:\n- 4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.\n- 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3.\n- 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1.\n", "Example 2:\nInput: nums1 = [2,4], nums2 = [1,2,3,4]\nOutput: [3,-1]\nExplanation: The next greater element for each value of nums1 is as follows:\n- 2 is underlined in nums2 = [1,2,3,4]. The next greater element is 3.\n- 4 is underlined in nums2 = [1,2,3,4]. There is no next greater element, so the answer is -1.\n"], "constraints": "\nConstraints:\n1 <= nums1.length <= nums2.length <= 1000\n0 <= nums1[i], nums2[i] <= 104\nAll integers in nums1 and nums2 are unique.\nAll the integers of nums1 also appear in nums2.\n", "java_context": "\nclass Solution {\n    public int[] nextGreaterElement(int[] nums1, int[] nums2) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums1\n* @param {number[]} nums2\n* @return {number[]}\n*/\nvar nextGreaterElement = function (nums1, nums2) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int[] nextGreaterElement(int[] nums1, int[] nums2) {\nDeque<Integer> stk = new ArrayDeque<>();\nMap<Integer, Integer> m = new HashMap<>();\nfor (int v : nums2) {\nwhile (!stk.isEmpty() && stk.peek() < v) {\nm.put(stk.pop(), v);\n}\nstk.push(v);\n}\nint n = nums1.length;\nint[] ans = new int[n];\nfor (int i = 0; i < n; ++i) {\nans[i] = m.getOrDefault(nums1[i], -1);\n}\nreturn ans;\n}\n}\n", "\nclass Solution {\npublic int[] nextGreaterElement(int[] nums1, int[] nums2) {\nDeque<Integer> stk = new ArrayDeque<>();\nMap<Integer, Integer> m = new HashMap<>();\nfor (int i = nums2.length - 1; i >= 0; --i) {\nwhile (!stk.isEmpty() && stk.peek() <= nums2[i]) {\nstk.pop();\n}\nif (!stk.isEmpty()) {\nm.put(nums2[i], stk.peek());\n}\nstk.push(nums2[i]);\n}\nint n = nums1.length;\nint[] ans = new int[n];\nfor (int i = 0; i < n; ++i) {\nans[i] = m.getOrDefault(nums1[i], -1);\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums1\n* @param {number[]} nums2\n* @return {number[]}\n*/\nvar nextGreaterElement = function (nums1, nums2) {\nlet stk = [];\nlet m = {};\nfor (let v of nums2) {\nwhile (stk && stk[stk.length - 1] < v) {\nm[stk.pop()] = v;\n}\nstk.push(v);\n}\nreturn nums1.map(e => m[e] || -1);\n};\n", "\n/**\n* @param {number[]} nums1\n* @param {number[]} nums2\n* @return {number[]}\n*/\nvar nextGreaterElement = function (nums1, nums2) {\nlet stk = [];\nlet m = {};\nfor (let v of nums2.reverse()) {\nwhile (stk && stk[stk.length - 1] <= v) {\nstk.pop();\n}\nif (stk) {\nm[v] = stk[stk.length - 1];\n}\nstk.push(v);\n}\nreturn nums1.map(e => m[e] || -1);\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {\nstack<int> stk;\nunordered_map<int, int> m;\nfor (int& v : nums2) {\nwhile (!stk.empty() && stk.top() < v) {\nm[stk.top()] = v;\nstk.pop();\n}\nstk.push(v);\n}\nvector<int> ans;\nfor (int& v : nums1) ans.push_back(m.count(v) ? m[v] : -1);\nreturn ans;\n}\n};\n", "\nclass Solution {\npublic:\nvector<int> nextGreaterElement(vector<int>& nums1, vector<int>& nums2) {\nstack<int> stk;\nunordered_map<int, int> m;\nfor (int i = nums2.size() - 1; ~i; --i) {\nwhile (!stk.empty() && stk.top() <= nums2[i]) stk.pop();\nif (!stk.empty()) m[nums2[i]] = stk.top();\nstk.push(nums2[i]);\n}\nvector<int> ans;\nfor (int& v : nums1) ans.push_back(m.count(v) ? m[v] : -1);\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0509", "level": "easy", "question_description": "The Fibonacci numbers, commonly denoted F(n) form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. That is,\nF(0) = 0, F(1) = 1\nF(n) = F(n - 1) + F(n - 2), for n &gt; 1.\nGiven n, calculate F(n).", "examples": ["Example 1:\nInput: n = 2\nOutput: 1\nExplanation: F(2) = F(1) + F(0) = 1 + 0 = 1.\n", "Example 2:\nInput: n = 3\nOutput: 2\nExplanation: F(3) = F(2) + F(1) = 1 + 1 = 2.\n", "Example 3:\nInput: n = 4\nOutput: 3\nExplanation: F(4) = F(3) + F(2) = 2 + 1 = 3.\n"], "constraints": "\nConstraints:\n0 <= n <= 30\n", "java_context": "\nclass Solution {\n    public int fib(int n) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number} n\n* @return {number}\n*/\nvar fib = function (n) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int fib(int n) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int fib(int n) {\nint a = 0, b = 1;\nwhile (n-- > 0) {\nint c = a + b;\na = b;\nb = c;\n}\nreturn a;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number} n\n* @return {number}\n*/\nvar fib = function (n) {\nlet a = 0;\nlet b = 1;\nwhile (n--) {\nconst c = a + b;\na = b;\nb = c;\n}\nreturn a;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint fib(int n) {\nint a = 0, b = 1;\nwhile (n--) {\nint c = a + b;\na = b;\nb = c;\n}\nreturn a;\n}\n};\n"]}, {"leetCodeID": "0561", "level": "easy", "question_description": "Given an integer array nums of 2n integers, group these integers into n pairs (a1, b1), (a2, b2), ..., (an, bn) such that the sum of min(ai, bi) for all i is maximized. Return the maximized sum.", "examples": ["Example 1:\nInput: nums = [1,4,3,2]\nOutput: 4\nExplanation: All possible pairings (ignoring the ordering of elements) are:\n1. (1, 4), (2, 3) -&gt; min(1, 4) + min(2, 3) = 1 + 2 = 3\n2. (1, 3), (2, 4) -&gt; min(1, 3) + min(2, 4) = 1 + 2 = 3\n3. (1, 2), (3, 4) -&gt; min(1, 2) + min(3, 4) = 1 + 3 = 4\nSo the maximum possible sum is 4.", "Example 2:\nInput: nums = [6,2,6,5,1,2]\nOutput: 9\nExplanation: The optimal pairing is (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9.\n"], "constraints": "\nConstraints:\n1 <= n <= 104\nnums.length == 2 * n\n-104 <= nums[i] <= 104\n", "java_context": "\nclass Solution {\n    public int arrayPairSum(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar arrayPairSum = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int arrayPairSum(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int arrayPairSum(int[] nums) {\nArrays.sort(nums);\nint ans = 0;\nfor (int i = 0; i < nums.length; i += 2) {\nans += nums[i];\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar arrayPairSum = function (nums) {\nnums.sort((a, b) => a - b);\nlet ans = 0;\nfor (let i = 0; i < nums.length; i += 2) {\nans += nums[i];\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint arrayPairSum(vector<int>& nums) {\nsort(nums.begin(), nums.end());\nint ans = 0;\nfor (int i = 0; i < nums.size(); i += 2) ans += nums[i];\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0572", "level": "easy", "question_description": "Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.\nA subtree of a binary tree tree is a tree that consists of a node in tree and all of this node&#39;s descendants. The tree tree could also be considered as a subtree of itself.", "examples": [], "constraints": "\nConstraints:\nThe number of nodes in the root tree is in the range [1, 2000].\nThe number of nodes in the subRoot tree is in the range [1, 1000].\n-104 <= root.val <= 104\n-104 <= subRoot.val <= 104\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\n    public boolean isSubtree(TreeNode root, TreeNode subRoot) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @param {TreeNode} subRoot\n* @return {boolean}\n*/\nvar isSubtree = function (root, subRoot) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    bool isSubtree(TreeNode* root, TreeNode* subRoot) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\npublic boolean isSubtree(TreeNode root, TreeNode subRoot) {\nif (root == null) {\nreturn false;\n}\nreturn dfs(root, subRoot) || isSubtree(root.left, subRoot)\n|| isSubtree(root.right, subRoot);\n}\n\nprivate boolean dfs(TreeNode root1, TreeNode root2) {\nif (root1 == null && root2 == null) {\nreturn true;\n}\nif (root1 == null || root2 == null) {\nreturn false;\n}\nreturn root1.val == root2.val && dfs(root1.left, root2.left)\n&& dfs(root1.right, root2.right);\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @param {TreeNode} subRoot\n* @return {boolean}\n*/\nvar isSubtree = function (root, subRoot) {\nif (!root) return false;\nlet dfs = function (root1, root2) {\nif (!root1 && !root2) {\nreturn true;\n}\nif (!root1 || !root2) {\nreturn false;\n}\nreturn (\nroot1.val == root2.val && dfs(root1.left, root2.left) && dfs(root1.right, root2.right)\n);\n};\nreturn dfs(root, subRoot) || isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nbool isSubtree(TreeNode* root, TreeNode* subRoot) {\nif (!root) return 0;\nreturn dfs(root, subRoot) || isSubtree(root->left, subRoot) || isSubtree(root->right, subRoot);\n}\n\nbool dfs(TreeNode* root1, TreeNode* root2) {\nif (!root1 && !root2) return 1;\nif (!root1 || !root2) return 0;\nreturn root1->val == root2->val && dfs(root1->left, root2->left) && dfs(root1->right, root2->right);\n}\n};\n"]}, {"leetCodeID": "0617", "level": "easy", "question_description": "You are given two binary trees root1 and root2.\nImagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of the new tree.\nReturn the merged tree.\nNote: The merging process must start from the root nodes of both trees.", "examples": ["Example 1:\n\n\nInput: root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]\nOutput: [3,4,5,5,4,null,7]\n\n\nExample 2:\nInput: root1 = [1], root2 = [1,2]\nOutput: [2,2]\n"], "constraints": "\nConstraints:\nThe number of nodes in both trees is in the range [0, 2000].\n-104 <= Node.val <= 104\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root1\n* @param {TreeNode} root2\n* @return {TreeNode}\n*/\nvar mergeTrees = function (root1, root2) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\npublic TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\nif (root1 == null) {\nreturn root2;\n}\nif (root2 == null) {\nreturn root1;\n}\nTreeNode node = new TreeNode(root1.val + root2.val);\nnode.left = mergeTrees(root1.left, root2.left);\nnode.right = mergeTrees(root1.right, root2.right);\nreturn node;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root1\n* @param {TreeNode} root2\n* @return {TreeNode}\n*/\nvar mergeTrees = function (root1, root2) {\nif (!root1) {\nreturn root2;\n}\nif (!root2) {\nreturn root1;\n}\nconst node = new TreeNode(root1.val + root2.val);\nnode.left = mergeTrees(root1.left, root2.left);\nnode.right = mergeTrees(root1.right, root2.right);\nreturn node;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nTreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {\nif (!root1) return root2;\nif (!root2) return root1;\nTreeNode* node = new TreeNode(root1->val + root2->val);\nnode->left = mergeTrees(root1->left, root2->left);\nnode->right = mergeTrees(root1->right, root2->right);\nreturn node;\n}\n};\n"]}, {"leetCodeID": "0637", "level": "easy", "question_description": "Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers within 10-5 of the actual answer will be accepted.", "examples": [], "constraints": "\nConstraints:\nThe number of nodes in the tree is in the range [1, 104].\n-231 <= Node.val <= 231 - 1\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\n    public List<Double> averageOfLevels(TreeNode root) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {number[]}\n*/\nvar averageOfLevels = function (root) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    vector<double> averageOfLevels(TreeNode* root) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\npublic List<Double> averageOfLevels(TreeNode root) {\nList<Double> ans = new ArrayList<>();\nDeque<TreeNode> q = new ArrayDeque<>();\nq.offer(root);\nwhile (!q.isEmpty()) {\nint n = q.size();\nlong s = 0;\nfor (int i = 0; i < n; ++i) {\nroot = q.pollFirst();\ns += root.val;\nif (root.left != null) {\nq.offer(root.left);\n}\nif (root.right != null) {\nq.offer(root.right);\n}\n}\nans.add(s * 1.0 / n);\n}\nreturn ans;\n}\n}\n", "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\nprivate List<Long> s = new ArrayList<>();\nprivate List<Integer> cnt = new ArrayList<>();\n\npublic List<Double> averageOfLevels(TreeNode root) {\ndfs(root, 0);\nList<Double> ans = new ArrayList<>();\nfor (int i = 0; i < s.size(); ++i) {\nans.add(s.get(i) * 1.0 / cnt.get(i));\n}\nreturn ans;\n}\n\nprivate void dfs(TreeNode root, int i) {\nif (root == null) {\nreturn;\n}\nif (s.size() == i) {\ns.add((long) root.val);\ncnt.add(1);\n} else {\ns.set(i, s.get(i) + root.val);\ncnt.set(i, cnt.get(i) + 1);\n}\ndfs(root.left, i + 1);\ndfs(root.right, i + 1);\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {number[]}\n*/\nvar averageOfLevels = function (root) {\nconst q = [root];\nconst ans = [];\nwhile (q.length) {\nconst n = q.length;\nlet s = 0;\nfor (let i = 0; i < n; ++i) {\nroot = q.shift();\ns += root.val;\nif (root.left) {\nq.push(root.left);\n}\nif (root.right) {\nq.push(root.right);\n}\n}\nans.push(s / n);\n}\nreturn ans;\n};\n", "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {number[]}\n*/\nvar averageOfLevels = function (root) {\nlet s = [];\nlet cnt = [];\nfunction dfs(root, i) {\nif (!root) {\nreturn;\n}\nif (s.length == i) {\ns.push(root.val);\ncnt.push(1);\n} else {\ns[i] += root.val;\ncnt[i]++;\n}\ndfs(root.left, i + 1);\ndfs(root.right, i + 1);\n}\ndfs(root, 0);\nlet ans = [];\nfor (let i = 0; i < s.length; ++i) {\nans.push(s[i] / cnt[i]);\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nvector<double> averageOfLevels(TreeNode* root) {\nqueue<TreeNode*> q{{root}};\nvector<double> ans;\nwhile (!q.empty()) {\nint n = q.size();\nlong long s = 0;\nfor (int i = 0; i < n; ++i) {\nroot = q.front();\nq.pop();\ns += root->val;\nif (root->left) q.push(root->left);\nif (root->right) q.push(root->right);\n}\nans.push_back(s * 1.0 / n);\n}\nreturn ans;\n}\n};\n", "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\n\nusing ll = long long;\n\nclass Solution {\npublic:\nvector<ll> s;\nvector<int> cnt;\n\nvector<double> averageOfLevels(TreeNode* root) {\ndfs(root, 0);\nvector<double> ans(s.size());\nfor (int i = 0; i < s.size(); ++i) {\nans[i] = (s[i] * 1.0 / cnt[i]);\n}\nreturn ans;\n}\n\nvoid dfs(TreeNode* root, int i) {\nif (!root) return;\nif (s.size() == i) {\ns.push_back(root->val);\ncnt.push_back(1);\n} else {\ns[i] += root->val;\ncnt[i]++;\n}\ndfs(root->left, i + 1);\ndfs(root->right, i + 1);\n}\n};\n"]}, {"leetCodeID": "0671", "level": "easy", "question_description": "Given a non-empty special binary tree consisting of nodes with the non-negative value, where each node in this tree has exactly two or zero sub-node. If the node has two sub-nodes, then this node&#39;s value is the smaller value among its two sub-nodes. More formally, the property root.val = min(root.left.val, root.right.val) always holds.\nGiven such a binary tree, you need to output the second minimum value in the set made of all the nodes&#39; value in the whole tree.\nIf no such second minimum value exists, output -1 instead.", "examples": [], "constraints": "\nExample 1:\nInput: root = [2,2,5,null,null,5,7]\nOutput: 5\nExplanation: The smallest value is 2, the second smallest value is 5.\nExample 2:\nInput: root = [2,2,2]\nOutput: -1\nExplanation: The smallest value is 2, but there isn&#39;t any second smallest value.\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\n    private int ans = -1;\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {number}\n*/\nvar findSecondMinimumValue = function (root) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    int ans = -1;\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\nprivate int ans = -1;\n\npublic int findSecondMinimumValue(TreeNode root) {\ndfs(root, root.val);\nreturn ans;\n}\n\nprivate void dfs(TreeNode root, int val) {\nif (root != null) {\ndfs(root.left, val);\ndfs(root.right, val);\nif (root.val > val) {\nans = ans == -1 ? root.val : Math.min(ans, root.val);\n}\n}\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {number}\n*/\nvar findSecondMinimumValue = function (root) {\nlet ans = -1;\nconst v = root.val;\nfunction dfs(root) {\nif (!root) {\nreturn;\n}\ndfs(root.left);\ndfs(root.right);\nif (root.val > v) {\nif (ans == -1 || ans > root.val) {\nans = root.val;\n}\n}\n}\ndfs(root);\nreturn ans;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nint ans = -1;\n\nint findSecondMinimumValue(TreeNode* root) {\ndfs(root, root->val);\nreturn ans;\n}\n\nvoid dfs(TreeNode* root, int val) {\nif (!root) return;\ndfs(root->left, val);\ndfs(root->right, val);\nif (root->val > val) ans = ans == -1 ? root->val : min(ans, root->val);\n}\n};\n"]}, {"leetCodeID": "0680", "level": "easy", "question_description": "Given a string s, return true if the s can be palindrome after deleting at most one character from it.", "examples": ["Example 1:\nInput: s = &quot;aba&quot;\nOutput: true\n", "Example 2:\nInput: s = &quot;abca&quot;\nOutput: true\nExplanation: You could delete the character &#39;c&#39;.\n", "Example 3:\nInput: s = &quot;abc&quot;\nOutput: false\n"], "constraints": "\nConstraints:\n1 <= s.length <= 105\ns consists of lowercase English letters.\n", "java_context": "\nclass Solution {\n    public boolean validPalindrome(String s) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} s\n* @return {boolean}\n*/\nvar validPalindrome = function (s) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    bool validPalindrome(string s) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic boolean validPalindrome(String s) {\nfor (int i = 0, j = s.length() - 1; i < j; ++i, --j) {\nif (s.charAt(i) != s.charAt(j)) {\nreturn check(s, i + 1, j) || check(s, i, j - 1);\n}\n}\nreturn true;\n}\n\nprivate boolean check(String s, int i, int j) {\nfor (; i < j; ++i, --j) {\nif (s.charAt(i) != s.charAt(j)) {\nreturn false;\n}\n}\nreturn true;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} s\n* @return {boolean}\n*/\nvar validPalindrome = function (s) {\nlet check = function (i, j) {\nfor (; i < j; ++i, --j) {\nif (s.charAt(i) != s.charAt(j)) {\nreturn false;\n}\n}\nreturn true;\n};\nfor (let i = 0, j = s.length - 1; i < j; ++i, --j) {\nif (s.charAt(i) != s.charAt(j)) {\nreturn check(i + 1, j) || check(i, j - 1);\n}\n}\nreturn true;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nbool validPalindrome(string s) {\nfor (int i = 0, j = s.size() - 1; i < j; ++i, --j) {\nif (s[i] != s[j]) {\nreturn check(s, i + 1, j) || check(s, i, j - 1);\n}\n}\nreturn 1;\n}\n\nbool check(string s, int i, int j) {\nfor (; i < j; ++i, --j) {\nif (s[i] != s[j]) {\nreturn false;\n}\n}\nreturn true;\n}\n};\n"]}, {"leetCodeID": "0703", "level": "easy", "question_description": "Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.\nImplement KthLargest class:\nKthLargest(int k, int[] nums) Initializes the object with the integer k and the stream of integers nums.\nint add(int val) Appends the integer val to the stream and returns the element representing the kth largest element in the stream.", "examples": ["Example 1:\nInput\n[&quot;KthLargest&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;, &quot;add&quot;]\n[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]\nOutput\n[null, 4, 5, 5, 8, 8]\n\nExplanation\nKthLargest kthLargest = new KthLargest(3, [4, 5, 8, 2]);\nkthLargest.add(3);   // return 4\nkthLargest.add(5);   // return 5\nkthLargest.add(10);  // return 5\nkthLargest.add(9);   // return 8\nkthLargest.add(4);   // return 8\n"], "constraints": "\nConstraints:\n1 <= k <= 104\n0 <= nums.length <= 104\n-104 <= nums[i] <= 104\n-104 <= val <= 104\nAt most 104 calls will be made to add.\nIt is guaranteed that there will be at least k elements in the array when you search for the kth element.\n", "java_context": "    \n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number} k\n* @param {number[]} nums\n*/\nvar KthLargest = function (k, nums) {\n    // your code\n};", "cpp_context": "    \n        // your code\n    }\n};", "java_solutions": ["\nclass KthLargest {\nprivate PriorityQueue<Integer> q;\nprivate int size;\n\npublic KthLargest(int k, int[] nums) {\nq = new PriorityQueue<>(k);\nsize = k;\nfor (int num : nums) {\nadd(num);\n}\n}\n\npublic int add(int val) {\nq.offer(val);\nif (q.size() > size) {\nq.poll();\n}\nreturn q.peek();\n}\n}\n\n/**\n* Your KthLargest object will be instantiated and called as such:\n* KthLargest obj = new KthLargest(k, nums);\n* int param_1 = obj.add(val);\n*/\n"], "js_solutions": ["\n/**\n* @param {number} k\n* @param {number[]} nums\n*/\nvar KthLargest = function (k, nums) {\nthis.k = k;\nthis.heap = new MinHeap();\nfor (let num of nums) {\nthis.add(num);\n}\n};\n\n/**\n* @param {number} val\n* @return {number}\n*/\nKthLargest.prototype.add = function (val) {\nthis.heap.offer(val);\nif (this.heap.size() > this.k) {\nthis.heap.poll();\n}\nreturn this.heap.peek();\n};\n\nclass MinHeap {\nconstructor(data = []) {\nthis.data = data;\nthis.comparator = (a, b) => a - b;\nthis.heapify();\n}\n\nheapify() {\nif (this.size() < 2) return;\nfor (let i = 1; i < this.size(); i++) {\nthis.bubbleUp(i);\n}\n}\n\npeek() {\nif (this.size() === 0) return null;\nreturn this.data[0];\n}\n\noffer(value) {\nthis.data.push(value);\nthis.bubbleUp(this.size() - 1);\n}\n\npoll() {\nif (this.size() === 0) {\nreturn null;\n}\nconst result = this.data[0];\nconst last = this.data.pop();\nif (this.size() !== 0) {\nthis.data[0] = last;\nthis.bubbleDown(0);\n}\nreturn result;\n}\n\nbubbleUp(index) {\nwhile (index > 0) {\nconst parentIndex = (index - 1) >> 1;\nif (this.comparator(this.data[index], this.data[parentIndex]) < 0) {\nthis.swap(index, parentIndex);\nindex = parentIndex;\n} else {\nbreak;\n}\n}\n}\n\nbubbleDown(index) {\nconst lastIndex = this.size() - 1;\nwhile (true) {\nconst leftIndex = index * 2 + 1;\nconst rightIndex = index * 2 + 2;\nlet findIndex = index;\nif (\nleftIndex <= lastIndex &&\nthis.comparator(this.data[leftIndex], this.data[findIndex]) < 0\n) {\nfindIndex = leftIndex;\n}\nif (\nrightIndex <= lastIndex &&\nthis.comparator(this.data[rightIndex], this.data[findIndex]) < 0\n) {\nfindIndex = rightIndex;\n}\nif (index !== findIndex) {\nthis.swap(index, findIndex);\nindex = findIndex;\n} else {\nbreak;\n}\n}\n}\n\nswap(index1, index2) {\n[this.data[index1], this.data[index2]] = [this.data[index2], this.data[index1]];\n}\n\nsize() {\nreturn this.data.length;\n}\n}\n\n/**\n* Your KthLargest object will be instantiated and called as such:\n* var obj = new KthLargest(k, nums)\n* var param_1 = obj.add(val)\n*/\n"], "cpp_solutions": ["\nclass KthLargest {\npublic:\npriority_queue<int, vector<int>, greater<int>> q;\nint size;\n\nKthLargest(int k, vector<int>& nums) {\nsize = k;\nfor (int num : nums) add(num);\n}\n\nint add(int val) {\nq.push(val);\nif (q.size() > size) q.pop();\nreturn q.top();\n}\n};\n\n/**\n* Your KthLargest object will be instantiated and called as such:\n* KthLargest* obj = new KthLargest(k, nums);\n* int param_1 = obj->add(val);\n*/\n"]}, {"leetCodeID": "0704", "level": "easy", "question_description": "Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\nYou must write an algorithm with O(log n) runtime complexity.", "examples": ["Example 1:\nInput: nums = [-1,0,3,5,9,12], target = 9\nOutput: 4\nExplanation: 9 exists in nums and its index is 4\n", "Example 2:\nInput: nums = [-1,0,3,5,9,12], target = 2\nOutput: -1\nExplanation: 2 does not exist in nums so return -1\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 104\n-104 < nums[i], target < 104\nAll the integers in nums are unique.\nnums is sorted in ascending order.\n", "java_context": "\nclass Solution {\n    public int search(int[] nums, int target) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @param {number} target\n* @return {number}\n*/\nvar search = function (nums, target) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int search(int[] nums, int target) {\nint left = 0, right = nums.length - 1;\nwhile (left < right) {\nint mid = (left + right) >> 1;\nif (nums[mid] >= target) {\nright = mid;\n} else {\nleft = mid + 1;\n}\n}\nreturn nums[left] == target ? left : -1;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @param {number} target\n* @return {number}\n*/\nvar search = function (nums, target) {\nlet left = 0;\nlet right = nums.length - 1;\nwhile (left < right) {\nconst mid = (left + right) >> 1;\nif (nums[mid] >= target) {\nright = mid;\n} else {\nleft = mid + 1;\n}\n}\nreturn nums[left] == target ? left : -1;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint search(vector<int>& nums, int target) {\nint left = 0, right = nums.size() - 1;\nwhile (left < right) {\nint mid = left + right >> 1;\nif (nums[mid] >= target)\nright = mid;\nelse\nleft = mid + 1;\n}\nreturn nums[left] == target ? left : -1;\n}\n};\n"]}, {"leetCodeID": "0717", "level": "easy", "question_description": "We have two special characters:\nThe first character can be represented by one bit 0.\nThe second character can be represented by two bits (10 or 11).\nGiven a binary array bits that ends with 0, return true if the last character must be a one-bit character.", "examples": ["Example 1:\nInput: bits = [1,0,0]\nOutput: true\nExplanation: The only way to decode it is two-bit character and one-bit character.\nSo the last character is one-bit character.\n", "Example 2:\nInput: bits = [1,1,1,0]\nOutput: false\nExplanation: The only way to decode it is two-bit character and two-bit character.\nSo the last character is not one-bit character.\n"], "constraints": "\nConstraints:\n1 <= bits.length <= 1000\nbits[i] is either 0 or 1.\n", "java_context": "\nclass Solution {\n    public boolean isOneBitCharacter(int[] bits) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} bits\n* @return {boolean}\n*/\nvar isOneBitCharacter = function (bits) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    bool isOneBitCharacter(vector<int>& bits) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic boolean isOneBitCharacter(int[] bits) {\nint i = 0, n = bits.length;\nwhile (i < n - 1) {\ni += bits[i] + 1;\n}\nreturn i == n - 1;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} bits\n* @return {boolean}\n*/\nvar isOneBitCharacter = function (bits) {\nlet i = 0;\nconst n = bits.length;\nwhile (i < n - 1) {\ni += bits[i] + 1;\n}\nreturn i == n - 1;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nbool isOneBitCharacter(vector<int>& bits) {\nint i = 0, n = bits.size();\nwhile (i < n - 1) i += bits[i] + 1;\nreturn i == n - 1;\n}\n};\n"]}, {"leetCodeID": "0724", "level": "easy", "question_description": "Given an array of integers nums, calculate the pivot index of this array.\nThe pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index&#39;s right.\nIf the index is on the left edge of the array, then the left sum is 0 because there are no elements to the left. This also applies to the right edge of the array.\nReturn the leftmost pivot index. If no such index exists, return -1.", "examples": ["Example 1:\nInput: nums = [1,7,3,6,5,6]\nOutput: 3\nExplanation:\nThe pivot index is 3.\nLeft sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11\nRight sum = nums[4] + nums[5] = 5 + 6 = 11\n", "Example 2:\nInput: nums = [1,2,3]\nOutput: -1\nExplanation:\nThere is no index that satisfies the conditions in the problem statement.", "Example 3:\nInput: nums = [2,1,-1]\nOutput: 0\nExplanation:\nThe pivot index is 0.\nLeft sum = 0 (no elements to the left of index 0)\nRight sum = nums[1] + nums[2] = 1 + -1 = 0\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 104\n-1000 <= nums[i] <= 1000\n", "java_context": "\nclass Solution {\n    public int pivotIndex(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar pivotIndex = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int pivotIndex(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int pivotIndex(int[] nums) {\nint left = 0, right = Arrays.stream(nums).sum();\nfor (int i = 0; i < nums.length; ++i) {\nright -= nums[i];\nif (left == right) {\nreturn i;\n}\nleft += nums[i];\n}\nreturn -1;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar pivotIndex = function (nums) {\nlet left = 0,\nright = nums.reduce((a, b) => a + b);\nfor (let i = 0; i < nums.length; ++i) {\nright -= nums[i];\nif (left == right) {\nreturn i;\n}\nleft += nums[i];\n}\nreturn -1;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint pivotIndex(vector<int>& nums) {\nint left = 0, right = accumulate(nums.begin(), nums.end(), 0);\nfor (int i = 0; i < nums.size(); ++i) {\nright -= nums[i];\nif (left == right) {\nreturn i;\n}\nleft += nums[i];\n}\nreturn -1;\n}\n};\n"]}, {"leetCodeID": "0747", "level": "easy", "question_description": "You are given an integer array nums where the largest integer is unique.\nDetermine whether the largest element in the array is at least twice as much as every other number in the array. If it is, return the index of the largest element, or return -1 otherwise.", "examples": ["Example 1:\nInput: nums = [3,6,1,0]\nOutput: 1\nExplanation: 6 is the largest integer.\nFor every other number in the array x, 6 is at least twice as big as x.\nThe index of value 6 is 1, so we return 1.\n", "Example 2:\nInput: nums = [1,2,3,4]\nOutput: -1\nExplanation: 4 is less than twice the value of 3, so we return -1.\n"], "constraints": "\nConstraints:\n2 <= nums.length <= 50\n0 <= nums[i] <= 100\nThe largest element in nums is unique.\n", "java_context": "\nclass Solution {\n    public int dominantIndex(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar dominantIndex = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int dominantIndex(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int dominantIndex(int[] nums) {\nint n = nums.length;\nint k = 0;\nfor (int i = 0; i < n; ++i) {\nif (nums[k] < nums[i]) {\nk = i;\n}\n}\nfor (int i = 0; i < n; ++i) {\nif (k != i && nums[k] < nums[i] * 2) {\nreturn -1;\n}\n}\nreturn k;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar dominantIndex = function (nums) {\nlet k = 0;\nfor (let i = 0; i < nums.length; ++i) {\nif (nums[i] > nums[k]) {\nk = i;\n}\n}\nfor (let i = 0; i < nums.length; ++i) {\nif (i !== k && nums[k] < nums[i] * 2) {\nreturn -1;\n}\n}\nreturn k;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint dominantIndex(vector<int>& nums) {\nint n = nums.size();\nint k = 0;\nfor (int i = 0; i < n; ++i) {\nif (nums[k] < nums[i]) {\nk = i;\n}\n}\nfor (int i = 0; i < n; ++i) {\nif (k != i && nums[k] < nums[i] * 2) {\nreturn -1;\n}\n}\nreturn k;\n}\n};\n"]}, {"leetCodeID": "0766", "level": "easy", "question_description": "Given an m x n matrix, return true if the matrix is Toeplitz. Otherwise, return false.\nA matrix is Toeplitz if every diagonal from top-left to bottom-right has the same elements.", "examples": [], "constraints": "\nConstraints:\nm == matrix.length\nn == matrix[i].length\n1 <= m, n <= 20\n0 <= matrix[i][j] <= 99\n", "java_context": "\nclass Solution {\n    public boolean isToeplitzMatrix(int[][] matrix) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[][]} matrix\n* @return {boolean}\n*/\nvar isToeplitzMatrix = function (matrix) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    bool isToeplitzMatrix(vector<vector<int>>& matrix) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic boolean isToeplitzMatrix(int[][] matrix) {\nint m = matrix.length, n = matrix[0].length;\nfor (int i = 1; i < m; ++i) {\nfor (int j = 1; j < n; ++j) {\nif (matrix[i][j] != matrix[i - 1][j - 1]) {\nreturn false;\n}\n}\n}\nreturn true;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[][]} matrix\n* @return {boolean}\n*/\nvar isToeplitzMatrix = function (matrix) {\nconst m = matrix.length;\nconst n = matrix[0].length;\nfor (let i = 1; i < m; ++i) {\nfor (let j = 1; j < n; ++j) {\nif (matrix[i][j] != matrix[i - 1][j - 1]) {\nreturn false;\n}\n}\n}\nreturn true;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nbool isToeplitzMatrix(vector<vector<int>>& matrix) {\nint m = matrix.size(), n = matrix[0].size();\nfor (int i = 1; i < m; ++i) {\nfor (int j = 1; j < n; ++j) {\nif (matrix[i][j] != matrix[i - 1][j - 1]) {\nreturn false;\n}\n}\n}\nreturn true;\n}\n};\n"]}, {"leetCodeID": "0771", "level": "easy", "question_description": "You&#39;re given strings jewels representing the types of stones that are jewels, and stones representing the stones you have. Each character in stones is a type of stone you have. You want to know how many of the stones you have are also jewels.\nLetters are case sensitive, so &quot;a&quot; is considered a different type of stone from &quot;A&quot;.", "examples": ["Example 1:Input: jewels = \"aA\", stones = \"aAAbbbb\"\nOutput: 3\n", "Example 2:Input: jewels = \"z\", stones = \"ZZ\"\nOutput: 0\n"], "constraints": "\nConstraints:\n1 <=&nbsp;jewels.length, stones.length <= 50\njewels and stones consist of only English letters.\nAll the characters of&nbsp;jewels are unique.\n", "java_context": "\nclass Solution {\n    public int numJewelsInStones(String jewels, String stones) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} jewels\n* @param {string} stones\n* @return {number}\n*/\nvar numJewelsInStones = function (jewels, stones) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int numJewelsInStones(string jewels, string stones) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int numJewelsInStones(String jewels, String stones) {\nint[] s = new int[128];\nfor (char c : jewels.toCharArray()) {\ns[c] = 1;\n}\nint ans = 0;\nfor (char c : stones.toCharArray()) {\nans += s[c];\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} jewels\n* @param {string} stones\n* @return {number}\n*/\nvar numJewelsInStones = function (jewels, stones) {\nconst s = new Set(jewels.split(''));\nreturn stones.split('').reduce((prev, val) => prev + s.has(val), 0);\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint numJewelsInStones(string jewels, string stones) {\nint s[128] = {0};\nfor (char c : jewels) s[c] = 1;\nint ans = 0;\nfor (char c : stones) ans += s[c];\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0783", "level": "easy", "question_description": "Given the root of a Binary Search Tree (BST), return the minimum difference between the values of any two different nodes in the tree.", "examples": [], "constraints": "\nConstraints:\nThe number of nodes in the tree is in the range [2, 100].\n0 <= Node.val <= 105\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\n    private int ans;\n        // your code\n    }\n}", "js_context": "\nvar minDiffInBST = function (root) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    const int inf = INT_MAX;\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\nprivate int ans;\nprivate int prev;\nprivate int inf = Integer.MAX_VALUE;\n\npublic int minDiffInBST(TreeNode root) {\nans = inf;\nprev = inf;\ndfs(root);\nreturn ans;\n}\n\nprivate void dfs(TreeNode root) {\nif (root == null) {\nreturn;\n}\ndfs(root.left);\nans = Math.min(ans, Math.abs(root.val - prev));\nprev = root.val;\ndfs(root.right);\n}\n}\n"], "js_solutions": ["\nvar minDiffInBST = function (root) {\nlet ans = Number.MAX_SAFE_INTEGER,\nprev = Number.MAX_SAFE_INTEGER;\nconst dfs = root => {\nif (!root) {\nreturn;\n}\ndfs(root.left);\nans = Math.min(ans, Math.abs(root.val - prev));\nprev = root.val;\ndfs(root.right);\n};\ndfs(root);\nreturn ans;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nconst int inf = INT_MAX;\nint ans;\nint prev;\n\nint minDiffInBST(TreeNode* root) {\nans = inf, prev = inf;\ndfs(root);\nreturn ans;\n}\n\nvoid dfs(TreeNode* root) {\nif (!root) return;\ndfs(root->left);\nans = min(ans, abs(prev - root->val));\nprev = root->val;\ndfs(root->right);\n}\n};\n"]}, {"leetCodeID": "0832", "level": "easy", "question_description": "Given an n x n binary matrix image, flip the image horizontally, then invert it, and return the resulting image.\nTo flip an image horizontally means that each row of the image is reversed.\nFor example, flipping [1,1,0] horizontally results in [0,1,1].\nTo invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0.\nFor example, inverting [0,1,1] results in [1,0,0].", "examples": ["Example 1:\nInput: image = [[1,1,0],[1,0,1],[0,0,0]]\nOutput: [[1,0,0],[0,1,0],[1,1,1]]\nExplanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]].\nThen, invert the image: [[1,0,0],[0,1,0],[1,1,1]]\n", "Example 2:\nInput: image = [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]\nOutput: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\nExplanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]].\nThen invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]\n"], "constraints": "\nConstraints:\nn == image.length\nn == image[i].length\n1 <= n <= 20\nimages[i][j] is either 0 or 1.\n", "java_context": "\nclass Solution {\n    public int[][] flipAndInvertImage(int[][] image) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[][]} image\n* @return {number[][]}\n*/\nvar flipAndInvertImage = function (image) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int[][] flipAndInvertImage(int[][] image) {\nfor (var row : image) {\nint i = 0, j = row.length - 1;\nfor (; i < j; ++i, --j) {\nif (row[i] == row[j]) {\nrow[i] ^= 1;\nrow[j] ^= 1;\n}\n}\nif (i == j) {\nrow[i] ^= 1;\n}\n}\nreturn image;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[][]} image\n* @return {number[][]}\n*/\nvar flipAndInvertImage = function (image) {\nfor (const row of image) {\nlet i = 0;\nlet j = row.length - 1;\nfor (; i < j; ++i, --j) {\nif (row[i] == row[j]) {\nrow[i] ^= 1;\nrow[j] ^= 1;\n}\n}\nif (i == j) {\nrow[i] ^= 1;\n}\n}\nreturn image;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<vector<int>> flipAndInvertImage(vector<vector<int>>& image) {\nfor (auto& row : image) {\nint i = 0, j = row.size() - 1;\nfor (; i < j; ++i, --j) {\nif (row[i] == row[j]) {\nrow[i] ^= 1;\nrow[j] ^= 1;\n}\n}\nif (i == j) {\nrow[i] ^= 1;\n}\n}\nreturn image;\n}\n};\n"]}, {"leetCodeID": "0867", "level": "easy", "question_description": "Given a 2D integer array matrix, return the transpose of matrix.\nThe transpose of a matrix is the matrix flipped over its main diagonal, switching the matrix&#39;s row and column indices.", "examples": ["Example 1:\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [[1,4,7],[2,5,8],[3,6,9]]\n", "Example 2:\nInput: matrix = [[1,2,3],[4,5,6]]\nOutput: [[1,4],[2,5],[3,6]]\n"], "constraints": "\nConstraints:\nm == matrix.length\nn == matrix[i].length\n1 <= m, n <= 1000\n1 <= m * n <= 105\n-109 <= matrix[i][j] <= 109\n", "java_context": "\nclass Solution {\n    public int[][] transpose(int[][] matrix) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[][]} matrix\n* @return {number[][]}\n*/\nvar transpose = function (matrix) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<vector<int>> transpose(vector<vector<int>>& matrix) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int[][] transpose(int[][] matrix) {\nint m = matrix.length, n = matrix[0].length;\nint[][] ans = new int[n][m];\nfor (int i = 0; i < n; ++i) {\nfor (int j = 0; j < m; ++j) {\nans[i][j] = matrix[j][i];\n}\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[][]} matrix\n* @return {number[][]}\n*/\nvar transpose = function (matrix) {\nconst m = matrix.length;\nconst n = matrix[0].length;\nconst ans = new Array(n).fill(0).map(() => new Array(m).fill(0));\nfor (let i = 0; i < n; ++i) {\nfor (let j = 0; j < m; ++j) {\nans[i][j] = matrix[j][i];\n}\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<vector<int>> transpose(vector<vector<int>>& matrix) {\nint m = matrix.size(), n = matrix[0].size();\nvector<vector<int>> ans(n, vector<int>(m));\nfor (int i = 0; i < n; ++i)\nfor (int j = 0; j < m; ++j)\nans[i][j] = matrix[j][i];\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0872", "level": "easy", "question_description": "Consider all the leaves of a binary tree, from left to right order, the values of those leaves form a leaf value sequence.\nFor example, in the given tree above, the leaf value sequence is (6, 7, 4, 9, 8).\nTwo binary trees are considered leaf-similar if their leaf value sequence is the same.\nReturn true if and only if the two given trees with head nodes root1 and root2 are leaf-similar.", "examples": [], "constraints": "\nConstraints:\nThe number of nodes in each tree will be in the range [1, 200].\nBoth of the given trees will have values in the range [0, 200].\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\n    public boolean leafSimilar(TreeNode root1, TreeNode root2) {\n        // your code\n    }\n}", "js_context": "\nvar leafSimilar = function (root1, root2) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    bool leafSimilar(TreeNode* root1, TreeNode* root2) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\npublic boolean leafSimilar(TreeNode root1, TreeNode root2) {\nList<Integer> l1 = dfs(root1);\nList<Integer> l2 = dfs(root2);\nreturn l1.equals(l2);\n}\n\nprivate List<Integer> dfs(TreeNode root) {\nif (root == null) {\nreturn new ArrayList<>();\n}\nList<Integer> ans = dfs(root.left);\nans.addAll(dfs(root.right));\nif (ans.isEmpty()) {\nans.add(root.val);\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\nvar leafSimilar = function (root1, root2) {\nconst dfs = root => {\nif (!root) {\nreturn [];\n}\nlet ans = [...dfs(root.left), ...dfs(root.right)];\nif (!ans.length) {\nans = [root.val];\n}\nreturn ans;\n};\nconst l1 = dfs(root1);\nconst l2 = dfs(root2);\nreturn l1.toString() === l2.toString();\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nbool leafSimilar(TreeNode* root1, TreeNode* root2) {\nreturn dfs(root1) == dfs(root2);\n}\n\nvector<int> dfs(TreeNode* root) {\nif (!root) return {};\nauto ans = dfs(root->left);\nauto right = dfs(root->right);\nans.insert(ans.end(), right.begin(), right.end());\nif (ans.empty()) ans.push_back(root->val);\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0884", "level": "easy", "question_description": "A sentence is a string of single-space separated words where each word consists only of lowercase letters.\nA word is uncommon if it appears exactly once in one of the sentences, and does not appear in the other sentence.\nGiven two sentences s1 and s2, return a list of all the uncommon words. You may return the answer in any order.", "examples": ["Example 1:Input: s1 = \"this apple is sweet\", s2 = \"this apple is sour\"\nOutput: [\"sweet\",\"sour\"]\n", "Example 2:Input: s1 = \"apple apple\", s2 = \"banana\"\nOutput: [\"banana\"]\n"], "constraints": "\nConstraints:\n1 <= s1.length, s2.length <= 200\ns1 and s2 consist of lowercase English letters and spaces.\ns1 and s2 do not have leading or trailing spaces.\nAll the words in s1 and s2 are separated by a single space.\n", "java_context": "\nclass Solution {\n    public String[] uncommonFromSentences(String s1, String s2) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} s1\n* @param {string} s2\n* @return {string[]}\n*/\nvar uncommonFromSentences = function (s1, s2) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<string> uncommonFromSentences(string s1, string s2) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic String[] uncommonFromSentences(String s1, String s2) {\nMap<String, Integer> cnt = new HashMap<>();\nfor (String s : s1.split(\" \")) {\ncnt.merge(s, 1, Integer::sum);\n}\nfor (String s : s2.split(\" \")) {\ncnt.merge(s, 1, Integer::sum);\n}\nList<String> ans = new ArrayList<>();\nfor (var e : cnt.entrySet()) {\nif (e.getValue() == 1) {\nans.add(e.getKey());\n}\n}\nreturn ans.toArray(new String[0]);\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} s1\n* @param {string} s2\n* @return {string[]}\n*/\nvar uncommonFromSentences = function (s1, s2) {\nconst cnt = new Map();\nfor (const s of [...s1.split(' '), ...s2.split(' ')]) {\ncnt.set(s, (cnt.get(s) || 0) + 1);\n}\nconst ans = [];\nfor (const [s, v] of cnt.entries()) {\nif (v == 1) {\nans.push(s);\n}\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<string> uncommonFromSentences(string s1, string s2) {\nunordered_map<string, int> cnt;\nauto add = [&](string& s) {\nstringstream ss(s);\nstring w;\nwhile (ss >> w) ++cnt[move(w)];\n};\nadd(s1);\nadd(s2);\nvector<string> ans;\nfor (auto& [s, v] : cnt)\nif (v == 1) ans.emplace_back(s);\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0896", "level": "easy", "question_description": "An array is monotonic if it is either monotone increasing or monotone decreasing.\nAn array nums is monotone increasing if for all i &lt;= j, nums[i] &lt;= nums[j]. An array nums is monotone decreasing if for all i &lt;= j, nums[i] &gt;= nums[j].\nGiven an integer array nums, return true if the given array is monotonic, or false otherwise.", "examples": ["Example 1:\nInput: nums = [1,2,2,3]\nOutput: true\n", "Example 2:\nInput: nums = [6,5,4,4]\nOutput: true\n", "Example 3:\nInput: nums = [1,3,2]\nOutput: false\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 105\n-105 <= nums[i] <= 105\n", "java_context": "\nclass Solution {\n    public boolean isMonotonic(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {boolean}\n*/\nvar isMonotonic = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    bool isMonotonic(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic boolean isMonotonic(int[] nums) {\nboolean asc = false, desc = false;\nfor (int i = 1; i < nums.length; ++i) {\nif (nums[i - 1] < nums[i]) {\nasc = true;\n} else if (nums[i - 1] > nums[i]) {\ndesc = true;\n}\nif (asc && desc) {\nreturn false;\n}\n}\nreturn true;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {boolean}\n*/\nvar isMonotonic = function (nums) {\nlet [asc, desc] = [false, false];\nfor (let i = 1; i < nums.length; ++i) {\nif (nums[i - 1] < nums[i]) {\nasc = true;\n} else if (nums[i - 1] > nums[i]) {\ndesc = true;\n}\nif (asc && desc) {\nreturn false;\n}\n}\nreturn true;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nbool isMonotonic(vector<int>& nums) {\nbool asc = false, desc = false;\nfor (int i = 1; i < nums.size(); ++i) {\nif (nums[i - 1] < nums[i]) {\nasc = true;\n} else if (nums[i - 1] > nums[i]) {\ndesc = true;\n}\nif (asc && desc) {\nreturn false;\n}\n}\nreturn true;\n}\n};\n"]}, {"leetCodeID": "0905", "level": "easy", "question_description": "Given an integer array nums, move all the even integers at the beginning of the array followed by all the odd integers.\nReturn any array that satisfies this condition.", "examples": ["Example 1:\nInput: nums = [3,1,2,4]\nOutput: [2,4,3,1]\nExplanation: The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted.\n", "Example 2:\nInput: nums = [0]\nOutput: [0]\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 5000\n0 <= nums[i] <= 5000\n", "java_context": "\nclass Solution {\n    public int[] sortArrayByParity(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number[]}\n*/\nvar sortArrayByParity = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> sortArrayByParity(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int[] sortArrayByParity(int[] nums) {\nint i = 0, j = nums.length - 1;\nwhile (i < j) {\nif (nums[i] % 2 == 0) {\n++i;\n} else if (nums[j] % 2 == 1) {\n--j;\n} else {\nint t = nums[i];\nnums[i] = nums[j];\nnums[j] = t;\n++i;\n--j;\n}\n}\nreturn nums;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number[]}\n*/\nvar sortArrayByParity = function (nums) {\nfor (let i = 0, j = nums.length - 1; i < j; ) {\nif (nums[i] % 2 === 0) {\n++i;\n} else if (nums[j] % 2 === 1) {\n--j;\n} else {\n[nums[i], nums[j]] = [nums[j], nums[i]];\n++i;\n--j;\n}\n}\nreturn nums;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> sortArrayByParity(vector<int>& nums) {\nint i = 0, j = nums.size() - 1;\nwhile (i < j) {\nif (nums[i] % 2 == 0) {\n++i;\n} else if (nums[j] % 2 == 1) {\n--j;\n} else {\nswap(nums[i++], nums[j--]);\n}\n}\nreturn nums;\n}\n};\n"]}, {"leetCodeID": "0922", "level": "easy", "question_description": "Given an array of integers nums, half of the integers in nums are odd, and the other half are even.\nSort the array so that whenever nums[i] is odd, i is odd, and whenever nums[i] is even, i is even.\nReturn any answer array that satisfies this condition.", "examples": ["Example 1:\nInput: nums = [4,2,5,7]\nOutput: [4,5,2,7]\nExplanation: [4,7,2,5], [2,5,4,7], [2,7,4,5] would also have been accepted.\n", "Example 2:\nInput: nums = [2,3]\nOutput: [2,3]\n"], "constraints": "\nConstraints:\n2 <= nums.length <= 2 * 104\nnums.length is even.\nHalf of the integers in nums are even.\n0 <= nums[i] <= 1000\n", "java_context": "\nclass Solution {\n    public int[] sortArrayByParityII(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number[]}\n*/\nvar sortArrayByParityII = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> sortArrayByParityII(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int[] sortArrayByParityII(int[] nums) {\nfor (int i = 0, j = 1; i < nums.length; i += 2) {\nif (nums[i] % 2 == 1) {\nwhile (nums[j] % 2 == 1) {\nj += 2;\n}\nint t = nums[i];\nnums[i] = nums[j];\nnums[j] = t;\n}\n}\nreturn nums;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number[]}\n*/\nvar sortArrayByParityII = function (nums) {\nfor (let i = 0, j = 1; i < nums.length; i += 2) {\nif (nums[i] % 2) {\nwhile (nums[j] % 2) {\nj += 2;\n}\n[nums[i], nums[j]] = [nums[j], nums[i]];\n}\n}\nreturn nums;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> sortArrayByParityII(vector<int>& nums) {\nfor (int i = 0, j = 1; i < nums.size(); i += 2) {\nif (nums[i] % 2) {\nwhile (nums[j] % 2) {\nj += 2;\n}\nswap(nums[i], nums[j]);\n}\n}\nreturn nums;\n}\n};\n"]}, {"leetCodeID": "0929", "level": "easy", "question_description": "Every valid email consists of a local name and a domain name, separated by the &#39;@&#39; sign. Besides lowercase letters, the email may contain one or more &#39;.&#39; or &#39;+&#39;.\nFor example, in &quot;alice@leetcode.com&quot;, &quot;alice&quot; is the local name, and &quot;leetcode.com&quot; is the domain name.\nIf you add periods &#39;.&#39; between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. Note that this rule does not apply to domain names.\nFor example, &quot;alice.z@leetcode.com&quot; and &quot;alicez@leetcode.com&quot; forward to the same email address.\nIf you add a plus &#39;+&#39; in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered. Note that this rule does not apply to domain names.\nFor example, &quot;m.y+name@email.com&quot; will be forwarded to &quot;my@email.com&quot;.\nIt is possible to use both of these rules at the same time.\nGiven an array of strings emails where we send one email to each emails[i], return the number of different addresses that actually receive mails.", "examples": ["Example 1:\nInput: emails = [&quot;test.email+alex@leetcode.com&quot;,&quot;test.e.mail+bob.cathy@leetcode.com&quot;,&quot;testemail+david@lee.tcode.com&quot;]\nOutput: 2\nExplanation: &quot;testemail@leetcode.com&quot; and &quot;testemail@lee.tcode.com&quot; actually receive mails.\n", "Example 2:\nInput: emails = [&quot;a@leetcode.com&quot;,&quot;b@leetcode.com&quot;,&quot;c@leetcode.com&quot;]\nOutput: 3\n"], "constraints": "\nConstraints:\n1 <= emails.length <= 100\n1 <= emails[i].length <= 100\nemails[i] consist of lowercase English letters, &#39;+&#39;, &#39;.&#39; and &#39;@&#39;.\nEach emails[i] contains exactly one &#39;@&#39; character.\nAll local and domain names are non-empty.\nLocal names do not start with a &#39;+&#39; character.\nDomain names end with the &quot;.com&quot; suffix.\n", "java_context": "\nclass Solution {\n    public int numUniqueEmails(String[] emails) {\n        // your code\n    }\n}", "js_context": "\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int numUniqueEmails(vector<string>& emails) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int numUniqueEmails(String[] emails) {\nSet<String> s = new HashSet<>();\nfor (String email : emails) {\nString[] t = email.split(\"@\");\nString local = t[0].replace(\".\", \"\");\nString domain = t[1];\nint i = local.indexOf('+');\nif (i != -1) {\nlocal = local.substring(0, i);\n}\ns.add(local + \"@\" + domain);\n}\nreturn s.size();\n}\n}\n"], "js_solutions": ["\nconst numUniqueEmails2 = function (emails) {\nconst emailFilter = function (str) {\nlet index = str.search(/@/);\nlet s = str.substring(0, index);\nlet s2 = str.substring(index + 1, str.length);\nlet res = '';\nfor (let i = 0; i < s.length; i++) {\nif (s[i] === '+') break;\nif (s[i] === '.') continue;\nres = res + s[i];\n}\nreturn res + s2;\n};\n\nlet arr = [];\nfor (let i = 0; i < emails.length; i++) {\nlet t = emailFilter(emails[i]);\nif (arr.indexOf(t) === -1) {\narr.push(t);\n}\n}\nreturn arr.length;\n};\n\nconst numUniqueEmails = function (emails) {\nlet arr = emails.map(str => {\nlet index = str.search(/@/);\nlet s = str.substring(0, index);\nlet s2 = str.substring(index + 1, str.length);\nlet res = '';\nfor (let i = 0; i < s.length; i++) {\nif (s[i] === '+') break;\nif (s[i] === '.') continue;\nres = res + s[i];\n}\nreturn res + s2;\n});\nlet set = new Set(arr);\nreturn set.size;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint numUniqueEmails(vector<string>& emails) {\nunordered_set<string> s;\nfor (auto& email : emails) {\nint i = email.find('@');\nstring local = email.substr(0, i);\nstring domain = email.substr(i + 1);\ni = local.find('+', 0);\nif (~i) local = local.substr(0, i);\nwhile (~(i = local.find('.', 0)))\nlocal.erase(local.begin() + i);\ns.insert(local + \"@\" + domain);\n}\nreturn s.size();\n}\n};\n"]}, {"leetCodeID": "0933", "level": "easy", "question_description": "You have a RecentCounter class which counts the number of recent requests within a certain time frame.\nImplement the RecentCounter class:\nRecentCounter() Initializes the counter with zero recent requests.\nint ping(int t) Adds a new request at time t, where t represents some time in milliseconds, and returns the number of requests that has happened in the past 3000 milliseconds (including the new request). Specifically, return the number of requests that have happened in the inclusive range [t - 3000, t].\nIt is guaranteed that every call to ping uses a strictly larger value of t than the previous call.", "examples": ["Example 1:\nInput\n[&quot;RecentCounter&quot;, &quot;ping&quot;, &quot;ping&quot;, &quot;ping&quot;, &quot;ping&quot;]\n[[], [1], [100], [3001], [3002]]\nOutput\n[null, 1, 2, 3, 3]\n\nExplanation\nRecentCounter recentCounter = new RecentCounter();\nrecentCounter.ping(1);     // requests = [1], range is [-2999,1], return 1\nrecentCounter.ping(100);   // requests = [1, 100], range is [-2900,100], return 2\nrecentCounter.ping(3001);  // requests = [1, 100, 3001], range is [1,3001], return 3\nrecentCounter.ping(3002);  // requests = [1, 100, 3001, 3002], range is [2,3002], return 3\n"], "constraints": "\nConstraints:\n1 <= t <= 109\nEach test case will call ping with strictly increasing values of t.\nAt most 104 calls will be made to ping.\n", "java_context": "    \n        // your code\n    }\n}", "js_context": "\nvar RecentCounter = function () {\n    // your code\n};", "cpp_context": "    \n        // your code\n    }\n};", "java_solutions": ["\nclass RecentCounter {\nprivate int[] s = new int[10010];\nprivate int idx;\n\npublic RecentCounter() {\n}\n\npublic int ping(int t) {\ns[idx++] = t;\nreturn idx - search(t - 3000);\n}\n\nprivate int search(int x) {\nint left = 0, right = idx;\nwhile (left < right) {\nint mid = (left + right) >> 1;\nif (s[mid] >= x) {\nright = mid;\n} else {\nleft = mid + 1;\n}\n}\nreturn left;\n}\n}\n\n/**\n* Your RecentCounter object will be instantiated and called as such:\n* RecentCounter obj = new RecentCounter();\n* int param_1 = obj.ping(t);\n*/\n"], "js_solutions": ["\nvar RecentCounter = function () {\nthis.q = [];\n};\n\n/**\n* @param {number} t\n* @return {number}\n*/\nRecentCounter.prototype.ping = function (t) {\nthis.q.push(t);\nwhile (this.q[0] < t - 3000) {\nthis.q.shift();\n}\nreturn this.q.length;\n};\n\n/**\n* Your RecentCounter object will be instantiated and called as such:\n* var obj = new RecentCounter()\n* var param_1 = obj.ping(t)\n*/\n"], "cpp_solutions": ["\nclass RecentCounter {\npublic:\nqueue<int> q;\n\nRecentCounter() {\n}\n\nint ping(int t) {\nq.push(t);\nwhile (q.front() < t - 3000) q.pop();\nreturn q.size();\n}\n};\n\n/**\n* Your RecentCounter object will be instantiated and called as such:\n* RecentCounter* obj = new RecentCounter();\n* int param_1 = obj->ping(t);\n*/\n", "\nclass RecentCounter {\npublic:\nvector<int> s;\n\nRecentCounter() {\n}\n\nint ping(int t) {\ns.push_back(t);\nreturn s.size() - (lower_bound(s.begin(), s.end(), t - 3000) - s.begin());\n}\n};\n\n/**\n* Your RecentCounter object will be instantiated and called as such:\n* RecentCounter* obj = new RecentCounter();\n* int param_1 = obj->ping(t);\n*/\n"]}, {"leetCodeID": "0961", "level": "easy", "question_description": "You are given an integer array nums with the following properties:\nnums.length == 2 * n.\nnums contains n + 1 unique elements.\nExactly one element of nums is repeated n times.\nReturn the element that is repeated n times.", "examples": ["Example 1:Input: nums = [1,2,3,3]\nOutput: 3\n", "Example 2:Input: nums = [2,1,2,5,3,2]\nOutput: 2\n", "Example 3:Input: nums = [5,1,5,2,5,3,5,4]\nOutput: 5\n"], "constraints": "\nConstraints:\n2 <= n <= 5000\nnums.length == 2 * n\n0 <= nums[i] <= 104\nnums contains n + 1 unique elements and one of them is repeated exactly n times.\n", "java_context": "\nclass Solution {\n    public int repeatedNTimes(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar repeatedNTimes = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int repeatedNTimes(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int repeatedNTimes(int[] nums) {\nSet<Integer> s = new HashSet<>(nums.length / 2 + 1);\nfor (int i = 0;; ++i) {\nif (!s.add(nums[i])) {\nreturn nums[i];\n}\n}\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar repeatedNTimes = function (nums) {\nconst s = new Set();\nfor (const x of nums) {\nif (s.has(x)) {\nreturn x;\n}\ns.add(x);\n}\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint repeatedNTimes(vector<int>& nums) {\nunordered_set<int> s;\nfor (int i = 0;; ++i) {\nif (s.count(nums[i])) {\nreturn nums[i];\n}\ns.insert(nums[i]);\n}\n}\n};\n"]}, {"leetCodeID": "0977", "level": "easy", "question_description": "Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.", "examples": ["Example 1:\nInput: nums = [-4,-1,0,3,10]\nOutput: [0,1,9,16,100]\nExplanation: After squaring, the array becomes [16,1,0,9,100].\nAfter sorting, it becomes [0,1,9,16,100].\n", "Example 2:\nInput: nums = [-7,-3,2,3,11]\nOutput: [4,9,9,49,121]\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 104\n-104 <= nums[i] <= 104\nnums is sorted in non-decreasing order.\n", "java_context": "\nclass Solution {\n    public int[] sortedSquares(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number[]}\n*/\nvar sortedSquares = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> sortedSquares(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int[] sortedSquares(int[] nums) {\nint n = nums.length;\nint[] ans = new int[n];\nfor (int i = 0, j = n - 1, k = n - 1; i <= j; --k) {\nint a = nums[i] * nums[i];\nint b = nums[j] * nums[j];\nif (a > b) {\nans[k] = a;\n++i;\n} else {\nans[k] = b;\n--j;\n}\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number[]}\n*/\nvar sortedSquares = function (nums) {\nconst n = nums.length;\nconst ans = Array(n).fill(0);\nfor (let i = 0, j = n - 1, k = n - 1; i <= j; --k) {\nconst [a, b] = [nums[i] * nums[i], nums[j] * nums[j]];\nif (a > b) {\nans[k] = a;\n++i;\n} else {\nans[k] = b;\n--j;\n}\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> sortedSquares(vector<int>& nums) {\nint n = nums.size();\nvector<int> ans(n);\nfor (int i = 0, j = n - 1, k = n - 1; i <= j; --k) {\nint a = nums[i] * nums[i];\nint b = nums[j] * nums[j];\nif (a > b) {\nans[k] = a;\n++i;\n} else {\nans[k] = b;\n--j;\n}\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1025", "level": "easy", "question_description": "Alice and Bob take turns playing a game, with Alice starting first.\nInitially, there is a number n on the chalkboard. On each player&#39;s turn, that player makes a move consisting of:\nChoosing any x with 0 &lt; x &lt; n and n % x == 0.\nReplacing the number n on the chalkboard with n - x.\nAlso, if a player cannot make a move, they lose the game.\nReturn true if and only if Alice wins the game, assuming both players play optimally.", "examples": ["Example 1:\nInput: n = 2\nOutput: true\nExplanation: Alice chooses 1, and Bob has no more moves.\n", "Example 2:\nInput: n = 3\nOutput: false\nExplanation: Alice chooses 1, Bob chooses 1, and Alice has no more moves.\n"], "constraints": "\nConstraints:\n1 <= n <= 1000\n", "java_context": "\nclass Solution {\n    public boolean divisorGame(int n) {\n        // your code\n    }\n}", "js_context": "\nvar divisorGame = function (n) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    bool divisorGame(int n) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic boolean divisorGame(int n) {\nreturn n % 2 == 0;\n}\n}\n"], "js_solutions": ["\nvar divisorGame = function (n) {\nreturn n % 2 === 0;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nbool divisorGame(int n) {\nreturn n % 2 == 0;\n}\n};\n"]}, {"leetCodeID": "1046", "level": "easy", "question_description": "You are given an array of integers stones where stones[i] is the weight of the ith stone.\nWe are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights x and y with x &lt;= y. The result of this smash is:\nIf x == y, both stones are destroyed, and\nIf x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.\nAt the end of the game, there is at most one stone left.\nReturn the weight of the last remaining stone. If there are no stones left, return 0.", "examples": ["Example 1:\nInput: stones = [2,7,4,1,8,1]\nOutput: 1\nExplanation:\nWe combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then,\nwe combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then,\nwe combine 2 and 1 to get 1 so the array converts to [1,1,1] then,\nwe combine 1 and 1 to get 0 so the array converts to [1] then that&#39;s the value of the last stone.\n", "Example 2:\nInput: stones = [1]\nOutput: 1\n"], "constraints": "\nConstraints:\n1 <= stones.length <= 30\n1 <= stones[i] <= 1000\n", "java_context": "\nclass Solution {\n    public int lastStoneWeight(int[] stones) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} stones\n* @return {number}\n*/\nvar lastStoneWeight = function (stones) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int lastStoneWeight(vector<int>& stones) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int lastStoneWeight(int[] stones) {\nPriorityQueue<Integer> q = new PriorityQueue<>((a, b) -> b - a);\nfor (int x : stones) {\nq.offer(x);\n}\nwhile (q.size() > 1) {\nint y = q.poll();\nint x = q.poll();\nif (x != y) {\nq.offer(y - x);\n}\n}\nreturn q.isEmpty() ? 0 : q.poll();\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} stones\n* @return {number}\n*/\nvar lastStoneWeight = function (stones) {\nconst pq = new MaxPriorityQueue();\nfor (const x of stones) {\npq.enqueue(x);\n}\nwhile (pq.size() > 1) {\nconst y = pq.dequeue()['priority'];\nconst x = pq.dequeue()['priority'];\nif (x != y) {\npq.enqueue(y - x);\n}\n}\nreturn pq.isEmpty() ? 0 : pq.dequeue()['priority'];\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint lastStoneWeight(vector<int>& stones) {\npriority_queue<int> pq;\nfor (int x : stones) {\npq.push(x);\n}\nwhile (pq.size() > 1) {\nint y = pq.top();\npq.pop();\nint x = pq.top();\npq.pop();\nif (x != y) {\npq.push(y - x);\n}\n}\nreturn pq.empty() ? 0 : pq.top();\n}\n};\n"]}, {"leetCodeID": "1047", "level": "easy", "question_description": "You are given a string s consisting of lowercase English letters. A duplicate removal consists of choosing two adjacent and equal letters and removing them.\nWe repeatedly make duplicate removals on s until we no longer can.\nReturn the final string after all such duplicate removals have been made. It can be proven that the answer is unique.", "examples": ["Example 1:\nInput: s = &quot;abbaca&quot;\nOutput: &quot;ca&quot;\nExplanation:\nFor example, in &quot;abbaca&quot; we could remove &quot;bb&quot; since the letters are adjacent and equal, and this is the only possible move.  The result of this move is that the string is &quot;aaca&quot;, of which only &quot;aa&quot; is possible, so the final string is &quot;ca&quot;.\n", "Example 2:\nInput: s = &quot;azxxzy&quot;\nOutput: &quot;ay&quot;\n"], "constraints": "\nConstraints:\n1 <= s.length <= 105\ns consists of lowercase English letters.\n", "java_context": "\nclass Solution {\n    public String removeDuplicates(String s) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} s\n* @return {string}\n*/\nvar removeDuplicates = function (s) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic String removeDuplicates(String s) {\nStringBuilder sb = new StringBuilder();\nfor (char c : s.toCharArray()) {\nif (sb.length() > 0 && sb.charAt(sb.length() - 1) == c) {\nsb.deleteCharAt(sb.length() - 1);\n} else {\nsb.append(c);\n}\n}\nreturn sb.toString();\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} s\n* @return {string}\n*/\nvar removeDuplicates = function (s) {\nconst stk = [];\nfor (const c of s) {\nif (stk.length && stk[stk.length - 1] == c) {\nstk.pop();\n} else {\nstk.push(c);\n}\n}\nreturn stk.join('');\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nstring removeDuplicates(string s) {\nstring stk;\nfor (char c : s) {\nif (!stk.empty() && stk[stk.size() - 1] == c) {\nstk.pop_back();\n} else {\nstk += c;\n}\n}\nreturn stk;\n}\n};\n"]}, {"leetCodeID": "1133", "level": "easy", "question_description": "Given an integer array nums, return the largest integer that only occurs once. If no integer occurs once, return -1.", "examples": ["Example 1:\nInput: nums = [5,7,3,9,4,9,8,3,1]\nOutput: 8\nExplanation: The maximum integer in the array is 9 but it is repeated. The number 8 occurs only once, so it is the answer.", "Example 2:\nInput: nums = [9,9,8,8]\nOutput: -1\nExplanation: There is no number that occurs only once.\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 2000\n0 <= nums[i] <= 1000\n", "java_context": "\nclass Solution {\n    public int largestUniqueNumber(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar largestUniqueNumber = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int largestUniqueNumber(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int largestUniqueNumber(int[] nums) {\nint[] cnt = new int[1001];\nfor (int x : nums) {\n++cnt[x];\n}\nfor (int x = 1000; x >= 0; --x) {\nif (cnt[x] == 1) {\nreturn x;\n}\n}\nreturn -1;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar largestUniqueNumber = function (nums) {\nconst cnt = Array(1001).fill(0);\nfor (const x of nums) {\n++cnt[x];\n}\nfor (let x = 1000; x >= 0; --x) {\nif (cnt[x] === 1) {\nreturn x;\n}\n}\nreturn -1;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint largestUniqueNumber(vector<int>& nums) {\nint cnt[1001]{};\nfor (int& x : nums) {\n++cnt[x];\n}\nfor (int x = 1000; ~x; --x) {\nif (cnt[x] == 1) {\nreturn x;\n}\n}\nreturn -1;\n}\n};\n"]}, {"leetCodeID": "1134", "level": "easy", "question_description": "Given an integer n, return true if and only if it is an Armstrong number.\nThe k-digit number n is an Armstrong number if and only if the kth power of each digit sums to n.", "examples": ["Example 1:\nInput: n = 153\nOutput: true\nExplanation: 153 is a 3-digit number, and 153 = 13 + 53 + 33.\n", "Example 2:\nInput: n = 123\nOutput: false\nExplanation: 123 is a 3-digit number, and 123 != 13 + 23 + 33 = 36.\n"], "constraints": "\nConstraints:\n1 <= n <= 108\n", "java_context": "\nclass Solution {\n    public boolean isArmstrong(int n) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number} n\n* @return {boolean}\n*/\nvar isArmstrong = function (n) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    bool isArmstrong(int n) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic boolean isArmstrong(int n) {\nint k = (n + \"\").length();\nint s = 0;\nfor (int x = n; x > 0; x /= 10) {\ns += Math.pow(x % 10, k);\n}\nreturn s == n;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number} n\n* @return {boolean}\n*/\nvar isArmstrong = function (n) {\nconst k = String(n).length;\nlet s = 0;\nfor (let x = n; x; x = Math.floor(x / 10)) {\ns += Math.pow(x % 10, k);\n}\nreturn s == n;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nbool isArmstrong(int n) {\nint k = to_string(n).size();\nint s = 0;\nfor (int x = n; x; x /= 10) {\ns += pow(x % 10, k);\n}\nreturn s == n;\n}\n};\n"]}, {"leetCodeID": "1137", "level": "easy", "question_description": "The Tribonacci sequence Tn is defined as follows: \nT0 = 0, T1 = 1, T2 = 1, and Tn+3 = Tn + Tn+1 + Tn+2 for n &gt;= 0.\nGiven n, return the value of Tn.", "examples": ["Example 1:\n\nInput: n = 4\n\nOutput: 4\n\nExplanation:\n\nT_3 = 0 + 1 + 1 = 2\n\nT_4 = 1 + 1 + 2 = 4\n\n", "Example 2:\n\nInput: n = 25\n\nOutput: 1389537\n\n"], "constraints": "\nConstraints:\n0 <= n <= 37\nThe answer is guaranteed to fit within a 32-bit integer, ie. answer <= 2^31 - 1.\n", "java_context": "\nclass Solution {\n    public int tribonacci(int n) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number} n\n* @return {number}\n*/\nvar tribonacci = function (n) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int tribonacci(int n) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int tribonacci(int n) {\nint a = 0, b = 1, c = 1;\nwhile (n-- > 0) {\nint d = a + b + c;\na = b;\nb = c;\nc = d;\n}\nreturn a;\n}\n}\n", "\nclass Solution {\npublic int tribonacci(int n) {\nif (n == 0) {\nreturn 0;\n}\nif (n < 3) {\nreturn 1;\n}\nint[][] a = {{1, 1, 0}, {1, 0, 1}, {1, 0, 0}};\nint[][] res = pow(a, n - 3);\nint ans = 0;\nfor (int x : res[0]) {\nans += x;\n}\nreturn ans;\n}\n\nprivate int[][] mul(int[][] a, int[][] b) {\nint m = a.length, n = b[0].length;\nint[][] c = new int[m][n];\nfor (int i = 0; i < m; ++i) {\nfor (int j = 0; j < n; ++j) {\nfor (int k = 0; k < b.length; ++k) {\nc[i][j] += a[i][k] * b[k][j];\n}\n}\n}\nreturn c;\n}\n\nprivate int[][] pow(int[][] a, int n) {\nint[][] res = {{1, 1, 0}};\nwhile (n > 0) {\nif ((n & 1) == 1) {\nres = mul(res, a);\n}\na = mul(a, a);\nn >>= 1;\n}\nreturn res;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number} n\n* @return {number}\n*/\nvar tribonacci = function (n) {\nlet a = 0;\nlet b = 1;\nlet c = 1;\nwhile (n--) {\nlet d = a + b + c;\na = b;\nb = c;\nc = d;\n}\nreturn a;\n};\n", "\n/**\n* @param {number} n\n* @return {number}\n*/\nvar tribonacci = function (n) {\nif (n === 0) {\nreturn 0;\n}\nif (n < 3) {\nreturn 1;\n}\nconst a = [\n[1, 1, 0],\n[1, 0, 1],\n[1, 0, 0],\n];\nreturn pow(a, n - 3)[0].reduce((a, b) => a + b);\n};\n\nfunction mul(a, b) {\nconst [m, n] = [a.length, b[0].length];\nconst c = Array.from({ length: m }, () => Array.from({ length: n }, () => 0));\nfor (let i = 0; i < m; ++i) {\nfor (let j = 0; j < n; ++j) {\nfor (let k = 0; k < b.length; ++k) {\nc[i][j] += a[i][k] * b[k][j];\n}\n}\n}\nreturn c;\n}\n\nfunction pow(a, n) {\nlet res = [[1, 1, 0]];\nwhile (n) {\nif (n & 1) {\nres = mul(res, a);\n}\na = mul(a, a);\nn >>= 1;\n}\nreturn res;\n}\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint tribonacci(int n) {\nlong long a = 0, b = 1, c = 1;\nwhile (n--) {\nlong long d = a + b + c;\na = b;\nb = c;\nc = d;\n}\nreturn (int) a;\n}\n};\n", "\nclass Solution {\npublic:\nint tribonacci(int n) {\nif (n == 0) {\nreturn 0;\n}\nif (n < 3) {\nreturn 1;\n}\nvector<vector<ll>> a = {{1, 1, 0}, {1, 0, 1}, {1, 0, 0}};\nvector<vector<ll>> res = pow(a, n - 3);\nreturn accumulate(res[0].begin(), res[0].end(), 0);\n}\n\nprivate:\nusing ll = long long;\nvector<vector<ll>> mul(vector<vector<ll>>& a, vector<vector<ll>>& b) {\nint m = a.size(), n = b[0].size();\nvector<vector<ll>> c(m, vector<ll>(n));\nfor (int i = 0; i < m; ++i) {\nfor (int j = 0; j < n; ++j) {\nfor (int k = 0; k < b.size(); ++k) {\nc[i][j] += a[i][k] * b[k][j];\n}\n}\n}\nreturn c;\n}\n\nvector<vector<ll>> pow(vector<vector<ll>>& a, int n) {\nvector<vector<ll>> res = {{1, 1, 0}};\nwhile (n) {\nif (n & 1) {\nres = mul(res, a);\n}\na = mul(a, a);\nn >>= 1;\n}\nreturn res;\n}\n};\n"]}, {"leetCodeID": "1154", "level": "easy", "question_description": "Given a string date representing a Gregorian calendar date formatted as YYYY-MM-DD, return the day number of the year.", "examples": ["Example 1:\nInput: date = &quot;2019-01-09&quot;\nOutput: 9\nExplanation: Given date is the 9th day of the year in 2019.\n", "Example 2:\nInput: date = &quot;2019-02-10&quot;\nOutput: 41\n"], "constraints": "\nConstraints:\ndate.length == 10\ndate[4] == date[7] == &#39;-&#39;, and all other date[i]&#39;s are digits\ndate represents a calendar date between Jan 1st, 1900 and Dec 31th, 2019.\n", "java_context": "\nclass Solution {\n    public int dayOfYear(String date) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} date\n* @return {number}\n*/\nvar dayOfYear = function (date) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int dayOfYear(string date) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int dayOfYear(String date) {\nint y = Integer.parseInt(date.substring(0, 4));\nint m = Integer.parseInt(date.substring(5, 7));\nint d = Integer.parseInt(date.substring(8));\nint v = y % 400 == 0 || (y % 4 == 0 && y % 100 != 0) ? 29 : 28;\nint[] days = {31, v, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\nint ans = d;\nfor (int i = 0; i < m - 1; ++i) {\nans += days[i];\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} date\n* @return {number}\n*/\nvar dayOfYear = function (date) {\nconst y = +date.slice(0, 4);\nconst m = +date.slice(5, 7);\nconst d = +date.slice(8);\nconst v = y % 400 == 0 || (y % 4 == 0 && y % 100) ? 29 : 28;\nconst days = [31, v, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\nreturn days.slice(0, m - 1).reduce((a, b) => a + b, d);\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint dayOfYear(string date) {\nint y, m, d;\nsscanf(date.c_str(), \"%d-%d-%d\", &y, &m, &d);\nint v = y % 400 == 0 || (y % 4 == 0 && y % 100) ? 29 : 28;\nint days[] = {31, v, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\nint ans = d;\nfor (int i = 0; i < m - 1; ++i) {\nans += days[i];\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1184", "level": "easy", "question_description": "A bus has n stops numbered from 0 to n - 1 that form a circle. We know the distance between all pairs of neighboring stops where distance[i] is the distance between the stops number i and (i + 1) % n.\nThe bus goes along both directions i.e. clockwise and counterclockwise.\nReturn the shortest distance between the given start and destination stops.", "examples": [], "constraints": "\nExample 2:\nInput: distance = [1,2,3,4], start = 0, destination = 2\nOutput: 3\nExplanation: Distance between 0 and 2 is 3 or 7, minimum is 3.\n", "java_context": "\nclass Solution {\n    public int distanceBetweenBusStops(int[] distance, int start, int destination) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} distance\n* @param {number} start\n* @param {number} destination\n* @return {number}\n*/\nvar distanceBetweenBusStops = function (distance, start, destination) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int distanceBetweenBusStops(vector<int>& distance, int start, int destination) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int distanceBetweenBusStops(int[] distance, int start, int destination) {\nint s = Arrays.stream(distance).sum();\nint n = distance.length;\nint a = 0;\nwhile (start != destination) {\na += distance[start];\nstart = (start + 1) % n;\n}\nreturn Math.min(a, s - a);\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} distance\n* @param {number} start\n* @param {number} destination\n* @return {number}\n*/\nvar distanceBetweenBusStops = function (distance, start, destination) {\nconst s = distance.reduce((a, b) => a + b, 0);\nlet a = 0;\nconst n = distance.length;\nwhile (start != destination) {\na += distance[start];\nstart = (start + 1) % n;\n}\nreturn Math.min(a, s - a);\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint distanceBetweenBusStops(vector<int>& distance, int start, int destination) {\nint s = accumulate(distance.begin(), distance.end(), 0);\nint a = 0, n = distance.size();\nwhile (start != destination) {\na += distance[start];\nstart = (start + 1) % n;\n}\nreturn min(a, s - a);\n}\n};\n"]}, {"leetCodeID": "1217", "level": "easy", "question_description": "We have n chips, where the position of the ith chip is position[i].\nWe need to move all the chips to the same position. In one step, we can change the position of the ith chip from position[i] to:\nposition[i] + 2 or position[i] - 2 with cost = 0.\nposition[i] + 1 or position[i] - 1 with cost = 1.\nReturn the minimum cost needed to move all the chips to the same position.", "examples": ["Example 1:\n\n\nInput: position = [1,2,3]\nOutput: 1\nExplanation: First step: Move the chip at position 3 to position 1 with cost = 0.\nSecond step: Move the chip at position 2 to position 1 with cost = 1.\nTotal cost is 1.\n\n\nExample 2:\n\n\nInput: position = [2,2,2,3,3]\nOutput: 2\nExplanation: We can move the two chips at position  3 to position 2. Each move has cost = 1. The total cost = 2.\n\n\nExample 3:\nInput: position = [1,1000000000]\nOutput: 1\n"], "constraints": "\nConstraints:\n1 <= position.length <= 100\n1 <= position[i] <= 10^9\n", "java_context": "\nclass Solution {\n    public int minCostToMoveChips(int[] position) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} position\n* @return {number}\n*/\nvar minCostToMoveChips = function (position) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int minCostToMoveChips(vector<int>& position) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int minCostToMoveChips(int[] position) {\nint a = 0;\nfor (int p : position) {\na += p % 2;\n}\nint b = position.length - a;\nreturn Math.min(a, b);\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} position\n* @return {number}\n*/\nvar minCostToMoveChips = function (position) {\nlet a = 0;\nfor (let v of position) {\na += v % 2;\n}\nlet b = position.length - a;\nreturn Math.min(a, b);\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint minCostToMoveChips(vector<int>& position) {\nint a = 0;\nfor (auto& p : position) a += p & 1;\nint b = position.size() - a;\nreturn min(a, b);\n}\n};\n"]}, {"leetCodeID": "1221", "level": "easy", "question_description": "Balanced strings are those that have an equal quantity of &#39;L&#39; and &#39;R&#39; characters.\nGiven a balanced string s, split it into some number of substrings such that:\nEach substring is balanced.\nReturn the maximum number of balanced strings you can obtain.", "examples": ["Example 1:\nInput: s = &quot;RLRRLLRLRL&quot;\nOutput: 4\nExplanation: s can be split into &quot;RL&quot;, &quot;RRLL&quot;, &quot;RL&quot;, &quot;RL&quot;, each substring contains same number of &#39;L&#39; and &#39;R&#39;.\n", "Example 2:\nInput: s = &quot;RLRRRLLRLL&quot;\nOutput: 2\nExplanation: s can be split into &quot;RL&quot;, &quot;RRRLLRLL&quot;, each substring contains same number of &#39;L&#39; and &#39;R&#39;.\nNote that s cannot be split into &quot;RL&quot;, &quot;RR&quot;, &quot;RL&quot;, &quot;LR&quot;, &quot;LL&quot;, because the 2nd and 5th substrings are not balanced.", "Example 3:\nInput: s = &quot;LLLLRRRR&quot;\nOutput: 1\nExplanation: s can be split into &quot;LLLLRRRR&quot;.\n"], "constraints": "\nConstraints:\n2 <= s.length <= 1000\ns[i] is either &#39;L&#39; or &#39;R&#39;.\ns is a balanced string.\n", "java_context": "\nclass Solution {\n    public int balancedStringSplit(String s) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} s\n* @return {number}\n*/\nvar balancedStringSplit = function (s) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int balancedStringSplit(string s) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int balancedStringSplit(String s) {\nint ans = 0, l = 0;\nfor (char c : s.toCharArray()) {\nif (c == 'L') {\n++l;\n} else {\n--l;\n}\nif (l == 0) {\n++ans;\n}\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} s\n* @return {number}\n*/\nvar balancedStringSplit = function (s) {\nlet ans = 0;\nlet l = 0;\nfor (let c of s) {\nif (c == 'L') {\n++l;\n} else {\n--l;\n}\nif (l == 0) {\n++ans;\n}\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint balancedStringSplit(string s) {\nint ans = 0, l = 0;\nfor (char c : s) {\nif (c == 'L')\n++l;\nelse\n--l;\nif (l == 0) ++ans;\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1287", "level": "easy", "question_description": "Given an integer array sorted in non-decreasing order, there is exactly one integer in the array that occurs more than 25% of the time, return that integer.", "examples": ["Example 1:\nInput: arr = [1,2,2,6,6,6,6,7,10]\nOutput: 6\n", "Example 2:\nInput: arr = [1,1]\nOutput: 1\n"], "constraints": "\nConstraints:\n1 <= arr.length <= 104\n0 <= arr[i] <= 105\n", "java_context": "\nclass Solution {\n    public int findSpecialInteger(int[] arr) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} arr\n* @return {number}\n*/\nvar findSpecialInteger = function (arr) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int findSpecialInteger(vector<int>& arr) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int findSpecialInteger(int[] arr) {\nint n = arr.length;\nfor (int i = 0; i < n; ++i) {\nif (arr[i] == arr[i + (n >> 2)]) {\nreturn arr[i];\n}\n}\nreturn 0;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} arr\n* @return {number}\n*/\nvar findSpecialInteger = function (arr) {\nconst n = arr.length;\nfor (let i = 0; i < n; ++i) {\nif (arr[i] == arr[i + (n >> 2)]) {\nreturn arr[i];\n}\n}\nreturn 0;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint findSpecialInteger(vector<int>& arr) {\nint n = arr.size();\nfor (int i = 0; i < n; ++i)\nif (arr[i] == arr[i + (n >> 2)]) return arr[i];\nreturn 0;\n}\n};\n"]}, {"leetCodeID": "1290", "level": "easy", "question_description": "Given head which is a reference node to a singly-linked list. The value of each node in the linked list is either 0 or 1. The linked list holds the binary representation of a number.\nReturn the decimal value of the number in the linked list.\nThe most significant bit is at the head of the linked list.", "examples": ["Example 1:\n\n\nInput: head = [1,0,1]\nOutput: 5\nExplanation: (101) in base 2 = (5) in base 10\n\n\nExample 2:\nInput: head = [0]\nOutput: 0\n"], "constraints": "\nConstraints:\nThe Linked List is not empty.\nNumber of nodes will not exceed 30.\nEach node&#39;s value is either 0 or 1.\n", "java_context": "\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode() {}\n*     ListNode(int val) { this.val = val; }\n*     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n* }\n*/\nclass Solution {\n    public int getDecimalValue(ListNode head) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for singly-linked list.\n* function ListNode(val, next) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.next = (next===undefined ? null : next)\n* }\n*/\n/**\n* @param {ListNode} head\n* @return {number}\n*/\nvar getDecimalValue = function (head) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\nclass Solution {\npublic:\n    int getDecimalValue(ListNode* head) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode() {}\n*     ListNode(int val) { this.val = val; }\n*     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n* }\n*/\nclass Solution {\npublic int getDecimalValue(ListNode head) {\nint ans = 0;\nfor (; head != null; head = head.next) {\nans = ans << 1 | head.val;\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for singly-linked list.\n* function ListNode(val, next) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.next = (next===undefined ? null : next)\n* }\n*/\n/**\n* @param {ListNode} head\n* @return {number}\n*/\nvar getDecimalValue = function (head) {\nlet ans = 0;\nfor (; head; head = head.next) {\nans = (ans << 1) | head.val;\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\nclass Solution {\npublic:\nint getDecimalValue(ListNode* head) {\nint ans = 0;\nfor (; head; head = head->next) {\nans = ans << 1 | head->val;\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1295", "level": "easy", "question_description": "Given an array nums of integers, return how many of them contain an even number of digits.", "examples": ["Example 1:\nInput: nums = [12,345,2,6,7896]\nOutput: 2\nExplanation:\n12 contains 2 digits (even number of digits).&nbsp;\n345 contains 3 digits (odd number of digits).&nbsp;\n2 contains 1 digit (odd number of digits).&nbsp;\n6 contains 1 digit (odd number of digits).&nbsp;\n7896 contains 4 digits (even number of digits).&nbsp;\nTherefore only 12 and 7896 contain an even number of digits.\n", "Example 2:\nInput: nums = [555,901,482,1771]\nOutput: 1\nExplanation: \nOnly 1771 contains an even number of digits.\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 500\n1 <= nums[i] <= 105\n", "java_context": "\nclass Solution {\n    public int findNumbers(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar findNumbers = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int findNumbers(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int findNumbers(int[] nums) {\nint ans = 0;\nfor (int v : nums) {\nif (String.valueOf(v).length() % 2 == 0) {\n++ans;\n}\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar findNumbers = function (nums) {\nlet ans = 0;\nfor (const v of nums) {\nans += String(v).length % 2 == 0;\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint findNumbers(vector<int>& nums) {\nint ans = 0;\nfor (int& v : nums) {\nans += to_string(v).size() % 2 == 0;\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1351", "level": "easy", "question_description": "Given a m x n matrix grid which is sorted in non-increasing order both row-wise and column-wise, return the number of negative numbers in grid.", "examples": ["Example 1:\nInput: grid = [[4,3,2,-1],[3,2,1,-1],[1,1,-1,-2],[-1,-1,-2,-3]]\nOutput: 8\nExplanation: There are 8 negatives number in the matrix.\n", "Example 2:\nInput: grid = [[3,2],[1,0]]\nOutput: 0\n"], "constraints": "\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 100\n-100 <= grid[i][j] <= 100\n", "java_context": "\nclass Solution {\n    public int countNegatives(int[][] grid) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[][]} grid\n* @return {number}\n*/\nvar countNegatives = function (grid) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int countNegatives(vector<vector<int>>& grid) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int countNegatives(int[][] grid) {\nint m = grid.length, n = grid[0].length;\nint ans = 0;\nfor (int i = m - 1, j = 0; i >= 0 && j < n;) {\nif (grid[i][j] < 0) {\nans += n - j;\n--i;\n} else {\n++j;\n}\n}\nreturn ans;\n}\n}\n", "\nclass Solution {\npublic int countNegatives(int[][] grid) {\nint ans = 0;\nint n = grid[0].length;\nfor (int[] row : grid) {\nint left = 0, right = n;\nwhile (left < right) {\nint mid = (left + right) >> 1;\nif (row[mid] < 0) {\nright = mid;\n} else {\nleft = mid + 1;\n}\n}\nans += n - left;\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[][]} grid\n* @return {number}\n*/\nvar countNegatives = function (grid) {\nconst m = grid.length,\nn = grid[0].length;\nlet ans = 0;\nfor (let i = m - 1, j = 0; i >= 0 && j < n; ) {\nif (grid[i][j] < 0) {\nans += n - j;\n--i;\n} else {\n++j;\n}\n}\nreturn ans;\n};\n", "\n/**\n* @param {number[][]} grid\n* @return {number}\n*/\nvar countNegatives = function (grid) {\nconst n = grid[0].length;\nlet ans = 0;\nfor (let row of grid) {\nlet left = 0,\nright = n;\nwhile (left < right) {\nconst mid = (left + right) >> 1;\nif (row[mid] < 0) {\nright = mid;\n} else {\nleft = mid + 1;\n}\n}\nans += n - left;\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint countNegatives(vector<vector<int>>& grid) {\nint m = grid.size(), n = grid[0].size();\nint ans = 0;\nfor (int i = m - 1, j = 0; i >= 0 && j < n;) {\nif (grid[i][j] < 0) {\nans += n - j;\n--i;\n} else\n++j;\n}\nreturn ans;\n}\n};\n", "\nclass Solution {\npublic:\nint countNegatives(vector<vector<int>>& grid) {\nint ans = 0;\nfor (auto& row : grid) {\nans += lower_bound(row.rbegin(), row.rend(), 0) - row.rbegin();\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1370", "level": "easy", "question_description": "You are given a string s. Reorder the string using the following algorithm:\nPick the smallest character from s and append it to the result.\nPick the smallest character from s which is greater than the last appended character to the result and append it.\nRepeat step 2 until you cannot pick more characters.\nPick the largest character from s and append it to the result.\nPick the largest character from s which is smaller than the last appended character to the result and append it.\nRepeat step 5 until you cannot pick more characters.\nRepeat the steps from 1 to 6 until you pick all characters from s.\nIn each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.\nReturn the result string after sorting s with this algorithm.", "examples": ["Example 1:\nInput: s = &quot;aaaabbbbcccc&quot;\nOutput: &quot;abccbaabccba&quot;\nExplanation: After steps 1, 2 and 3 of the first iteration, result = &quot;abc&quot;\nAfter steps 4, 5 and 6 of the first iteration, result = &quot;abccba&quot;\nFirst iteration is done. Now s = &quot;aabbcc&quot; and we go back to step 1\nAfter steps 1, 2 and 3 of the second iteration, result = &quot;abccbaabc&quot;\nAfter steps 4, 5 and 6 of the second iteration, result = &quot;abccbaabccba&quot;\n", "Example 2:\nInput: s = &quot;rat&quot;\nOutput: &quot;art&quot;\nExplanation: The word &quot;rat&quot; becomes &quot;art&quot; after re-ordering it with the mentioned algorithm.\n"], "constraints": "\nConstraints:\n1 <= s.length <= 500\ns consists of only lowercase English letters.\n", "java_context": "\nclass Solution {\n    public String sortString(String s) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} s\n* @return {string}\n*/\nvar sortString = function (s) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    string sortString(string s) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic String sortString(String s) {\nint[] cnt = new int[26];\nint n = s.length();\nfor (int i = 0; i < n; ++i) {\ncnt[s.charAt(i) - 'a']++;\n}\nStringBuilder sb = new StringBuilder();\nwhile (sb.length() < n) {\nfor (int i = 0; i < 26; ++i) {\nif (cnt[i] > 0) {\nsb.append((char) ('a' + i));\n--cnt[i];\n}\n}\nfor (int i = 25; i >= 0; --i) {\nif (cnt[i] > 0) {\nsb.append((char) ('a' + i));\n--cnt[i];\n}\n}\n}\nreturn sb.toString();\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} s\n* @return {string}\n*/\nvar sortString = function (s) {\nconst cnt = Array(26).fill(0);\nfor (const c of s) {\n++cnt[c.charCodeAt(0) - 'a'.charCodeAt(0)];\n}\nconst ans = [];\nwhile (ans.length < s.length) {\nfor (let i = 0; i < 26; ++i) {\nif (cnt[i]) {\nans.push(String.fromCharCode(i + 'a'.charCodeAt(0)));\n--cnt[i];\n}\n}\nfor (let i = 25; i >= 0; --i) {\nif (cnt[i]) {\nans.push(String.fromCharCode(i + 'a'.charCodeAt(0)));\n--cnt[i];\n}\n}\n}\nreturn ans.join('');\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nstring sortString(string s) {\nint cnt[26]{};\nfor (char& c : s) {\n++cnt[c - 'a'];\n}\nstring ans;\nwhile (ans.size() < s.size()) {\nfor (int i = 0; i < 26; ++i) {\nif (cnt[i]) {\nans += i + 'a';\n--cnt[i];\n}\n}\nfor (int i = 25; i >= 0; --i) {\nif (cnt[i]) {\nans += i + 'a';\n--cnt[i];\n}\n}\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1426", "level": "easy", "question_description": "Given an integer array arr, count how many elements x there are, such that x + 1 is also in arr. If there are duplicates in arr, count them separately.", "examples": ["Example 1:\nInput: arr = [1,2,3]\nOutput: 2\nExplanation: 1 and 2 are counted cause 2 and 3 are in arr.\n", "Example 2:\nInput: arr = [1,1,3,3,5,5,7,7]\nOutput: 0\nExplanation: No numbers are counted, cause there is no 2, 4, 6, or 8 in arr.\n"], "constraints": "\nConstraints:\n1 <= arr.length <= 1000\n0 <= arr[i] <= 1000\n", "java_context": "\nclass Solution {\n    public int countElements(int[] arr) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} arr\n* @return {number}\n*/\nvar countElements = function (arr) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int countElements(vector<int>& arr) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int countElements(int[] arr) {\nint[] cnt = new int[1001];\nfor (int x : arr) {\n++cnt[x];\n}\nint ans = 0;\nfor (int x = 0; x < 1000; ++x) {\nif (cnt[x + 1] > 0) {\nans += cnt[x];\n}\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} arr\n* @return {number}\n*/\nvar countElements = function (arr) {\nconst mx = Math.max(...arr);\nconst cnt = Array(mx + 1).fill(0);\nfor (const x of arr) {\n++cnt[x];\n}\nlet ans = 0;\nfor (let i = 0; i < mx; ++i) {\nif (cnt[i + 1] > 0) {\nans += cnt[i];\n}\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint countElements(vector<int>& arr) {\nint cnt[1001]{};\nfor (int x : arr) {\n++cnt[x];\n}\nint ans = 0;\nfor (int x = 0; x < 1000; ++x) {\nif (cnt[x + 1]) {\nans += cnt[x];\n}\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1436", "level": "easy", "question_description": "You are given the array paths, where paths[i] = [cityAi, cityBi] means there exists a direct path going from cityAi to cityBi. Return the destination city, that is, the city without any path outgoing to another city.\nIt is guaranteed that the graph of paths forms a line without any loop, therefore, there will be exactly one destination city.", "examples": ["Example 1:\nInput: paths = [[&quot;London&quot;,&quot;New York&quot;],[&quot;New York&quot;,&quot;Lima&quot;],[&quot;Lima&quot;,&quot;Sao Paulo&quot;]]\nOutput: &quot;Sao Paulo&quot;\nExplanation: Starting at &quot;London&quot; city you will reach &quot;Sao Paulo&quot; city which is the destination city. Your trip consist of: &quot;London&quot; -&gt; &quot;New York&quot; -&gt; &quot;Lima&quot; -&gt; &quot;Sao Paulo&quot;.\n", "Example 2:\nInput: paths = [[&quot;B&quot;,&quot;C&quot;],[&quot;D&quot;,&quot;B&quot;],[&quot;C&quot;,&quot;A&quot;]]\nOutput: &quot;A&quot;\nExplanation: All possible trips are:&nbsp;\n&quot;D&quot; -&gt; &quot;B&quot; -&gt; &quot;C&quot; -&gt; &quot;A&quot;.&nbsp;\n&quot;B&quot; -&gt; &quot;C&quot; -&gt; &quot;A&quot;.&nbsp;\n&quot;C&quot; -&gt; &quot;A&quot;.&nbsp;\n&quot;A&quot;.&nbsp;\nClearly the destination city is &quot;A&quot;.\n", "Example 3:\nInput: paths = [[&quot;A&quot;,&quot;Z&quot;]]\nOutput: &quot;Z&quot;\n"], "constraints": "\nConstraints:\n1 <= paths.length <= 100\npaths[i].length == 2\n1 <= cityAi.length, cityBi.length <= 10\ncityAi != cityBi\nAll strings consist of lowercase and uppercase English letters and the space character.\n", "java_context": "\nclass Solution {\n    public String destCity(List<List<String>> paths) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string[][]} paths\n* @return {string}\n*/\nvar destCity = function (paths) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    string destCity(vector<vector<string>>& paths) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic String destCity(List<List<String>> paths) {\nSet<String> s = new HashSet<>();\nfor (var p : paths) {\ns.add(p.get(0));\n}\nfor (var p : paths) {\nif (!s.contains(p.get(1))) {\nreturn p.get(1);\n}\n}\nreturn \"\";\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string[][]} paths\n* @return {string}\n*/\nvar destCity = function (paths) {\nconst s = new Set();\nfor (const [a, _] of paths) {\ns.add(a);\n}\nfor (const [_, b] of paths) {\nif (!s.has(b)) {\nreturn b;\n}\n}\nreturn '';\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nstring destCity(vector<vector<string>>& paths) {\nunordered_set<string> s;\nfor (auto& p : paths) {\ns.insert(p[0]);\n}\nfor (auto& p : paths) {\nif (!s.count(p[1])) {\nreturn p[1];\n}\n}\nreturn \"\";\n}\n};\n"]}, {"leetCodeID": "1475", "level": "easy", "question_description": "You are given an integer array prices where prices[i] is the price of the ith item in a shop.\nThere is a special discount for items in the shop. If you buy the ith item, then you will receive a discount equivalent to prices[j] where j is the minimum index such that j &gt; i and prices[j] &lt;= prices[i]. Otherwise, you will not receive any discount at all.\nReturn an integer array answer where answer[i] is the final price you will pay for the ith item of the shop, considering the special discount.", "examples": ["Example 1:\nInput: prices = [8,4,6,2,3]\nOutput: [4,2,4,2,3]\nExplanation:\nFor item 0 with price[0]=8 you will receive a discount equivalent to prices[1]=4, therefore, the final price you will pay is 8 - 4 = 4.\nFor item 1 with price[1]=4 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 4 - 2 = 2.\nFor item 2 with price[2]=6 you will receive a discount equivalent to prices[3]=2, therefore, the final price you will pay is 6 - 2 = 4.\nFor items 3 and 4 you will not receive any discount at all.\n", "Example 2:\nInput: prices = [1,2,3,4,5]\nOutput: [1,2,3,4,5]\nExplanation: In this case, for all items, you will not receive any discount at all.\n", "Example 3:\nInput: prices = [10,1,1,6]\nOutput: [9,0,1,6]\n"], "constraints": "\nConstraints:\n1 <= prices.length <= 500\n1 <= prices[i] <= 1000\n", "java_context": "\nclass Solution {\n    public int[] finalPrices(int[] prices) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} prices\n* @return {number[]}\n*/\nvar finalPrices = function (prices) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> finalPrices(vector<int>& prices) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int[] finalPrices(int[] prices) {\nint n = prices.length;\nint[] ans = new int[n];\nfor (int i = 0; i < n; ++i) {\nans[i] = prices[i];\nfor (int j = i + 1; j < n; ++j) {\nif (prices[j] <= prices[i]) {\nans[i] -= prices[j];\nbreak;\n}\n}\n}\nreturn ans;\n}\n}\n", "\nclass Solution {\npublic int[] finalPrices(int[] prices) {\nDeque<Integer> stk = new ArrayDeque<>();\nint n = prices.length;\nint[] ans = new int[n];\nfor (int i = 0; i < n; ++i) {\nans[i] = prices[i];\nwhile (!stk.isEmpty() && prices[stk.peek()] >= prices[i]) {\nans[stk.pop()] -= prices[i];\n}\nstk.push(i);\n}\nreturn ans;\n}\n}\n", "\nclass Solution {\npublic int[] finalPrices(int[] prices) {\nDeque<Integer> stk = new ArrayDeque<>();\nint n = prices.length;\nint[] ans = new int[n];\nfor (int i = n - 1; i >= 0; --i) {\nans[i] = prices[i];\nwhile (!stk.isEmpty() && prices[stk.peek()] > prices[i]) {\nstk.pop();\n}\nif (!stk.isEmpty()) {\nans[i] -= prices[stk.peek()];\n}\nstk.push(i);\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} prices\n* @return {number[]}\n*/\nvar finalPrices = function (prices) {\nfor (let i = 0; i < prices.length; i++) {\nfor (let j = i + 1; j < prices.length; j++) {\nif (prices[i] >= prices[j]) {\nprices[i] -= prices[j];\nbreak;\n}\n}\n}\nreturn prices;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> finalPrices(vector<int>& prices) {\nint n = prices.size();\nvector<int> ans(n);\nfor (int i = 0; i < n; ++i) {\nans[i] = prices[i];\nfor (int j = i + 1; j < n; ++j) {\nif (prices[j] <= prices[i]) {\nans[i] -= prices[j];\nbreak;\n}\n}\n}\nreturn ans;\n}\n};\n", "\nclass Solution {\npublic:\nvector<int> finalPrices(vector<int>& prices) {\nstack<int> stk;\nvector<int> ans = prices;\nfor (int i = 0; i < prices.size(); ++i) {\nwhile (!stk.empty() && prices[stk.top()] >= prices[i]) {\nans[stk.top()] -= prices[i];\nstk.pop();\n}\nstk.push(i);\n}\nreturn ans;\n}\n};\n", "\nclass Solution {\npublic:\nvector<int> finalPrices(vector<int>& prices) {\nstack<int> stk;\nint n = prices.size();\nvector<int> ans(n);\nfor (int i = n - 1; i >= 0; --i) {\nans[i] = prices[i];\nwhile (!stk.empty() && prices[stk.top()] > prices[i]) {\nstk.pop();\n}\nif (!stk.empty()) {\nans[i] -= prices[stk.top()];\n}\nstk.push(i);\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1502", "level": "easy", "question_description": "A sequence of numbers is called an arithmetic progression if the difference between any two consecutive elements is the same.\nGiven an array of numbers arr, return true if the array can be rearranged to form an arithmetic progression. Otherwise, return false.", "examples": ["Example 1:\nInput: arr = [3,5,1]\nOutput: true\nExplanation: We can reorder the elements as [1,3,5] or [5,3,1] with differences 2 and -2 respectively, between each consecutive elements.\n", "Example 2:\nInput: arr = [1,2,4]\nOutput: false\nExplanation: There is no way to reorder the elements to obtain an arithmetic progression.\n"], "constraints": "\nConstraints:\n2 <= arr.length <= 1000\n-106 <= arr[i] <= 106\n", "java_context": "\nclass Solution {\n    public boolean canMakeArithmeticProgression(int[] arr) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} arr\n* @return {boolean}\n*/\nvar canMakeArithmeticProgression = function (arr) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    bool canMakeArithmeticProgression(vector<int>& arr) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic boolean canMakeArithmeticProgression(int[] arr) {\nArrays.sort(arr);\nint d = arr[1] - arr[0];\nfor (int i = 2; i < arr.length; ++i) {\nif (arr[i] - arr[i - 1] != d) {\nreturn false;\n}\n}\nreturn true;\n}\n}\n", "\nclass Solution {\npublic boolean canMakeArithmeticProgression(int[] arr) {\nint n = arr.length;\nint a = arr[0], b = arr[0];\nSet<Integer> s = new HashSet<>();\nfor (int x : arr) {\na = Math.min(a, x);\nb = Math.max(b, x);\ns.add(x);\n}\nif ((b - a) % (n - 1) != 0) {\nreturn false;\n}\nint d = (b - a) / (n - 1);\nfor (int i = 0; i < n; ++i) {\nif (!s.contains(a + d * i)) {\nreturn false;\n}\n}\nreturn true;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} arr\n* @return {boolean}\n*/\nvar canMakeArithmeticProgression = function (arr) {\narr.sort((a, b) => a - b);\nfor (let i = 1; i < arr.length - 1; i++) {\nif (arr[i] << 1 != arr[i - 1] + arr[i + 1]) {\nreturn false;\n}\n}\nreturn true;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nbool canMakeArithmeticProgression(vector<int>& arr) {\nsort(arr.begin(), arr.end());\nint d = arr[1] - arr[0];\nfor (int i = 2; i < arr.size(); i++) {\nif (arr[i] - arr[i - 1] != d) {\nreturn false;\n}\n}\nreturn true;\n}\n};\n", "\nclass Solution {\npublic:\nbool canMakeArithmeticProgression(vector<int>& arr) {\nauto [a, b] = minmax_element(arr.begin(), arr.end());\nint n = arr.size();\nif ((*b - *a) % (n - 1) != 0) {\nreturn false;\n}\nint d = (*b - *a) / (n - 1);\nunordered_set<int> s(arr.begin(), arr.end());\nfor (int i = 0; i < n; ++i) {\nif (!s.count(*a + d * i)) {\nreturn false;\n}\n}\nreturn true;\n}\n};\n"]}, {"leetCodeID": "1518", "level": "easy", "question_description": "There are numBottles water bottles that are initially full of water. You can exchange numExchange empty water bottles from the market with one full water bottle.\nThe operation of drinking a full water bottle turns it into an empty bottle.\nGiven the two integers numBottles and numExchange, return the maximum number of water bottles you can drink.", "examples": [], "constraints": "\nConstraints:\n1 <= numBottles <= 100\n2 <= numExchange <= 100\n", "java_context": "\nclass Solution {\n    public int numWaterBottles(int numBottles, int numExchange) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number} numBottles\n* @param {number} numExchange\n* @return {number}\n*/\nvar numWaterBottles = function (numBottles, numExchange) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int numWaterBottles(int numBottles, int numExchange) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int numWaterBottles(int numBottles, int numExchange) {\nint ans = numBottles;\nfor (; numBottles >= numExchange; ++ans) {\nnumBottles -= (numExchange - 1);\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number} numBottles\n* @param {number} numExchange\n* @return {number}\n*/\nvar numWaterBottles = function (numBottles, numExchange) {\nlet ans = numBottles;\nfor (; numBottles >= numExchange; ++ans) {\nnumBottles -= numExchange - 1;\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint numWaterBottles(int numBottles, int numExchange) {\nint ans = numBottles;\nfor (; numBottles >= numExchange; ++ans) {\nnumBottles -= (numExchange - 1);\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1528", "level": "easy", "question_description": "You are given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string.\nReturn the shuffled string.", "examples": ["Example 1:\n\n\nInput: s = &quot;codeleet&quot;, indices = [4,5,6,7,0,2,1,3]\nOutput: &quot;leetcode&quot;\nExplanation: As shown, &quot;codeleet&quot; becomes &quot;leetcode&quot; after shuffling.\n\n\nExample 2:\nInput: s = &quot;abc&quot;, indices = [0,1,2]\nOutput: &quot;abc&quot;\nExplanation: After shuffling, each character remains in its position.\n"], "constraints": "\nConstraints:\ns.length == indices.length == n\n1 <= n <= 100\ns consists of only lowercase English letters.\n0 <= indices[i] < n\nAll values of indices are unique.\n", "java_context": "\nclass Solution {\n    public String restoreString(String s, int[] indices) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} s\n* @param {number[]} indices\n* @return {string}\n*/\nvar restoreString = function (s, indices) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    string restoreString(string s, vector<int>& indices) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic String restoreString(String s, int[] indices) {\nint n = s.length();\nchar[] ans = new char[n];\nfor (int i = 0; i < n; ++i) {\nans[indices[i]] = s.charAt(i);\n}\nreturn String.valueOf(ans);\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} s\n* @param {number[]} indices\n* @return {string}\n*/\nvar restoreString = function (s, indices) {\nlet rs = [];\nfor (let i = 0; i < s.length; i++) {\nrs[indices[i]] = s[i];\n}\nreturn rs.join('');\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nstring restoreString(string s, vector<int>& indices) {\nint n = s.size();\nstring ans(n, 0);\nfor (int i = 0; i < n; ++i) {\nans[indices[i]] = s[i];\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1614", "level": "easy", "question_description": "Given a valid parentheses string s, return the nesting depth of s. The nesting depth is the maximum number of nested parentheses.", "examples": [], "constraints": "\nConstraints:\n1 <= s.length <= 100\ns consists of digits 0-9 and characters &#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;, &#39;(&#39;, and &#39;)&#39;.\nIt is guaranteed that parentheses expression s is a VPS.\n", "java_context": "\nclass Solution {\n    public int maxDepth(String s) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} s\n* @return {number}\n*/\nvar maxDepth = function (s) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int maxDepth(string s) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int maxDepth(String s) {\nint ans = 0, d = 0;\nfor (int i = 0; i < s.length(); ++i) {\nchar c = s.charAt(i);\nif (c == '(') {\nans = Math.max(ans, ++d);\n} else if (c == ')') {\n--d;\n}\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} s\n* @return {number}\n*/\nvar maxDepth = function (s) {\nlet ans = 0;\nlet d = 0;\nfor (const c of s) {\nif (c === '(') {\nans = Math.max(ans, ++d);\n} else if (c === ')') {\n--d;\n}\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint maxDepth(string s) {\nint ans = 0, d = 0;\nfor (char& c : s) {\nif (c == '(') {\nans = max(ans, ++d);\n} else if (c == ')') {\n--d;\n}\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1636", "level": "easy", "question_description": "Given an array of integers nums, sort the array in increasing order based on the frequency of the values. If multiple values have the same frequency, sort them in decreasing order.\nReturn the sorted array.", "examples": ["Example 1:\nInput: nums = [1,1,2,2,2,3]\nOutput: [3,1,1,2,2,2]\nExplanation: &#39;3&#39; has a frequency of 1, &#39;1&#39; has a frequency of 2, and &#39;2&#39; has a frequency of 3.\n", "Example 2:\nInput: nums = [2,3,1,3,2]\nOutput: [1,3,3,2,2]\nExplanation: &#39;2&#39; and &#39;3&#39; both have a frequency of 2, so they are sorted in decreasing order.\n", "Example 3:\nInput: nums = [-1,1,-6,4,5,-6,1,4,1]\nOutput: [5,-1,4,4,-6,-6,1,1,1]"], "constraints": "\nConstraints:\n1 <= nums.length <= 100\n-100 <= nums[i] <= 100\n", "java_context": "\nclass Solution {\n    public int[] frequencySort(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number[]}\n*/\nvar frequencySort = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> frequencySort(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int[] frequencySort(int[] nums) {\nint[] cnt = new int[201];\nList<Integer> t = new ArrayList<>();\nfor (int v : nums) {\nv += 100;\n++cnt[v];\nt.add(v);\n}\nt.sort((a, b) -> cnt[a] == cnt[b] ? b - a : cnt[a] - cnt[b]);\nint[] ans = new int[nums.length];\nint i = 0;\nfor (int v : t) {\nans[i++] = v - 100;\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number[]}\n*/\nvar frequencySort = function (nums) {\nconst m = new Map();\nfor (let i = 0; i < nums.length; i++) {\nm.set(nums[i], (m.get(nums[i]) || 0) + 1);\n}\nnums.sort((a, b) => (m.get(a) != m.get(b) ? m.get(a) - m.get(b) : b - a));\nreturn nums;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> frequencySort(vector<int>& nums) {\nvector<int> cnt(201);\nfor (int v : nums) {\n++cnt[v + 100];\n}\nsort(nums.begin(), nums.end(), [&](const int a, const int b) {\nif (cnt[a + 100] == cnt[b + 100]) return a > b;\nreturn cnt[a + 100] < cnt[b + 100];\n});\nreturn nums;\n}\n};\n"]}, {"leetCodeID": "1637", "level": "easy", "question_description": "Given n points on a 2D plane where points[i] = [xi, yi], Return the widest vertical area between two points such that no points are inside the area.\nA vertical area is an area of fixed-width extending infinitely along the y-axis (i.e., infinite height). The widest vertical area is the one with the maximum width.\nNote that points on the edge of a vertical area are not considered included in the area.", "examples": ["Example 1:\n\u200b\n\nInput: points = [[8,7],[9,9],[7,4],[9,7]]\nOutput: 1\nExplanation: Both the red and the blue area are optimal.\n\n\nExample 2:\nInput: points = [[3,1],[9,0],[1,0],[1,4],[5,3],[8,8]]\nOutput: 3\n"], "constraints": "\nConstraints:\nn == points.length\n2 <= n <= 105\npoints[i].length == 2\n0 <= xi, yi&nbsp;<= 109\n", "java_context": "\nclass Solution {\n    public int maxWidthOfVerticalArea(int[][] points) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[][]} points\n* @return {number}\n*/\nvar maxWidthOfVerticalArea = function (points) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int maxWidthOfVerticalArea(vector<vector<int>>& points) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int maxWidthOfVerticalArea(int[][] points) {\nArrays.sort(points, (a, b) -> a[0] - b[0]);\nint ans = 0;\nfor (int i = 0; i < points.length - 1; ++i) {\nans = Math.max(ans, points[i + 1][0] - points[i][0]);\n}\nreturn ans;\n}\n}\n", "\nclass Solution {\npublic int maxWidthOfVerticalArea(int[][] points) {\nint n = points.length;\nint[] nums = new int[n];\nfor (int i = 0; i < n; ++i) {\nnums[i] = points[i][0];\n}\nfinal int inf = 1 << 30;\nint mi = inf, mx = -inf;\nfor (int v : nums) {\nmi = Math.min(mi, v);\nmx = Math.max(mx, v);\n}\nint bucketSize = Math.max(1, (mx - mi) / (n - 1));\nint bucketCount = (mx - mi) / bucketSize + 1;\nint[][] buckets = new int[bucketCount][2];\nfor (var bucket : buckets) {\nbucket[0] = inf;\nbucket[1] = -inf;\n}\nfor (int v : nums) {\nint i = (v - mi) / bucketSize;\nbuckets[i][0] = Math.min(buckets[i][0], v);\nbuckets[i][1] = Math.max(buckets[i][1], v);\n}\nint prev = inf;\nint ans = 0;\nfor (var bucket : buckets) {\nif (bucket[0] > bucket[1]) {\ncontinue;\n}\nans = Math.max(ans, bucket[0] - prev);\nprev = bucket[1];\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[][]} points\n* @return {number}\n*/\nvar maxWidthOfVerticalArea = function (points) {\npoints.sort((a, b) => a[0] - b[0]);\nlet ans = 0;\nlet px = points[0][0];\nfor (const [x, _] of points) {\nans = Math.max(ans, x - px);\npx = x;\n}\nreturn ans;\n};\n", "\n/**\n* @param {number[][]} points\n* @return {number}\n*/\nvar maxWidthOfVerticalArea = function (points) {\nconst nums = points.map(point => point[0]);\nconst inf = 1 << 30;\nconst n = nums.length;\nlet mi = inf;\nlet mx = -inf;\nfor (const x of nums) {\nmi = Math.min(mi, x);\nmx = Math.max(mx, x);\n}\nconst bucketSize = Math.max(1, Math.floor((mx - mi) / (n - 1)));\nconst bucketCount = Math.floor((mx - mi) / bucketSize) + 1;\nconst buckets = new Array(bucketCount).fill(0).map(() => [inf, -inf]);\nfor (const x of nums) {\nconst i = Math.floor((x - mi) / bucketSize);\nbuckets[i][0] = Math.min(buckets[i][0], x);\nbuckets[i][1] = Math.max(buckets[i][1], x);\n}\nlet prev = inf;\nlet ans = 0;\nfor (const [left, right] of buckets) {\nif (left > right) {\ncontinue;\n}\nans = Math.max(ans, left - prev);\nprev = right;\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint maxWidthOfVerticalArea(vector<vector<int>>& points) {\nsort(points.begin(), points.end());\nint ans = 0;\nfor (int i = 0; i < points.size() - 1; ++i) {\nans = max(ans, points[i + 1][0] - points[i][0]);\n}\nreturn ans;\n}\n};\n", "\nclass Solution {\npublic:\nint maxWidthOfVerticalArea(vector<vector<int>>& points) {\nint n = points.size();\nvector<int> nums;\nfor (auto& p : points) {\nnums.push_back(p[0]);\n}\nconst int inf = 1 << 30;\nint mi = inf, mx = -inf;\nfor (int v : nums) {\nmi = min(mi, v);\nmx = max(mx, v);\n}\nint bucketSize = max(1, (mx - mi) / (n - 1));\nint bucketCount = (mx - mi) / bucketSize + 1;\nvector<pair<int, int>> buckets(bucketCount, {inf, -inf});\nfor (int v : nums) {\nint i = (v - mi) / bucketSize;\nbuckets[i].first = min(buckets[i].first, v);\nbuckets[i].second = max(buckets[i].second, v);\n}\nint ans = 0;\nint prev = inf;\nfor (auto [curmin, curmax] : buckets) {\nif (curmin > curmax) continue;\nans = max(ans, curmin - prev);\nprev = curmax;\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1640", "level": "easy", "question_description": "You are given an array of distinct integers arr and an array of integer arrays pieces, where the integers in pieces are distinct. Your goal is to form arr by concatenating the arrays in pieces in any order. However, you are not allowed to reorder the integers in each array pieces[i].\nReturn true if it is possible to form the array arr from pieces. Otherwise, return false.", "examples": ["Example 1:\nInput: arr = [15,88], pieces = [[88],[15]]\nOutput: true\nExplanation: Concatenate [15] then [88]\n", "Example 2:\nInput: arr = [49,18,16], pieces = [[16,18,49]]\nOutput: false\nExplanation: Even though the numbers match, we cannot reorder pieces[0].\n", "Example 3:\nInput: arr = [91,4,64,78], pieces = [[78],[4,64],[91]]\nOutput: true\nExplanation: Concatenate [91] then [4,64] then [78]\n"], "constraints": "\nConstraints:\n1 <= pieces.length <= arr.length <= 100\nsum(pieces[i].length) == arr.length\n1 <= pieces[i].length <= arr.length\n1 <= arr[i], pieces[i][j] <= 100\nThe integers in arr are distinct.\nThe integers in pieces are distinct (i.e., If we flatten pieces in a 1D array, all the integers in this array are distinct).\n", "java_context": "\nclass Solution {\n    public boolean canFormArray(int[] arr, int[][] pieces) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} arr\n* @param {number[][]} pieces\n* @return {boolean}\n*/\nvar canFormArray = function (arr, pieces) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    bool canFormArray(vector<int>& arr, vector<vector<int>>& pieces) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic boolean canFormArray(int[] arr, int[][] pieces) {\nfor (int i = 0; i < arr.length;) {\nint k = 0;\nwhile (k < pieces.length && pieces[k][0] != arr[i]) {\n++k;\n}\nif (k == pieces.length) {\nreturn false;\n}\nint j = 0;\nwhile (j < pieces[k].length && arr[i] == pieces[k][j]) {\n++i;\n++j;\n}\n}\nreturn true;\n}\n}\n", "\nclass Solution {\npublic boolean canFormArray(int[] arr, int[][] pieces) {\nMap<Integer, int[]> d = new HashMap<>();\nfor (var p : pieces) {\nd.put(p[0], p);\n}\nfor (int i = 0; i < arr.length;) {\nif (!d.containsKey(arr[i])) {\nreturn false;\n}\nfor (int v : d.get(arr[i])) {\nif (arr[i++] != v) {\nreturn false;\n}\n}\n}\nreturn true;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} arr\n* @param {number[][]} pieces\n* @return {boolean}\n*/\nvar canFormArray = function (arr, pieces) {\nconst d = new Map();\nfor (const p of pieces) {\nd.set(p[0], p);\n}\nfor (let i = 0; i < arr.length; ) {\nif (!d.has(arr[i])) {\nreturn false;\n}\nconst p = d.get(arr[i]);\nfor (const v of p) {\nif (arr[i++] != v) {\nreturn false;\n}\n}\n}\nreturn true;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nbool canFormArray(vector<int>& arr, vector<vector<int>>& pieces) {\nfor (int i = 0; i < arr.size();) {\nint k = 0;\nwhile (k < pieces.size() && pieces[k][0] != arr[i]) {\n++k;\n}\nif (k == pieces.size()) {\nreturn false;\n}\nint j = 0;\nwhile (j < pieces[k].size() && arr[i] == pieces[k][j]) {\n++i;\n++j;\n}\n}\nreturn true;\n}\n};\n", "\nclass Solution {\npublic:\nbool canFormArray(vector<int>& arr, vector<vector<int>>& pieces) {\nunordered_map<int, vector<int>> d;\nfor (auto& p : pieces) {\nd[p[0]] = p;\n}\nfor (int i = 0; i < arr.size();) {\nif (!d.count(arr[i])) {\nreturn false;\n}\nfor (int& v : d[arr[i]]) {\nif (arr[i++] != v) {\nreturn false;\n}\n}\n}\nreturn true;\n}\n};\n"]}, {"leetCodeID": "1688", "level": "easy", "question_description": "You are given an integer n, the number of teams in a tournament that has strange rules:\nIf the current number of teams is even, each team gets paired with another team. A total of n / 2 matches are played, and n / 2 teams advance to the next round.\nIf the current number of teams is odd, one team randomly advances in the tournament, and the rest gets paired. A total of (n - 1) / 2 matches are played, and (n - 1) / 2 + 1 teams advance to the next round.\nReturn the number of matches played in the tournament until a winner is decided.", "examples": ["Example 1:\nInput: n = 7\nOutput: 6\nExplanation: Details of the tournament:\n- 1st Round: Teams = 7, Matches = 3, and 4 teams advance.\n- 2nd Round: Teams = 4, Matches = 2, and 2 teams advance.\n- 3rd Round: Teams = 2, Matches = 1, and 1 team is declared the winner.\nTotal number of matches = 3 + 2 + 1 = 6.\n", "Example 2:\nInput: n = 14\nOutput: 13\nExplanation: Details of the tournament:\n- 1st Round: Teams = 14, Matches = 7, and 7 teams advance.\n- 2nd Round: Teams = 7, Matches = 3, and 4 teams advance.\n- 3rd Round: Teams = 4, Matches = 2, and 2 teams advance.\n- 4th Round: Teams = 2, Matches = 1, and 1 team is declared the winner.\nTotal number of matches = 7 + 3 + 2 + 1 = 13.\n"], "constraints": "\nConstraints:\n1 <= n <= 200\n", "java_context": "\nclass Solution {\n    public int numberOfMatches(int n) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number} n\n* @return {number}\n*/\nvar numberOfMatches = function (n) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int numberOfMatches(int n) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int numberOfMatches(int n) {\nreturn n - 1;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number} n\n* @return {number}\n*/\nvar numberOfMatches = function (n) {\nreturn n - 1;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint numberOfMatches(int n) {\nreturn n - 1;\n}\n};\n"]}, {"leetCodeID": "1704", "level": "easy", "question_description": "You are given a string s of even length. Split this string into two halves of equal lengths, and let a be the first half and b be the second half.\nTwo strings are alike if they have the same number of vowels (&#39;a&#39;, &#39;e&#39;, &#39;i&#39;, &#39;o&#39;, &#39;u&#39;, &#39;A&#39;, &#39;E&#39;, &#39;I&#39;, &#39;O&#39;, &#39;U&#39;). Notice that s contains uppercase and lowercase letters.\nReturn true if a and b are alike. Otherwise, return false.", "examples": ["Example 1:\nInput: s = &quot;book&quot;\nOutput: true\nExplanation: a = &quot;bo&quot; and b = &quot;ok&quot;. a has 1 vowel and b has 1 vowel. Therefore, they are alike.\n", "Example 2:\nInput: s = &quot;textbook&quot;\nOutput: false\nExplanation: a = &quot;text&quot; and b = &quot;book&quot;. a has 1 vowel whereas b has 2. Therefore, they are not alike.\nNotice that the vowel o is counted twice.\n"], "constraints": "\nConstraints:\n2 <= s.length <= 1000\ns.length is even.\ns consists of uppercase and lowercase letters.\n", "java_context": "\nclass Solution {\n    private static final Set<Character> VOWELS\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} s\n* @return {boolean}\n*/\nvar halvesAreAlike = function (s) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    bool halvesAreAlike(string s) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\nprivate static final Set<Character> VOWELS\n= Set.of('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U');\n\npublic boolean halvesAreAlike(String s) {\nint cnt = 0, n = s.length() >> 1;\nfor (int i = 0; i < n; ++i) {\ncnt += VOWELS.contains(s.charAt(i)) ? 1 : 0;\ncnt -= VOWELS.contains(s.charAt(i + n)) ? 1 : 0;\n}\nreturn cnt == 0;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} s\n* @return {boolean}\n*/\nvar halvesAreAlike = function (s) {\nconst str = 'aeiouAEIOU';\nlet cnt = 0;\nfor (let i = 0; i < s.length / 2; i++) {\nif (str.indexOf(s[i]) > -1) cnt++;\nif (str.indexOf(s[s.length - 1 - i]) > -1) cnt--;\n}\nreturn cnt === 0;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nbool halvesAreAlike(string s) {\nunordered_set<char> vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'};\nint cnt = 0, n = s.size() / 2;\nfor (int i = 0; i < n; ++i) {\ncnt += vowels.count(s[i]);\ncnt -= vowels.count(s[i + n]);\n}\nreturn cnt == 0;\n}\n};\n"]}, {"leetCodeID": "1732", "level": "easy", "question_description": "There is a biker going on a road trip. The road trip consists of n + 1 points at different altitudes. The biker starts his trip on point 0 with altitude equal 0.\nYou are given an integer array gain of length n where gain[i] is the net gain in altitude between points i\u200b\u200b\u200b\u200b\u200b\u200b and i + 1 for all (0 &lt;= i &lt; n). Return the highest altitude of a point.", "examples": ["Example 1:\nInput: gain = [-5,1,5,0,-7]\nOutput: 1\nExplanation: The altitudes are [0,-5,-4,1,1,-6]. The highest is 1.\n", "Example 2:\nInput: gain = [-4,-3,-2,-1,4,3,2]\nOutput: 0\nExplanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest is 0.\n"], "constraints": "\nConstraints:\nn == gain.length\n1 <= n <= 100\n-100 <= gain[i] <= 100\n", "java_context": "\nclass Solution {\n    public int largestAltitude(int[] gain) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} gain\n* @return {number}\n*/\nvar largestAltitude = function (gain) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int largestAltitude(vector<int>& gain) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int largestAltitude(int[] gain) {\nint ans = 0, h = 0;\nfor (int v : gain) {\nh += v;\nans = Math.max(ans, h);\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} gain\n* @return {number}\n*/\nvar largestAltitude = function (gain) {\nlet ans = 0;\nlet h = 0;\nfor (const v of gain) {\nh += v;\nans = Math.max(ans, h);\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint largestAltitude(vector<int>& gain) {\nint ans = 0, h = 0;\nfor (int v : gain) h += v, ans = max(ans, h);\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1736", "level": "easy", "question_description": "You are given a string time in the form of  hh:mm, where some of the digits in the string are hidden (represented by ?).\nThe valid times are those inclusively between 00:00 and 23:59.\nReturn the latest valid time you can get from time by replacing the hidden digits.", "examples": ["Example 1:\nInput: time = &quot;2?:?0&quot;\nOutput: &quot;23:50&quot;\nExplanation: The latest hour beginning with the digit &#39;2&#39; is 23 and the latest minute ending with the digit &#39;0&#39; is 50.\n", "Example 2:\nInput: time = &quot;0?:3?&quot;\nOutput: &quot;09:39&quot;\n", "Example 3:\nInput: time = &quot;1?:22&quot;\nOutput: &quot;19:22&quot;\n"], "constraints": "\nConstraints:\ntime is in the format hh:mm.\nIt is guaranteed that you can produce a valid time from the given string.\n", "java_context": "\nclass Solution {\n    public String maximumTime(String time) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} time\n* @return {string}\n*/\nvar maximumTime = function (time) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    string maximumTime(string time) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic String maximumTime(String time) {\nchar[] t = time.toCharArray();\nif (t[0] == '?') {\nt[0] = t[1] >= '4' && t[1] <= '9' ? '1' : '2';\n}\nif (t[1] == '?') {\nt[1] = t[0] == '2' ? '3' : '9';\n}\nif (t[3] == '?') {\nt[3] = '5';\n}\nif (t[4] == '?') {\nt[4] = '9';\n}\nreturn new String(t);\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} time\n* @return {string}\n*/\nvar maximumTime = function (time) {\nconst t = Array.from(time);\nif (t[0] === '?') {\nt[0] = t[1] >= '4' && t[1] <= '9' ? '1' : '2';\n}\nif (t[1] === '?') {\nt[1] = t[0] == '2' ? '3' : '9';\n}\nif (t[3] === '?') {\nt[3] = '5';\n}\nif (t[4] === '?') {\nt[4] = '9';\n}\nreturn t.join('');\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nstring maximumTime(string time) {\nif (time[0] == '?') {\ntime[0] = (time[1] >= '4' && time[1] <= '9') ? '1' : '2';\n}\nif (time[1] == '?') {\ntime[1] = (time[0] == '2') ? '3' : '9';\n}\nif (time[3] == '?') {\ntime[3] = '5';\n}\nif (time[4] == '?') {\ntime[4] = '9';\n}\nreturn time;\n}\n};\n"]}, {"leetCodeID": "1791", "level": "easy", "question_description": "There is an undirected star graph consisting of n nodes labeled from 1 to n. A star graph is a graph where there is one center node and exactly n - 1 edges that connect the center node with every other node.\nYou are given a 2D integer array edges where each edges[i] = [ui, vi] indicates that there is an edge between the nodes ui and vi. Return the center of the given star graph.", "examples": ["Example 1:\n\n\nInput: edges = [[1,2],[2,3],[4,2]]\nOutput: 2\nExplanation: As shown in the figure above, node 2 is connected to every other node, so 2 is the center.\n\n\nExample 2:\nInput: edges = [[1,2],[5,1],[1,3],[1,4]]\nOutput: 1\n"], "constraints": "\nConstraints:\n3 <= n <= 105\nedges.length == n - 1\nedges[i].length == 2\n1 <= ui, vi <= n\nui != vi\nThe given edges represent a valid star graph.\n", "java_context": "\nclass Solution {\n    public int findCenter(int[][] edges) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[][]} edges\n* @return {number}\n*/\nvar findCenter = function (edges) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int findCenter(vector<vector<int>>& edges) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int findCenter(int[][] edges) {\nint a = edges[0][0], b = edges[0][1];\nint c = edges[1][0], d = edges[1][1];\nreturn a == c || a == d ? a : b;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[][]} edges\n* @return {number}\n*/\nvar findCenter = function (edges) {\nconst [a, b] = edges[0];\nconst [c, d] = edges[1];\nreturn a == c || a == d ? a : b;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint findCenter(vector<vector<int>>& edges) {\nint a = edges[0][0], b = edges[0][1];\nint c = edges[1][0], d = edges[1][1];\nreturn a == c || a == d ? a : b;\n}\n};\n"]}, {"leetCodeID": "1812", "level": "easy", "question_description": "You are given coordinates, a string that represents the coordinates of a square of the chessboard. Below is a chessboard for your reference.\nReturn true if the square is white, and false if the square is black.\nThe coordinate will always represent a valid chessboard square. The coordinate will always have the letter first, and the number second.", "examples": ["Example 1:\nInput: coordinates = &quot;a1&quot;\nOutput: false\nExplanation: From the chessboard above, the square with coordinates &quot;a1&quot; is black, so return false.\n", "Example 2:\nInput: coordinates = &quot;h3&quot;\nOutput: true\nExplanation: From the chessboard above, the square with coordinates &quot;h3&quot; is white, so return true.\n", "Example 3:\nInput: coordinates = &quot;c7&quot;\nOutput: false\n"], "constraints": "\nConstraints:\ncoordinates.length == 2\n&#39;a&#39; <= coordinates[0] <= &#39;h&#39;\n&#39;1&#39; <= coordinates[1] <= &#39;8&#39;\n", "java_context": "\nclass Solution {\n    public boolean squareIsWhite(String coordinates) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} coordinates\n* @return {boolean}\n*/\nvar squareIsWhite = function (coordinates) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    bool squareIsWhite(string coordinates) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic boolean squareIsWhite(String coordinates) {\nreturn (coordinates.charAt(0) + coordinates.charAt(1)) % 2 == 1;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} coordinates\n* @return {boolean}\n*/\nvar squareIsWhite = function (coordinates) {\nconst x = coordinates.charAt(0).charCodeAt();\nconst y = coordinates.charAt(1).charCodeAt();\nreturn (x + y) % 2 == 1;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nbool squareIsWhite(string coordinates) {\nreturn (coordinates[0] + coordinates[1]) % 2;\n}\n};\n"]}, {"leetCodeID": "1816", "level": "easy", "question_description": "A sentence is a list of words that are separated by a single space with no leading or trailing spaces. Each of the words consists of only uppercase and lowercase English letters (no punctuation).\nFor example, &quot;Hello World&quot;, &quot;HELLO&quot;, and &quot;hello world hello world&quot; are all sentences.\nYou are given a sentence s\u200b\u200b\u200b\u200b\u200b\u200b and an integer k\u200b\u200b\u200b\u200b\u200b\u200b. You want to truncate s\u200b\u200b\u200b\u200b\u200b\u200b such that it contains only the first k\u200b\u200b\u200b\u200b\u200b\u200b words. Return s\u200b\u200b\u200b\u200b\u200b\u200b after truncating it.", "examples": ["Example 1:\nInput: s = &quot;Hello how are you Contestant&quot;, k = 4\nOutput: &quot;Hello how are you&quot;\nExplanation:\nThe words in s are [&quot;Hello&quot;, &quot;how&quot; &quot;are&quot;, &quot;you&quot;, &quot;Contestant&quot;].\nThe first 4 words are [&quot;Hello&quot;, &quot;how&quot;, &quot;are&quot;, &quot;you&quot;].\nHence, you should return &quot;Hello how are you&quot;.\n", "Example 2:\nInput: s = &quot;What is the solution to this problem&quot;, k = 4\nOutput: &quot;What is the solution&quot;\nExplanation:\nThe words in s are [&quot;What&quot;, &quot;is&quot; &quot;the&quot;, &quot;solution&quot;, &quot;to&quot;, &quot;this&quot;, &quot;problem&quot;].\nThe first 4 words are [&quot;What&quot;, &quot;is&quot;, &quot;the&quot;, &quot;solution&quot;].\nHence, you should return &quot;What is the solution&quot;.", "Example 3:\nInput: s = &quot;chopper is not a tanuki&quot;, k = 5\nOutput: &quot;chopper is not a tanuki&quot;\n"], "constraints": "\nConstraints:\n1 <= s.length <= 500\nk is in the range [1, the number of words in s].\ns consist of only lowercase and uppercase English letters and spaces.\nThe words in s are separated by a single space.\nThere are no leading or trailing spaces.\n", "java_context": "\nclass Solution {\n    public String truncateSentence(String s, int k) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} s\n* @param {number} k\n* @return {string}\n*/\nvar truncateSentence = function (s, k) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    string truncateSentence(string s, int k) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic String truncateSentence(String s, int k) {\nfor (int i = 0; i < s.length(); ++i) {\nif (s.charAt(i) == ' ' && (--k) == 0) {\nreturn s.substring(0, i);\n}\n}\nreturn s;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} s\n* @param {number} k\n* @return {string}\n*/\nvar truncateSentence = function (s, k) {\nfor (let i = 0; i < s.length; ++i) {\nif (s[i] === ' ' && --k === 0) {\nreturn s.slice(0, i);\n}\n}\nreturn s;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nstring truncateSentence(string s, int k) {\nfor (int i = 0; i < s.size(); ++i) {\nif (s[i] == ' ' && (--k) == 0) {\nreturn s.substr(0, i);\n}\n}\nreturn s;\n}\n};\n"]}, {"leetCodeID": "1822", "level": "easy", "question_description": "There is a function signFunc(x) that returns:\n1 if x is positive.\n-1 if x is negative.\n0 if x is equal to 0.\nYou are given an integer array nums. Let product be the product of all values in the array nums.\nReturn signFunc(product).", "examples": ["Example 1:\nInput: nums = [-1,-2,-3,-4,3,2,1]\nOutput: 1\nExplanation: The product of all values in the array is 144, and signFunc(144) = 1\n", "Example 2:\nInput: nums = [1,5,0,2,-3]\nOutput: 0\nExplanation: The product of all values in the array is 0, and signFunc(0) = 0\n", "Example 3:\nInput: nums = [-1,1,-1,1,-1]\nOutput: -1\nExplanation: The product of all values in the array is -1, and signFunc(-1) = -1\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 1000\n-100 <= nums[i] <= 100\n", "java_context": "\nclass Solution {\n    public int arraySign(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar arraySign = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int arraySign(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int arraySign(int[] nums) {\nint ans = 1;\nfor (int v : nums) {\nif (v == 0) {\nreturn 0;\n}\nif (v < 0) {\nans *= -1;\n}\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar arraySign = function (nums) {\nlet ans = 1;\nfor (const v of nums) {\nif (!v) {\nreturn 0;\n}\nif (v < 0) {\nans *= -1;\n}\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint arraySign(vector<int>& nums) {\nint ans = 1;\nfor (int v : nums) {\nif (!v) return 0;\nif (v < 0) ans *= -1;\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1837", "level": "easy", "question_description": "Given an integer n (in base 10) and a base k, return the sum of the digits of n after converting n from base 10 to base k.\nAfter converting, each digit should be interpreted as a base 10 number, and the sum should be returned in base 10.", "examples": ["Example 1:\nInput: n = 34, k = 6\nOutput: 9\nExplanation: 34 (base 10) expressed in base 6 is 54. 5 + 4 = 9.\n", "Example 2:\nInput: n = 10, k = 10\nOutput: 1\nExplanation: n is already in base 10. 1 + 0 = 1.\n"], "constraints": "\nConstraints:\n1 <= n <= 100\n2 <= k <= 10\n", "java_context": "\nclass Solution {\n    public int sumBase(int n, int k) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number} n\n* @param {number} k\n* @return {number}\n*/\nvar sumBase = function (n, k) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int sumBase(int n, int k) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int sumBase(int n, int k) {\nint ans = 0;\nwhile (n != 0) {\nans += n % k;\nn /= k;\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number} n\n* @param {number} k\n* @return {number}\n*/\nvar sumBase = function (n, k) {\nlet ans = 0;\nwhile (n) {\nans += n % k;\nn = Math.floor(n / k);\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint sumBase(int n, int k) {\nint ans = 0;\nwhile (n) {\nans += n % k;\nn /= k;\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1854", "level": "easy", "question_description": "You are given a 2D integer array logs where each logs[i] = [birthi, deathi] indicates the birth and death years of the ith person.\nThe population of some year x is the number of people alive during that year. The ith person is counted in year x&#39;s population if x is in the inclusive range [birthi, deathi - 1]. Note that the person is not counted in the year that they die.\nReturn the earliest year with the maximum population.", "examples": ["Example 1:\nInput: logs = [[1993,1999],[2000,2010]]\nOutput: 1993\nExplanation: The maximum population is 1, and 1993 is the earliest year with this population.\n", "Example 2:\nInput: logs = [[1950,1961],[1960,1971],[1970,1981]]\nOutput: 1960\nExplanation:\nThe maximum population is 2, and it had happened in years 1960 and 1970.\nThe earlier year between them is 1960."], "constraints": "\nConstraints:\n1 <= logs.length <= 100\n1950 <= birthi < deathi <= 2050\n", "java_context": "\nclass Solution {\n    public int maximumPopulation(int[][] logs) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[][]} logs\n* @return {number}\n*/\nvar maximumPopulation = function (logs) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int maximumPopulation(vector<vector<int>>& logs) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int maximumPopulation(int[][] logs) {\nint[] d = new int[101];\nfinal int offset = 1950;\nfor (var log : logs) {\nint a = log[0] - offset;\nint b = log[1] - offset;\n++d[a];\n--d[b];\n}\nint s = 0, mx = 0;\nint j = 0;\nfor (int i = 0; i < d.length; ++i) {\ns += d[i];\nif (mx < s) {\nmx = s;\nj = i;\n}\n}\nreturn j + offset;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[][]} logs\n* @return {number}\n*/\nvar maximumPopulation = function (logs) {\nconst d = new Array(101).fill(0);\nconst offset = 1950;\nfor (let [a, b] of logs) {\na -= offset;\nb -= offset;\nd[a]++;\nd[b]--;\n}\nlet j = 0;\nfor (let i = 0, s = 0, mx = 0; i < 101; ++i) {\ns += d[i];\nif (mx < s) {\nmx = s;\nj = i;\n}\n}\nreturn j + offset;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint maximumPopulation(vector<vector<int>>& logs) {\nint d[101]{};\nconst int offset = 1950;\nfor (auto& log : logs) {\nint a = log[0] - offset;\nint b = log[1] - offset;\n++d[a];\n--d[b];\n}\nint s = 0, mx = 0;\nint j = 0;\nfor (int i = 0; i < 101; ++i) {\ns += d[i];\nif (mx < s) {\nmx = s;\nj = i;\n}\n}\nreturn j + offset;\n}\n};\n"]}, {"leetCodeID": "1859", "level": "easy", "question_description": "A sentence is a list of words that are separated by a single space with no leading or trailing spaces. Each word consists of lowercase and uppercase English letters.\nA sentence can be shuffled by appending the 1-indexed word position to each word then rearranging the words in the sentence.\nFor example, the sentence &quot;This is a sentence&quot; can be shuffled as &quot;sentence4 a3 is2 This1&quot; or &quot;is2 sentence4 This1 a3&quot;.\nGiven a shuffled sentence s containing no more than 9 words, reconstruct and return the original sentence.", "examples": ["Example 1:\n\nInput: s = &quot;is2 sentence4 This1 a3&quot;\n\nOutput: &quot;This is a sentence&quot;\n\nExplanation: Sort the words in s to their original positions &quot;This1 is2 a3 sentence4&quot;, then remove the numbers.\n\n", "Example 2:\n\nInput: s = &quot;Myself2 Me1 I4 and3&quot;\n\nOutput: &quot;Me Myself and I&quot;\n\nExplanation: Sort the words in s to their original positions &quot;Me1 Myself2 and3 I4&quot;, then remove the numbers.\n\n"], "constraints": "\nConstraints:\n2 <= s.length <= 200\ns consists of lowercase and uppercase English letters, spaces, and digits from 1 to 9.\nThe number of words in s is between 1 and 9.\nThe words in s are separated by a single space.\ns contains no leading or trailing spaces.\n", "java_context": "\nclass Solution {\n    public String sortSentence(String s) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} s\n* @return {string}\n*/\nvar sortSentence = function (s) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    string sortSentence(string s) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic String sortSentence(String s) {\nString[] ws = s.split(\" \");\nint n = ws.length;\nString[] ans = new String[n];\nfor (int i = 0; i < n; ++i) {\nString w = ws[i];\nans[w.charAt(w.length() - 1) - '1'] = w.substring(0, w.length() - 1);\n}\nreturn String.join(\" \", ans);\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} s\n* @return {string}\n*/\nvar sortSentence = function (s) {\nconst ws = s.split(' ');\nconst ans = Array(ws.length);\nfor (const w of ws) {\nans[w.charCodeAt(w.length - 1) - '1'.charCodeAt(0)] = w.slice(0, -1);\n}\nreturn ans.join(' ');\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nstring sortSentence(string s) {\nistringstream iss(s);\nstring w;\nvector<string> ws;\nwhile (iss >> w) {\nws.push_back(w);\n}\nvector<string> ss(ws.size());\nfor (auto& w : ws) {\nss[w.back() - '1'] = w.substr(0, w.size() - 1);\n}\nstring ans;\nfor (auto& w : ss) {\nans += w + \" \";\n}\nans.pop_back();\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1863", "level": "easy", "question_description": "The XOR total of an array is defined as the bitwise XOR of all its elements, or 0 if the array is empty.\nFor example, the XOR total of the array [2,5,6] is 2 XOR 5 XOR 6 = 1.\nGiven an array nums, return the sum of all XOR totals for every subset of nums. \nNote: Subsets with the same elements should be counted multiple times.\nAn array a is a subset of an array b if a can be obtained from b by deleting some (possibly zero) elements of b.", "examples": ["Example 1:\nInput: nums = [1,3]\nOutput: 6\nExplanation: The 4 subsets of [1,3] are:\n- The empty subset has an XOR total of 0.\n- [1] has an XOR total of 1.\n- [3] has an XOR total of 3.\n- [1,3] has an XOR total of 1 XOR 3 = 2.\n0 + 1 + 3 + 2 = 6\n", "Example 2:\nInput: nums = [5,1,6]\nOutput: 28\nExplanation: The 8 subsets of [5,1,6] are:\n- The empty subset has an XOR total of 0.\n- [5] has an XOR total of 5.\n- [1] has an XOR total of 1.\n- [6] has an XOR total of 6.\n- [5,1] has an XOR total of 5 XOR 1 = 4.\n- [5,6] has an XOR total of 5 XOR 6 = 3.\n- [1,6] has an XOR total of 1 XOR 6 = 7.\n- [5,1,6] has an XOR total of 5 XOR 1 XOR 6 = 2.\n0 + 5 + 1 + 6 + 4 + 3 + 7 + 2 = 28\n", "Example 3:\nInput: nums = [3,4,5,6,7,8]\nOutput: 480\nExplanation: The sum of all XOR totals for every subset is 480.\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 12\n1 <= nums[i] <= 20\n", "java_context": "\nclass Solution {\n    public int subsetXORSum(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar subsetXORSum = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int subsetXORSum(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int subsetXORSum(int[] nums) {\nint n = nums.length;\nint ans = 0;\nfor (int i = 0; i < 1 << n; ++i) {\nint s = 0;\nfor (int j = 0; j < n; ++j) {\nif ((i >> j & 1) == 1) {\ns ^= nums[j];\n}\n}\nans += s;\n}\nreturn ans;\n}\n}\n", "\nclass Solution {\nprivate int ans;\nprivate int[] nums;\n\npublic int subsetXORSum(int[] nums) {\nthis.nums = nums;\ndfs(0, 0);\nreturn ans;\n}\n\nprivate void dfs(int i, int s) {\nif (i >= nums.length) {\nans += s;\nreturn;\n}\ndfs(i + 1, s);\ndfs(i + 1, s ^ nums[i]);\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar subsetXORSum = function (nums) {\nlet ans = 0;\nconst n = nums.length;\nfor (let i = 0; i < 1 << n; ++i) {\nlet s = 0;\nfor (let j = 0; j < n; ++j) {\nif ((i >> j) & 1) {\ns ^= nums[j];\n}\n}\nans += s;\n}\nreturn ans;\n};\n", "\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar subsetXORSum = function (nums) {\nlet ans = 0;\nconst n = nums.length;\nconst dfs = (i, s) => {\nif (i >= n) {\nans += s;\nreturn;\n}\ndfs(i + 1, s);\ndfs(i + 1, s ^ nums[i]);\n};\ndfs(0, 0);\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint subsetXORSum(vector<int>& nums) {\nint n = nums.size();\nint ans = 0;\nfor (int i = 0; i < 1 << n; ++i) {\nint s = 0;\nfor (int j = 0; j < n; ++j) {\nif (i >> j & 1) {\ns ^= nums[j];\n}\n}\nans += s;\n}\nreturn ans;\n}\n};\n", "\nclass Solution {\npublic:\nint subsetXORSum(vector<int>& nums) {\nint n = nums.size();\nint ans = 0;\nfunction<void(int, int)> dfs = [&](int i, int s) {\nif (i >= n) {\nans += s;\nreturn;\n}\ndfs(i + 1, s);\ndfs(i + 1, s ^ nums[i]);\n};\ndfs(0, 0);\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1869", "level": "easy", "question_description": "Given a binary string s, return true if the longest contiguous segment of 1&#39;s is strictly longer than the longest contiguous segment of 0&#39;s in s, or return false otherwise.\nFor example, in s = &quot;110100010&quot; the longest continuous segment of 1s has length 2, and the longest continuous segment of 0s has length 3.\nNote that if there are no 0&#39;s, then the longest continuous segment of 0&#39;s is considered to have a length 0. The same applies if there is no 1&#39;s.", "examples": ["Example 1:\nInput: s = &quot;1101&quot;\nOutput: true\nExplanation:\nThe longest contiguous segment of 1s has length 2: &quot;1101&quot;\nThe longest contiguous segment of 0s has length 1: &quot;1101&quot;\nThe segment of 1s is longer, so return true.\n", "Example 2:\nInput: s = &quot;111000&quot;\nOutput: false\nExplanation:\nThe longest contiguous segment of 1s has length 3: &quot;111000&quot;\nThe longest contiguous segment of 0s has length 3: &quot;111000&quot;\nThe segment of 1s is not longer, so return false.\n", "Example 3:\nInput: s = &quot;110100010&quot;\nOutput: false\nExplanation:\nThe longest contiguous segment of 1s has length 2: &quot;110100010&quot;\nThe longest contiguous segment of 0s has length 3: &quot;110100010&quot;\nThe segment of 1s is not longer, so return false.\n"], "constraints": "\nConstraints:\n1 <= s.length <= 100\ns[i] is either &#39;0&#39; or &#39;1&#39;.\n", "java_context": "\nclass Solution {\n    public boolean checkZeroOnes(String s) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} s\n* @return {boolean}\n*/\nvar checkZeroOnes = function (s) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    bool checkZeroOnes(string s) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic boolean checkZeroOnes(String s) {\nreturn f(s, '1') > f(s, '0');\n}\n\nprivate int f(String s, char x) {\nint cnt = 0, mx = 0;\nfor (int i = 0; i < s.length(); ++i) {\nif (s.charAt(i) == x) {\nmx = Math.max(mx, ++cnt);\n} else {\ncnt = 0;\n}\n}\nreturn mx;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} s\n* @return {boolean}\n*/\nvar checkZeroOnes = function (s) {\nconst f = x => {\nlet [mx, cnt] = [0, 0];\nfor (const c of s) {\nif (c === x) {\nmx = Math.max(mx, ++cnt);\n} else {\ncnt = 0;\n}\n}\nreturn mx;\n};\nreturn f('1') > f('0');\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nbool checkZeroOnes(string s) {\nauto f = [&](char x) {\nint cnt = 0, mx = 0;\nfor (char& c : s) {\nif (c == x) {\nmx = max(mx, ++cnt);\n} else {\ncnt = 0;\n}\n}\nreturn mx;\n};\nreturn f('1') > f('0');\n}\n};\n"]}, {"leetCodeID": "1880", "level": "easy", "question_description": "The letter value of a letter is its position in the alphabet starting from 0 (i.e. &#39;a&#39; -&gt; 0, &#39;b&#39; -&gt; 1, &#39;c&#39; -&gt; 2, etc.).\nThe numerical value of some string of lowercase English letters s is the concatenation of the letter values of each letter in s, which is then converted into an integer.\nFor example, if s = &quot;acb&quot;, we concatenate each letter&#39;s letter value, resulting in &quot;021&quot;. After converting it, we get 21.\nYou are given three strings firstWord, secondWord, and targetWord, each consisting of lowercase English letters &#39;a&#39; through &#39;j&#39; inclusive.\nReturn true if the summation of the numerical values of firstWord and secondWord equals the numerical value of targetWord, or false otherwise.", "examples": ["Example 1:\nInput: firstWord = &quot;acb&quot;, secondWord = &quot;cba&quot;, targetWord = &quot;cdb&quot;\nOutput: true\nExplanation:\nThe numerical value of firstWord is &quot;acb&quot; -&gt; &quot;021&quot; -&gt; 21.\nThe numerical value of secondWord is &quot;cba&quot; -&gt; &quot;210&quot; -&gt; 210.\nThe numerical value of targetWord is &quot;cdb&quot; -&gt; &quot;231&quot; -&gt; 231.\nWe return true because 21 + 210 == 231.\n", "Example 2:\nInput: firstWord = &quot;aaa&quot;, secondWord = &quot;a&quot;, targetWord = &quot;aab&quot;\nOutput: false\nExplanation:\nThe numerical value of firstWord is &quot;aaa&quot; -&gt; &quot;000&quot; -&gt; 0.\nThe numerical value of secondWord is &quot;a&quot; -&gt; &quot;0&quot; -&gt; 0.\nThe numerical value of targetWord is &quot;aab&quot; -&gt; &quot;001&quot; -&gt; 1.\nWe return false because 0 + 0 != 1.\n", "Example 3:\nInput: firstWord = &quot;aaa&quot;, secondWord = &quot;a&quot;, targetWord = &quot;aaaa&quot;\nOutput: true\nExplanation:\nThe numerical value of firstWord is &quot;aaa&quot; -&gt; &quot;000&quot; -&gt; 0.\nThe numerical value of secondWord is &quot;a&quot; -&gt; &quot;0&quot; -&gt; 0.\nThe numerical value of targetWord is &quot;aaaa&quot; -&gt; &quot;0000&quot; -&gt; 0.\nWe return true because 0 + 0 == 0.\n"], "constraints": "\nConstraints:\n1 <= firstWord.length, secondWord.length, targetWord.length <= 8\nfirstWord, secondWord, and targetWord consist of lowercase English letters from &#39;a&#39; to &#39;j&#39; inclusive.\n", "java_context": "\nclass Solution {\n    public boolean isSumEqual(String firstWord, String secondWord, String targetWord) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} firstWord\n* @param {string} secondWord\n* @param {string} targetWord\n* @return {boolean}\n*/\nvar isSumEqual = function (firstWord, secondWord, targetWord) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    bool isSumEqual(string firstWord, string secondWord, string targetWord) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic boolean isSumEqual(String firstWord, String secondWord, String targetWord) {\nreturn f(firstWord) + f(secondWord) == f(targetWord);\n}\n\nprivate int f(String s) {\nint res = 0;\nfor (char c : s.toCharArray()) {\nres = res * 10 + (c - 'a');\n}\nreturn res;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} firstWord\n* @param {string} secondWord\n* @param {string} targetWord\n* @return {boolean}\n*/\nvar isSumEqual = function (firstWord, secondWord, targetWord) {\nfunction f(s) {\nlet res = 0;\nfor (let c of s) {\nres = res * 10 + (c.charCodeAt() - 'a'.charCodeAt());\n}\nreturn res;\n}\nreturn f(firstWord) + f(secondWord) == f(targetWord);\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nbool isSumEqual(string firstWord, string secondWord, string targetWord) {\nreturn f(firstWord) + f(secondWord) == f(targetWord);\n}\n\nint f(string s) {\nint res = 0;\nfor (char c : s) res = res * 10 + (c - 'a');\nreturn res;\n}\n};\n"]}, {"leetCodeID": "1893", "level": "easy", "question_description": "You are given a 2D integer array ranges and two integers left and right. Each ranges[i] = [starti, endi] represents an inclusive interval between starti and endi.\nReturn true if each integer in the inclusive range [left, right] is covered by at least one interval in ranges. Return false otherwise.\nAn integer x is covered by an interval ranges[i] = [starti, endi] if starti &lt;= x &lt;= endi.", "examples": ["Example 1:\nInput: ranges = [[1,2],[3,4],[5,6]], left = 2, right = 5\nOutput: true\nExplanation: Every integer between 2 and 5 is covered:\n- 2 is covered by the first range.\n- 3 and 4 are covered by the second range.\n- 5 is covered by the third range.\n", "Example 2:\nInput: ranges = [[1,10],[10,20]], left = 21, right = 21\nOutput: false\nExplanation: 21 is not covered by any range.\n"], "constraints": "\nConstraints:\n1 <= ranges.length <= 50\n1 <= starti <= endi <= 50\n1 <= left <= right <= 50\n", "java_context": "\nclass Solution {\n    public boolean isCovered(int[][] ranges, int left, int right) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[][]} ranges\n* @param {number} left\n* @param {number} right\n* @return {boolean}\n*/\nvar isCovered = function (ranges, left, right) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    bool isCovered(vector<vector<int>>& ranges, int left, int right) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic boolean isCovered(int[][] ranges, int left, int right) {\nint[] diff = new int[52];\nfor (int[] range : ranges) {\nint l = range[0], r = range[1];\n++diff[l];\n--diff[r + 1];\n}\nint cur = 0;\nfor (int i = 0; i < diff.length; ++i) {\ncur += diff[i];\nif (i >= left && i <= right && cur == 0) {\nreturn false;\n}\n}\nreturn true;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[][]} ranges\n* @param {number} left\n* @param {number} right\n* @return {boolean}\n*/\nvar isCovered = function (ranges, left, right) {\nconst diff = new Array(52).fill(0);\nfor (const [l, r] of ranges) {\n++diff[l];\n--diff[r + 1];\n}\nlet cur = 0;\nfor (let i = 0; i < 52; ++i) {\ncur += diff[i];\nif (i >= left && i <= right && cur <= 0) {\nreturn false;\n}\n}\nreturn true;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nbool isCovered(vector<vector<int>>& ranges, int left, int right) {\nint diff[52]{};\nfor (auto& range : ranges) {\nint l = range[0], r = range[1];\n++diff[l];\n--diff[r + 1];\n}\nint cur = 0;\nfor (int i = 0; i < 52; ++i) {\ncur += diff[i];\nif (i >= left && i <= right && cur <= 0) {\nreturn false;\n}\n}\nreturn true;\n}\n};\n"]}, {"leetCodeID": "1903", "level": "easy", "question_description": "You are given a string num, representing a large integer. Return the largest-valued odd integer (as a string) that is a non-empty substring of num, or an empty string &quot;&quot; if no odd integer exists.\nA substring is a contiguous sequence of characters within a string.", "examples": ["Example 1:\nInput: num = &quot;52&quot;\nOutput: &quot;5&quot;\nExplanation: The only non-empty substrings are &quot;5&quot;, &quot;2&quot;, and &quot;52&quot;. &quot;5&quot; is the only odd number.\n", "Example 2:\nInput: num = &quot;4206&quot;\nOutput: &quot;&quot;\nExplanation: There are no odd numbers in &quot;4206&quot;.\n", "Example 3:\nInput: num = &quot;35427&quot;\nOutput: &quot;35427&quot;\nExplanation: &quot;35427&quot; is already an odd number.\n"], "constraints": "\nConstraints:\n1 <= num.length <= 105\nnum only consists of digits and does not contain any leading zeros.\n", "java_context": "\nclass Solution {\n    public String largestOddNumber(String num) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} num\n* @return {string}\n*/\nvar largestOddNumber = function (num) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    string largestOddNumber(string num) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic String largestOddNumber(String num) {\nfor (int i = num.length() - 1; i >= 0; --i) {\nint c = num.charAt(i) - '0';\nif ((c & 1) == 1) {\nreturn num.substring(0, i + 1);\n}\n}\nreturn \"\";\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} num\n* @return {string}\n*/\nvar largestOddNumber = function (num) {\nfor (let i = num.length - 1; ~i; --i) {\nif (Number(num[i]) & 1) {\nreturn num.slice(0, i + 1);\n}\n}\nreturn '';\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nstring largestOddNumber(string num) {\nfor (int i = num.size() - 1; i >= 0; --i) {\nint c = num[i] - '0';\nif ((c & 1) == 1) {\nreturn num.substr(0, i + 1);\n}\n}\nreturn \"\";\n}\n};\n"]}, {"leetCodeID": "1913", "level": "easy", "question_description": "The product difference between two pairs (a, b) and (c, d) is defined as (a * b) - (c * d).\nFor example, the product difference between (5, 6) and (2, 7) is (5 * 6) - (2 * 7) = 16.\nGiven an integer array nums, choose four distinct indices w, x, y, and z such that the product difference between pairs (nums[w], nums[x]) and (nums[y], nums[z]) is maximized.\nReturn the maximum such product difference.", "examples": ["Example 1:\n\nInput: nums = [5,6,2,7,4]\n\nOutput: 34\n\nExplanation: We can choose indices 1 and 3 for the first pair (6, 7) and indices 2 and 4 for the second pair (2, 4).\n\nThe product difference is (6 * 7) - (2 * 4) = 34.\n\n", "Example 2:\n\nInput: nums = [4,2,5,9,7,4,8]\n\nOutput: 64\n\nExplanation: We can choose indices 3 and 6 for the first pair (9, 8) and indices 1 and 5 for the second pair (2, 4).\n\nThe product difference is (9 * 8) - (2 * 4) = 64.\n\n"], "constraints": "\nConstraints:\n4 <= nums.length <= 104\n1 <= nums[i] <= 104\n", "java_context": "\nclass Solution {\n    public int maxProductDifference(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar maxProductDifference = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int maxProductDifference(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int maxProductDifference(int[] nums) {\nArrays.sort(nums);\nint n = nums.length;\nreturn nums[n - 1] * nums[n - 2] - nums[0] * nums[1];\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar maxProductDifference = function (nums) {\nnums.sort((a, b) => a - b);\nlet n = nums.length;\nlet ans = nums[n - 1] * nums[n - 2] - nums[0] * nums[1];\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint maxProductDifference(vector<int>& nums) {\nsort(nums.begin(), nums.end());\nint n = nums.size();\nreturn nums[n - 1] * nums[n - 2] - nums[0] * nums[1];\n}\n};\n"]}, {"leetCodeID": "1920", "level": "easy", "question_description": "Given a zero-based permutation nums (0-indexed), build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 &lt;= i &lt; nums.length and return it.\nA zero-based permutation nums is an array of distinct integers from 0 to nums.length - 1 (inclusive).", "examples": ["Example 1:\nInput: nums = [0,2,1,5,3,4]\nOutput: [0,1,2,4,5,3]\nExplanation: The array ans is built as follows:\nans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]\n= [nums[0], nums[2], nums[1], nums[5], nums[3], nums[4]]\n= [0,1,2,4,5,3]", "Example 2:\nInput: nums = [5,0,1,2,3,4]\nOutput: [4,5,0,1,2,3]\nExplanation: The array ans is built as follows:\nans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]\n= [nums[5], nums[0], nums[1], nums[2], nums[3], nums[4]]\n= [4,5,0,1,2,3]"], "constraints": "\nConstraints:\n1 <= nums.length <= 1000\n0 <= nums[i] < nums.length\nThe elements in nums are distinct.\n", "java_context": "\nclass Solution {\n    public int[] buildArray(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number[]}\n*/\nvar buildArray = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> buildArray(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int[] buildArray(int[] nums) {\nint[] ans = new int[nums.length];\nfor (int i = 0; i < nums.length; ++i) {\nans[i] = nums[nums[i]];\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number[]}\n*/\nvar buildArray = function (nums) {\nlet ans = [];\nfor (let i = 0; i < nums.length; ++i) {\nans[i] = nums[nums[i]];\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> buildArray(vector<int>& nums) {\nvector<int> ans;\nfor (int& num : nums) {\nans.push_back(nums[num]);\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1929", "level": "easy", "question_description": "Given an integer array nums of length n, you want to create an array ans of length 2n where ans[i] == nums[i] and ans[i + n] == nums[i] for 0 &lt;= i &lt; n (0-indexed).\nSpecifically, ans is the concatenation of two nums arrays.\nReturn the array ans.", "examples": ["Example 1:\nInput: nums = [1,2,1]\nOutput: [1,2,1,1,2,1]\nExplanation: The array ans is formed as follows:\n- ans = [nums[0],nums[1],nums[2],nums[0],nums[1],nums[2]]\n- ans = [1,2,1,1,2,1]", "Example 2:\nInput: nums = [1,3,2,1]\nOutput: [1,3,2,1,1,3,2,1]\nExplanation: The array ans is formed as follows:\n- ans = [nums[0],nums[1],nums[2],nums[3],nums[0],nums[1],nums[2],nums[3]]\n- ans = [1,3,2,1,1,3,2,1]\n"], "constraints": "\nConstraints:\nn == nums.length\n1 <= n <= 1000\n1 <= nums[i] <= 1000\n", "java_context": "\nclass Solution {\n    public int[] getConcatenation(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number[]}\n*/\nvar getConcatenation = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> getConcatenation(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int[] getConcatenation(int[] nums) {\nint n = nums.length;\nint[] ans = new int[n << 1];\nfor (int i = 0; i < n << 1; ++i) {\nans[i] = nums[i % n];\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number[]}\n*/\nvar getConcatenation = function (nums) {\nlet ans = nums.slice();\nans.splice(nums.length, 0, ...nums);\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> getConcatenation(vector<int>& nums) {\nfor (int i = 0, n = nums.size(); i < n; ++i) {\nnums.push_back(nums[i]);\n}\nreturn nums;\n}\n};\n"]}, {"leetCodeID": "1952", "level": "easy", "question_description": "Given an integer n, return true if n has exactly three positive divisors. Otherwise, return false.\nAn integer m is a divisor of n if there exists an integer k such that n = k * m.", "examples": ["Example 1:\nInput: n = 2\nOutput: false\nExplantion: 2 has only two divisors: 1 and 2.\n", "Example 2:\nInput: n = 4\nOutput: true\nExplantion: 4 has three divisors: 1, 2, and 4.\n"], "constraints": "\nConstraints:\n1 <= n <= 104\n", "java_context": "\nclass Solution {\n    public boolean isThree(int n) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number} n\n* @return {boolean}\n*/\nvar isThree = function (n) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    bool isThree(int n) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic boolean isThree(int n) {\nint cnt = 0;\nfor (int i = 2; i < n; i++) {\nif (n % i == 0) {\n++cnt;\n}\n}\nreturn cnt == 1;\n}\n}\n", "\nclass Solution {\npublic boolean isThree(int n) {\nint cnt = 0;\nfor (int i = 1; i <= n / i; ++i) {\nif (n % i == 0) {\ncnt += n / i == i ? 1 : 2;\n}\n}\nreturn cnt == 3;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number} n\n* @return {boolean}\n*/\nvar isThree = function (n) {\nlet cnt = 0;\nfor (let i = 2; i < n; ++i) {\nif (n % i == 0) {\n++cnt;\n}\n}\nreturn cnt == 1;\n};\n", "\n/**\n* @param {number} n\n* @return {boolean}\n*/\nvar isThree = function (n) {\nlet cnt = 0;\nfor (let i = 1; i <= n / i; ++i) {\nif (n % i == 0) {\ncnt += ~~(n / i) == i ? 1 : 2;\n}\n}\nreturn cnt == 3;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nbool isThree(int n) {\nint cnt = 0;\nfor (int i = 2; i < n; ++i) {\ncnt += n % i == 0;\n}\nreturn cnt == 1;\n}\n};\n", "\nclass Solution {\npublic:\nbool isThree(int n) {\nint cnt = 0;\nfor (int i = 1; i <= n / i; ++i) {\nif (n % i == 0) {\ncnt += n / i == i ? 1 : 2;\n}\n}\nreturn cnt == 3;\n}\n};\n"]}, {"leetCodeID": "1991", "level": "easy", "question_description": "Given a 0-indexed integer array nums, find the leftmost middleIndex (i.e., the smallest amongst all the possible ones).\nA middleIndex is an index where nums[0] + nums[1] + ... + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1].\nIf middleIndex == 0, the left side sum is considered to be 0. Similarly, if middleIndex == nums.length - 1, the right side sum is considered to be 0.\nReturn the leftmost middleIndex that satisfies the condition, or -1 if there is no such index.", "examples": ["Example 1:\nInput: nums = [2,3,-1,8,4]\nOutput: 3\nExplanation: The sum of the numbers before index 3 is: 2 + 3 + -1 = 4\nThe sum of the numbers after index 3 is: 4 = 4\n", "Example 2:\nInput: nums = [1,-1,4]\nOutput: 2\nExplanation: The sum of the numbers before index 2 is: 1 + -1 = 0\nThe sum of the numbers after index 2 is: 0\n", "Example 3:\nInput: nums = [2,5]\nOutput: -1\nExplanation: There is no valid middleIndex.\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 100\n-1000 <= nums[i] <= 1000\n", "java_context": "\nclass Solution {\n    public int findMiddleIndex(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar findMiddleIndex = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int findMiddleIndex(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int findMiddleIndex(int[] nums) {\nint left = 0, right = Arrays.stream(nums).sum();\nfor (int i = 0; i < nums.length; ++i) {\nright -= nums[i];\nif (left == right) {\nreturn i;\n}\nleft += nums[i];\n}\nreturn -1;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar findMiddleIndex = function (nums) {\nlet left = 0,\nright = nums.reduce((a, b) => a + b);\nfor (let i = 0; i < nums.length; ++i) {\nright -= nums[i];\nif (left == right) {\nreturn i;\n}\nleft += nums[i];\n}\nreturn -1;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint findMiddleIndex(vector<int>& nums) {\nint left = 0, right = accumulate(nums.begin(), nums.end(), 0);\nfor (int i = 0; i < nums.size(); ++i) {\nright -= nums[i];\nif (left == right) {\nreturn i;\n}\nleft += nums[i];\n}\nreturn -1;\n}\n};\n"]}, {"leetCodeID": "2011", "level": "easy", "question_description": "There is a programming language with only four operations and one variable X:\n++X and X++ increments the value of the variable X by 1.\n--X and X-- decrements the value of the variable X by 1.\nInitially, the value of X is 0.\nGiven an array of strings operations containing a list of operations, return the final value of X after performing all the operations.", "examples": ["Example 1:\nInput: operations = [&quot;--X&quot;,&quot;X++&quot;,&quot;X++&quot;]\nOutput: 1\nExplanation:&nbsp;The operations are performed as follows:\nInitially, X = 0.\n--X: X is decremented by 1, X =  0 - 1 = -1.\nX++: X is incremented by 1, X = -1 + 1 =  0.\nX++: X is incremented by 1, X =  0 + 1 =  1.\n", "Example 2:\nInput: operations = [&quot;++X&quot;,&quot;++X&quot;,&quot;X++&quot;]\nOutput: 3\nExplanation: The operations are performed as follows:\nInitially, X = 0.\n++X: X is incremented by 1, X = 0 + 1 = 1.\n++X: X is incremented by 1, X = 1 + 1 = 2.\nX++: X is incremented by 1, X = 2 + 1 = 3.\n", "Example 3:\nInput: operations = [&quot;X++&quot;,&quot;++X&quot;,&quot;--X&quot;,&quot;X--&quot;]\nOutput: 0\nExplanation:&nbsp;The operations are performed as follows:\nInitially, X = 0.\nX++: X is incremented by 1, X = 0 + 1 = 1.\n++X: X is incremented by 1, X = 1 + 1 = 2.\n--X: X is decremented by 1, X = 2 - 1 = 1.\nX--: X is decremented by 1, X = 1 - 1 = 0.\n"], "constraints": "\nConstraints:\n1 <= operations.length <= 100\noperations[i] will be either &quot;++X&quot;, &quot;X++&quot;, &quot;--X&quot;, or &quot;X--&quot;.\n", "java_context": "\nclass Solution {\n    public int finalValueAfterOperations(String[] operations) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string[]} operations\n* @return {number}\n*/\nvar finalValueAfterOperations = function (operations) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int finalValueAfterOperations(vector<string>& operations) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int finalValueAfterOperations(String[] operations) {\nint ans = 0;\nfor (var s : operations) {\nans += (s.charAt(1) == '+' ? 1 : -1);\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string[]} operations\n* @return {number}\n*/\nvar finalValueAfterOperations = function (operations) {\nlet ans = 0;\nfor (const s of operations) {\nans += s[1] === '+' ? 1 : -1;\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint finalValueAfterOperations(vector<string>& operations) {\nint ans = 0;\nfor (auto& s : operations) ans += (s[1] == '+' ? 1 : -1);\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "2016", "level": "easy", "question_description": "Given a 0-indexed integer array nums of size n, find the maximum difference between nums[i] and nums[j] (i.e., nums[j] - nums[i]), such that 0 &lt;= i &lt; j &lt; n and nums[i] &lt; nums[j].\nReturn the maximum difference. If no such i and j exists, return -1.", "examples": ["Example 1:\nInput: nums = [7,1,5,4]\nOutput: 4\nExplanation:\nThe maximum difference occurs with i = 1 and j = 2, nums[j] - nums[i] = 5 - 1 = 4.\nNote that with i = 1 and j = 0, the difference nums[j] - nums[i] = 7 - 1 = 6, but i &gt; j, so it is not valid.\n", "Example 2:\nInput: nums = [9,4,3,2]\nOutput: -1\nExplanation:\nThere is no i and j such that i &lt; j and nums[i] &lt; nums[j].\n", "Example 3:\nInput: nums = [1,5,2,10]\nOutput: 9\nExplanation:\nThe maximum difference occurs with i = 0 and j = 3, nums[j] - nums[i] = 10 - 1 = 9.\n"], "constraints": "\nConstraints:\nn == nums.length\n2 <= n <= 1000\n1 <= nums[i] <= 109\n", "java_context": "\nclass Solution {\n    public int maximumDifference(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar maximumDifference = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int maximumDifference(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int maximumDifference(int[] nums) {\nint mi = 1 << 30;\nint ans = -1;\nfor (int x : nums) {\nif (x > mi) {\nans = Math.max(ans, x - mi);\n} else {\nmi = x;\n}\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar maximumDifference = function (nums) {\nlet mi = 1 << 30;\nlet ans = -1;\nfor (const x of nums) {\nif (mi < x) {\nans = Math.max(ans, x - mi);\n} else {\nmi = x;\n}\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint maximumDifference(vector<int>& nums) {\nint mi = 1 << 30;\nint ans = -1;\nfor (int& x : nums) {\nif (x > mi) {\nans = max(ans, x - mi);\n} else {\nmi = x;\n}\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "2022", "level": "easy", "question_description": "You are given a 0-indexed 1-dimensional (1D) integer array original, and two integers, m and n. You are tasked with creating a 2-dimensional (2D) array with  m rows and n columns using all the elements from original.\nThe elements from indices 0 to n - 1 (inclusive) of original should form the first row of the constructed 2D array, the elements from indices n to 2 * n - 1 (inclusive) should form the second row of the constructed 2D array, and so on.\nReturn an m x n 2D array constructed according to the above procedure, or an empty 2D array if it is impossible.", "examples": ["Example 1:\n\n\nInput: original = [1,2,3,4], m = 2, n = 2\nOutput: [[1,2],[3,4]]\nExplanation: The constructed 2D array should contain 2 rows and 2 columns.\nThe first group of n=2 elements in original, [1,2], becomes the first row in the constructed 2D array.\nThe second group of n=2 elements in original, [3,4], becomes the second row in the constructed 2D array.\n\n\nExample 2:\nInput: original = [1,2,3], m = 1, n = 3\nOutput: [[1,2,3]]\nExplanation: The constructed 2D array should contain 1 row and 3 columns.\nPut all three elements in original into the first row of the constructed 2D array.\n", "Example 3:\nInput: original = [1,2], m = 1, n = 1\nOutput: []\nExplanation: There are 2 elements in original.\nIt is impossible to fit 2 elements in a 1x1 2D array, so return an empty 2D array.\n"], "constraints": "\nConstraints:\n1 <= original.length <= 5 * 104\n1 <= original[i] <= 105\n1 <= m, n <= 4 * 104\n", "java_context": "\nclass Solution {\n    public int[][] construct2DArray(int[] original, int m, int n) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} original\n* @param {number} m\n* @param {number} n\n* @return {number[][]}\n*/\nvar construct2DArray = function (original, m, n) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<vector<int>> construct2DArray(vector<int>& original, int m, int n) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int[][] construct2DArray(int[] original, int m, int n) {\nif (m * n != original.length) {\nreturn new int[0][0];\n}\nint[][] ans = new int[m][n];\nfor (int i = 0; i < m; ++i) {\nfor (int j = 0; j < n; ++j) {\nans[i][j] = original[i * n + j];\n}\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} original\n* @param {number} m\n* @param {number} n\n* @return {number[][]}\n*/\nvar construct2DArray = function (original, m, n) {\nif (m * n != original.length) {\nreturn [];\n}\nconst ans = [];\nfor (let i = 0; i < m * n; i += n) {\nans.push(original.slice(i, i + n));\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<vector<int>> construct2DArray(vector<int>& original, int m, int n) {\nif (m * n != original.size()) {\nreturn {};\n}\nvector<vector<int>> ans(m, vector<int>(n));\nfor (int i = 0; i < m; ++i) {\nfor (int j = 0; j < n; ++j) {\nans[i][j] = original[i * n + j];\n}\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "2068", "level": "easy", "question_description": "Two strings word1 and word2 are considered almost equivalent if the differences between the frequencies of each letter from &#39;a&#39; to &#39;z&#39; between word1 and word2 is at most 3.\nGiven two strings word1 and word2, each of length n, return true if word1 and word2 are almost equivalent, or false otherwise.\nThe frequency of a letter x is the number of times it occurs in the string.", "examples": ["Example 1:\nInput: word1 = &quot;aaaa&quot;, word2 = &quot;bccb&quot;\nOutput: false\nExplanation: There are 4 &#39;a&#39;s in &quot;aaaa&quot; but 0 &#39;a&#39;s in &quot;bccb&quot;.\nThe difference is 4, which is more than the allowed 3.\n", "Example 2:\nInput: word1 = &quot;abcdeef&quot;, word2 = &quot;abaaacc&quot;\nOutput: true\nExplanation: The differences between the frequencies of each letter in word1 and word2 are at most 3:\n- &#39;a&#39; appears 1 time in word1 and 4 times in word2. The difference is 3.\n- &#39;b&#39; appears 1 time in word1 and 1 time in word2. The difference is 0.\n- &#39;c&#39; appears 1 time in word1 and 2 times in word2. The difference is 1.\n- &#39;d&#39; appears 1 time in word1 and 0 times in word2. The difference is 1.\n- &#39;e&#39; appears 2 times in word1 and 0 times in word2. The difference is 2.\n- &#39;f&#39; appears 1 time in word1 and 0 times in word2. The difference is 1.\n", "Example 3:\nInput: word1 = &quot;cccddabba&quot;, word2 = &quot;babababab&quot;\nOutput: true\nExplanation: The differences between the frequencies of each letter in word1 and word2 are at most 3:\n- &#39;a&#39; appears 2 times in word1 and 4 times in word2. The difference is 2.\n- &#39;b&#39; appears 2 times in word1 and 5 times in word2. The difference is 3.\n- &#39;c&#39; appears 3 times in word1 and 0 times in word2. The difference is 3.\n- &#39;d&#39; appears 2 times in word1 and 0 times in word2. The difference is 2.\n"], "constraints": "\nConstraints:\nn == word1.length == word2.length\n1 <= n <= 100\nword1 and word2 consist only of lowercase English letters.\n", "java_context": "\nclass Solution {\n    public boolean checkAlmostEquivalent(String word1, String word2) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} word1\n* @param {string} word2\n* @return {boolean}\n*/\nvar checkAlmostEquivalent = function (word1, word2) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    bool checkAlmostEquivalent(string word1, string word2) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic boolean checkAlmostEquivalent(String word1, String word2) {\nint[] cnt = new int[26];\nfor (int i = 0; i < word1.length(); ++i) {\n++cnt[word1.charAt(i) - 'a'];\n}\nfor (int i = 0; i < word2.length(); ++i) {\n--cnt[word2.charAt(i) - 'a'];\n}\nfor (int x : cnt) {\nif (Math.abs(x) > 3) {\nreturn false;\n}\n}\nreturn true;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} word1\n* @param {string} word2\n* @return {boolean}\n*/\nvar checkAlmostEquivalent = function (word1, word2) {\nconst m = new Map();\nfor (let i = 0; i < word1.length; i++) {\nm.set(word1[i], (m.get(word1[i]) || 0) + 1);\nm.set(word2[i], (m.get(word2[i]) || 0) - 1);\n}\nfor (const v of m.values()) {\nif (Math.abs(v) > 3) {\nreturn false;\n}\n}\nreturn true;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nbool checkAlmostEquivalent(string word1, string word2) {\nint cnt[26]{};\nfor (char& c : word1) {\n++cnt[c - 'a'];\n}\nfor (char& c : word2) {\n--cnt[c - 'a'];\n}\nfor (int i = 0; i < 26; ++i) {\nif (abs(cnt[i]) > 3) {\nreturn false;\n}\n}\nreturn true;\n}\n};\n"]}, {"leetCodeID": "2215", "level": "easy", "question_description": "Given two 0-indexed integer arrays nums1 and nums2, return a list answer of size 2 where:\nanswer[0] is a list of all distinct integers in nums1 which are not present in nums2.\nanswer[1] is a list of all distinct integers in nums2 which are not present in nums1.\nNote that the integers in the lists may be returned in any order.", "examples": ["Example 1:\nInput: nums1 = [1,2,3], nums2 = [2,4,6]\nOutput: [[1,3],[4,6]]\nExplanation:\nFor nums1, nums1[1] = 2 is present at index 0 of nums2, whereas nums1[0] = 1 and nums1[2] = 3 are not present in nums2. Therefore, answer[0] = [1,3].\nFor nums2, nums2[0] = 2 is present at index 1 of nums1, whereas nums2[1] = 4 and nums2[2] = 6 are not present in nums2. Therefore, answer[1] = [4,6].", "Example 2:\nInput: nums1 = [1,2,3,3], nums2 = [1,1,2,2]\nOutput: [[3],[]]\nExplanation:\nFor nums1, nums1[2] and nums1[3] are not present in nums2. Since nums1[2] == nums1[3], their value is only included once and answer[0] = [3].\nEvery integer in nums2 is present in nums1. Therefore, answer[1] = [].\n"], "constraints": "\nConstraints:\n1 <= nums1.length, nums2.length <= 1000\n-1000 <= nums1[i], nums2[i] <= 1000\n", "java_context": "\nclass Solution {\n    public List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums1\n* @param {number[]} nums2\n* @return {number[][]}\n*/\nvar findDifference = function (nums1, nums2) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic List<List<Integer>> findDifference(int[] nums1, int[] nums2) {\nSet<Integer> s1 = convert(nums1);\nSet<Integer> s2 = convert(nums2);\nList<Integer> l1 = new ArrayList<>();\nList<Integer> l2 = new ArrayList<>();\nfor (int v : s1) {\nif (!s2.contains(v)) {\nl1.add(v);\n}\n}\nfor (int v : s2) {\nif (!s1.contains(v)) {\nl2.add(v);\n}\n}\nreturn List.of(l1, l2);\n}\n\nprivate Set<Integer> convert(int[] nums) {\nSet<Integer> s = new HashSet<>();\nfor (int v : nums) {\ns.add(v);\n}\nreturn s;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums1\n* @param {number[]} nums2\n* @return {number[][]}\n*/\nvar findDifference = function (nums1, nums2) {\nconst s1 = new Set(nums1);\nconst s2 = new Set(nums2);\nnums1.forEach(num => s2.delete(num));\nnums2.forEach(num => s1.delete(num));\nreturn [Array.from(s1), Array.from(s2)];\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {\nunordered_set<int> s1(nums1.begin(), nums1.end());\nunordered_set<int> s2(nums2.begin(), nums2.end());\nvector<vector<int>> ans(2);\nfor (int v : s1) {\nif (!s2.contains(v)) {\nans[0].push_back(v);\n}\n}\nfor (int v : s2) {\nif (!s1.contains(v)) {\nans[1].push_back(v);\n}\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "2309", "level": "easy", "question_description": "Given a string of English letters s, return the greatest English letter which occurs as both a lowercase and uppercase letter in s. The returned letter should be in uppercase. If no such letter exists, return an empty string.\nAn English letter b is greater than another letter a if b appears after a in the English alphabet.", "examples": ["Example 1:\nInput: s = &quot;lEeTcOdE&quot;\nOutput: &quot;E&quot;\nExplanation:\nThe letter &#39;E&#39; is the only letter to appear in both lower and upper case.\n", "Example 2:\nInput: s = &quot;arRAzFif&quot;\nOutput: &quot;R&quot;\nExplanation:\nThe letter &#39;R&#39; is the greatest letter to appear in both lower and upper case.\nNote that &#39;A&#39; and &#39;F&#39; also appear in both lower and upper case, but &#39;R&#39; is greater than &#39;F&#39; or &#39;A&#39;.\n", "Example 3:\nInput: s = &quot;AbCdEfGhIjK&quot;\nOutput: &quot;&quot;\nExplanation:\nThere is no letter that appears in both lower and upper case.\n"], "constraints": "\nConstraints:\n1 <= s.length <= 1000\ns consists of lowercase and uppercase English letters.\n", "java_context": "\nclass Solution {\n    public String greatestLetter(String s) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} s\n* @return {string}\n*/\nvar greatestLetter = function (s) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    string greatestLetter(string s) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic String greatestLetter(String s) {\nSet<Character> ss = new HashSet<>();\nfor (char c : s.toCharArray()) {\nss.add(c);\n}\nfor (char a = 'Z'; a >= 'A'; --a) {\nif (ss.contains(a) && ss.contains((char) (a + 32))) {\nreturn String.valueOf(a);\n}\n}\nreturn \"\";\n}\n}\n", "\nclass Solution {\npublic String greatestLetter(String s) {\nint mask1 = 0, mask2 = 0;\nfor (int i = 0; i < s.length(); ++i) {\nchar c = s.charAt(i);\nif (Character.isLowerCase(c)) {\nmask1 |= 1 << (c - 'a');\n} else {\nmask2 |= 1 << (c - 'A');\n}\n}\nint mask = mask1 & mask2;\nreturn mask > 0 ? String.valueOf((char) (31 - Integer.numberOfLeadingZeros(mask) + 'A'))\n: \"\";\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} s\n* @return {string}\n*/\nvar greatestLetter = function (s) {\nconst ss = new Array(128).fill(false);\nfor (const c of s) {\nss[c.charCodeAt(0)] = true;\n}\nfor (let i = 90; i >= 65; --i) {\nif (ss[i] && ss[i + 32]) {\nreturn String.fromCharCode(i);\n}\n}\nreturn '';\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nstring greatestLetter(string s) {\nunordered_set<char> ss(s.begin(), s.end());\nfor (char c = 'Z'; c >= 'A'; --c) {\nif (ss.count(c) && ss.count(char(c + 32))) {\nreturn string(1, c);\n}\n}\nreturn \"\";\n}\n};\n", "\nclass Solution {\npublic:\nstring greatestLetter(string s) {\nint mask1 = 0, mask2 = 0;\nfor (char& c : s) {\nif (islower(c)) {\nmask1 |= 1 << (c - 'a');\n} else {\nmask2 |= 1 << (c - 'A');\n}\n}\nint mask = mask1 & mask2;\nreturn mask ? string(1, 31 - __builtin_clz(mask) + 'A') : \"\";\n}\n};\n"]}, {"leetCodeID": "2341", "level": "easy", "question_description": "You are given a 0-indexed integer array nums. In one operation, you may do the following:\nChoose two integers in nums that are equal.\nRemove both integers from nums, forming a pair.\nThe operation is done on nums as many times as possible.\nReturn a 0-indexed integer array answer of size 2 where answer[0] is the number of pairs that are formed and answer[1] is the number of leftover integers in nums after doing the operation as many times as possible.", "examples": ["Example 1:\nInput: nums = [1,3,2,1,3,2,2]\nOutput: [3,1]\nExplanation:\nForm a pair with nums[0] and nums[3] and remove them from nums. Now, nums = [3,2,3,2,2].\nForm a pair with nums[0] and nums[2] and remove them from nums. Now, nums = [2,2,2].\nForm a pair with nums[0] and nums[1] and remove them from nums. Now, nums = [2].\nNo more pairs can be formed. A total of 3 pairs have been formed, and there is 1 number leftover in nums.\n", "Example 2:\nInput: nums = [1,1]\nOutput: [1,0]\nExplanation: Form a pair with nums[0] and nums[1] and remove them from nums. Now, nums = [].\nNo more pairs can be formed. A total of 1 pair has been formed, and there are 0 numbers leftover in nums.\n", "Example 3:\nInput: nums = [0]\nOutput: [0,1]\nExplanation: No pairs can be formed, and there is 1 number leftover in nums.\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 100\n0 <= nums[i] <= 100\n", "java_context": "\nclass Solution {\n    public int[] numberOfPairs(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number[]}\n*/\nvar numberOfPairs = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> numberOfPairs(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int[] numberOfPairs(int[] nums) {\nint[] cnt = new int[101];\nfor (int x : nums) {\n++cnt[x];\n}\nint s = 0;\nfor (int v : cnt) {\ns += v / 2;\n}\nreturn new int[] {s, nums.length - s * 2};\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number[]}\n*/\nvar numberOfPairs = function (nums) {\nconst cnt = new Array(101).fill(0);\nfor (const x of nums) {\n++cnt[x];\n}\nconst s = cnt.reduce((a, b) => a + (b >> 1), 0);\nreturn [s, nums.length - s * 2];\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> numberOfPairs(vector<int>& nums) {\nvector<int> cnt(101);\nfor (int& x : nums) {\n++cnt[x];\n}\nint s = 0;\nfor (int& v : cnt) {\ns += v >> 1;\n}\nreturn {s, (int) nums.size() - s * 2};\n}\n};\n"]}, {"leetCodeID": "2490", "level": "easy", "question_description": "A sentence is a list of words that are separated by a single space with no leading or trailing spaces.\nFor example, &quot;Hello World&quot;, &quot;HELLO&quot;, &quot;hello world hello world&quot; are all sentences.\nWords consist of only uppercase and lowercase English letters. Uppercase and lowercase English letters are considered different.\nA sentence is circular if:\nThe last character of a word is equal to the first character of the next word.\nThe last character of the last word is equal to the first character of the first word.\nFor example, &quot;leetcode exercises sound delightful&quot;, &quot;eetcode&quot;, &quot;leetcode eats soul&quot; are all circular sentences. However, &quot;Leetcode is cool&quot;, &quot;happy Leetcode&quot;, &quot;Leetcode&quot; and &quot;I like Leetcode&quot; are not circular sentences.\nGiven a string sentence, return true if it is circular. Otherwise, return false.", "examples": ["Example 1:\nInput: sentence = &quot;leetcode exercises sound delightful&quot;\nOutput: true\nExplanation: The words in sentence are [&quot;leetcode&quot;, &quot;exercises&quot;, &quot;sound&quot;, &quot;delightful&quot;].\n- leetcode&#39;s&nbsp;last character is equal to exercises&#39;s first character.\n- exercises&#39;s&nbsp;last character is equal to sound&#39;s first character.\n- sound&#39;s&nbsp;last character is equal to delightful&#39;s first character.\n- delightful&#39;s&nbsp;last character is equal to leetcode&#39;s first character.\nThe sentence is circular.", "Example 2:\nInput: sentence = &quot;eetcode&quot;\nOutput: true\nExplanation: The words in sentence are [&quot;eetcode&quot;].\n- eetcode&#39;s&nbsp;last character is equal to eetcode&#39;s first character.\nThe sentence is circular.", "Example 3:\nInput: sentence = &quot;Leetcode is cool&quot;\nOutput: false\nExplanation: The words in sentence are [&quot;Leetcode&quot;, &quot;is&quot;, &quot;cool&quot;].\n- Leetcode&#39;s&nbsp;last character is not equal to is&#39;s first character.\nThe sentence is not circular."], "constraints": "\nConstraints:\n1 <= sentence.length <= 500\nsentence consist of only lowercase and uppercase English letters and spaces.\nThe words in sentence are separated by a single space.\nThere are no leading or trailing spaces.\n", "java_context": "\nclass Solution {\n    public boolean isCircularSentence(String sentence) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} sentence\n* @return {boolean}\n*/\nvar isCircularSentence = function (sentence) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    bool isCircularSentence(string sentence) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic boolean isCircularSentence(String sentence) {\nvar ss = sentence.split(\" \");\nint n = ss.length;\nfor (int i = 0; i < n; ++i) {\nif (ss[i].charAt(ss[i].length() - 1) != ss[(i + 1) % n].charAt(0)) {\nreturn false;\n}\n}\nreturn true;\n}\n}\n", "\nclass Solution {\npublic boolean isCircularSentence(String s) {\nint n = s.length();\nif (s.charAt(0) != s.charAt(n - 1)) {\nreturn false;\n}\nfor (int i = 1; i < n; ++i) {\nif (s.charAt(i) == ' ' && s.charAt(i - 1) != s.charAt(i + 1)) {\nreturn false;\n}\n}\nreturn true;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} sentence\n* @return {boolean}\n*/\nvar isCircularSentence = function (sentence) {\nconst ss = sentence.split(' ');\nconst n = ss.length;\nfor (let i = 0; i < n; ++i) {\nif (ss[i][ss[i].length - 1] !== ss[(i + 1) % n][0]) {\nreturn false;\n}\n}\nreturn true;\n};\n", "\n/**\n* @param {string} s\n* @return {boolean}\n*/\nvar isCircularSentence = function (s) {\nconst n = s.length;\nif (s[0] !== s[n - 1]) {\nreturn false;\n}\nfor (let i = 1; i < n; ++i) {\nif (s[i] === ' ' && s[i - 1] !== s[i + 1]) {\nreturn false;\n}\n}\nreturn true;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nbool isCircularSentence(string sentence) {\nauto ss = split(sentence, ' ');\nint n = ss.size();\nfor (int i = 0; i < n; ++i) {\nif (ss[i].back() != ss[(i + 1) % n][0]) {\nreturn false;\n}\n}\nreturn true;\n}\n\nvector<string> split(string& s, char delim) {\nstringstream ss(s);\nstring item;\nvector<string> res;\nwhile (getline(ss, item, delim)) {\nres.emplace_back(item);\n}\nreturn res;\n}\n};\n", "\nclass Solution {\npublic:\nbool isCircularSentence(string s) {\nint n = s.size();\nif (s[0] != s.back()) {\nreturn false;\n}\nfor (int i = 1; i < n; ++i) {\nif (s[i] == ' ' && s[i - 1] != s[i + 1]) {\nreturn false;\n}\n}\nreturn true;\n}\n};\n"]}, {"leetCodeID": "2739", "level": "easy", "question_description": "A truck has two fuel tanks. You are given two integers, mainTank representing the fuel present in the main tank in liters and additionalTank representing the fuel present in the additional tank in liters.\nThe truck has a mileage of 10 km per liter. Whenever 5 liters of fuel get used up in the main tank, if the additional tank has at least 1 liters of fuel, 1 liters of fuel will be transferred from the additional tank to the main tank.\nReturn the maximum distance which can be traveled.\nNote: Injection from the additional tank is not continuous. It happens suddenly and immediately for every 5 liters consumed.", "examples": ["Example 1:\nInput: mainTank = 5, additionalTank = 10\nOutput: 60\nExplanation:\nAfter spending 5 litre of fuel, fuel remaining is (5 - 5 + 1) = 1 litre and distance traveled is 50km.\nAfter spending another 1 litre of fuel, no fuel gets injected in the main tank and the main tank becomes empty.\nTotal distance traveled is 60km.\n", "Example 2:\nInput: mainTank = 1, additionalTank = 2\nOutput: 10\nExplanation:\nAfter spending 1 litre of fuel, the main tank becomes empty.\nTotal distance traveled is 10km.\n\n"], "constraints": "\nConstraints:\n1 <= mainTank, additionalTank <= 100\n", "java_context": "\nclass Solution {\n    public int distanceTraveled(int mainTank, int additionalTank) {\n        // your code\n    }\n}", "js_context": "\nvar distanceTraveled = function (mainTank, additionalTank) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int distanceTraveled(int mainTank, int additionalTank) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int distanceTraveled(int mainTank, int additionalTank) {\nint ans = 0, cur = 0;\nwhile (mainTank > 0) {\ncur++;\nans += 10;\nmainTank--;\nif (cur % 5 == 0 && additionalTank > 0) {\nadditionalTank--;\nmainTank++;\n}\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\nvar distanceTraveled = function (mainTank, additionalTank) {\nlet ans = 0,\ncur = 0;\nwhile (mainTank) {\ncur++;\nans += 10;\nmainTank--;\nif (cur % 5 === 0 && additionalTank) {\nadditionalTank--;\nmainTank++;\n}\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint distanceTraveled(int mainTank, int additionalTank) {\nint ans = 0, cur = 0;\nwhile (mainTank > 0) {\ncur++;\nans += 10;\nmainTank--;\nif (cur % 5 == 0 && additionalTank > 0) {\nadditionalTank--;\nmainTank++;\n}\n}\nreturn ans;\n}\n};\n"]}]