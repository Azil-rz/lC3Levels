[{"leetCodeID": "0002", "level": "middle", "question_description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.", "examples": ["Example 1:\n\n\nInput: l1 = [2,4,3], l2 = [5,6,4]\nOutput: [7,0,8]\nExplanation: 342 + 465 = 807.\n\n\nExample 2:\nInput: l1 = [0], l2 = [0]\nOutput: [0]\n", "Example 3:\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\nOutput: [8,9,9,9,0,0,0,1]\n"], "constraints": "\nConstraints:\nThe number of nodes in each linked list is in the range [1, 100].\n0 <= Node.val <= 9\nIt is guaranteed that the list represents a number that does not have leading zeros.\n", "java_context": "\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode() {}\n*     ListNode(int val) { this.val = val; }\n*     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n* }\n*/\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for singly-linked list.\n* function ListNode(val, next) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.next = (next===undefined ? null : next)\n* }\n*/\n/**\n* @param {ListNode} l1\n* @param {ListNode} l2\n* @return {ListNode}\n*/\nvar addTwoNumbers = function (l1, l2) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode() {}\n*     ListNode(int val) { this.val = val; }\n*     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n* }\n*/\nclass Solution {\npublic ListNode addTwoNumbers(ListNode l1, ListNode l2) {\nListNode dummy = new ListNode(0);\nint carry = 0;\nListNode cur = dummy;\nwhile (l1 != null || l2 != null || carry != 0) {\nint s = (l1 == null ? 0 : l1.val) + (l2 == null ? 0 : l2.val) + carry;\ncarry = s / 10;\ncur.next = new ListNode(s % 10);\ncur = cur.next;\nl1 = l1 == null ? null : l1.next;\nl2 = l2 == null ? null : l2.next;\n}\nreturn dummy.next;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for singly-linked list.\n* function ListNode(val, next) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.next = (next===undefined ? null : next)\n* }\n*/\n/**\n* @param {ListNode} l1\n* @param {ListNode} l2\n* @return {ListNode}\n*/\nvar addTwoNumbers = function (l1, l2) {\nconst dummy = new ListNode();\nlet carry = 0;\nlet cur = dummy;\nwhile (l1 || l2 || carry) {\nconst s = (l1?.val || 0) + (l2?.val || 0) + carry;\ncarry = Math.floor(s / 10);\ncur.next = new ListNode(s % 10);\ncur = cur.next;\nl1 = l1?.next;\nl2 = l2?.next;\n}\nreturn dummy.next;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\nclass Solution {\npublic:\nListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\nListNode* dummy = new ListNode();\nint carry = 0;\nListNode* cur = dummy;\nwhile (l1 || l2 || carry) {\nint s = (l1 ? l1->val : 0) + (l2 ? l2->val : 0) + carry;\ncarry = s / 10;\ncur->next = new ListNode(s % 10);\ncur = cur->next;\nl1 = l1 ? l1->next : nullptr;\nl2 = l2 ? l2->next : nullptr;\n}\nreturn dummy->next;\n}\n};\n"]}, {"leetCodeID": "0003", "level": "middle", "question_description": "Given a string s, find the length of the longest substring without repeating characters.", "examples": ["Example 1:\nInput: s = &quot;abcabcbb&quot;\nOutput: 3\nExplanation: The answer is &quot;abc&quot;, with the length of 3.\n", "Example 2:\nInput: s = &quot;bbbbb&quot;\nOutput: 1\nExplanation: The answer is &quot;b&quot;, with the length of 1.\n", "Example 3:\nInput: s = &quot;pwwkew&quot;\nOutput: 3\nExplanation: The answer is &quot;wke&quot;, with the length of 3.\nNotice that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.\n"], "constraints": "\nConstraints:\n0 <= s.length <= 5 * 104\ns consists of English letters, digits, symbols and spaces.\n", "java_context": "    \n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} s\n* @return {number}\n*/\nvar lengthOfLongestSubstring = function (s) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        // your code\n    }\n};", "java_solutions": ["\nfor (int i = 0, j = 0; i < n; ++i) {\nwhile (j < i && check(j, i)) {\n++j;\n}\n// logic of specific problem\n}\n", "\nclass Solution {\npublic int lengthOfLongestSubstring(String s) {\nboolean[] ss = new boolean[128];\nint ans = 0;\nfor (int i = 0, j = 0; j < s.length(); ++j) {\nchar c = s.charAt(j);\nwhile (ss[c]) {\nss[s.charAt(i++)] = false;\n}\nss[c] = true;\nans = Math.max(ans, j - i + 1);\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} s\n* @return {number}\n*/\nvar lengthOfLongestSubstring = function (s) {\nlet ans = 0;\nconst ss = new Set();\nfor (let i = 0, j = 0; j < s.length; ++j) {\nwhile (ss.has(s[j])) {\nss.delete(s[i++]);\n}\nss.add(s[j]);\nans = Math.max(ans, j - i + 1);\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint lengthOfLongestSubstring(string s) {\nbool ss[128]{};\nint ans = 0;\nfor (int i = 0, j = 0; j < s.size(); ++j) {\nwhile (ss[s[j]]) {\nss[s[i++]] = false;\n}\nss[s[j]] = true;\nans = max(ans, j - i + 1);\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0005", "level": "middle", "question_description": "Given a string s, return the longest palindromic substring in s.", "examples": ["Example 1:\nInput: s = &quot;babad&quot;\nOutput: &quot;bab&quot;\nExplanation: &quot;aba&quot; is also a valid answer.\n", "Example 2:\nInput: s = &quot;cbbd&quot;\nOutput: &quot;bb&quot;\n"], "constraints": "\nConstraints:\n1 <= s.length <= 1000\ns consist of only digits and English letters.\n", "java_context": "\nclass Solution {\n    public String longestPalindrome(String s) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} s\n* @return {string}\n*/\nvar longestPalindrome = function (s) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    string longestPalindrome(string s) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic String longestPalindrome(String s) {\nint n = s.length();\nboolean[][] f = new boolean[n][n];\nfor (var g : f) {\nArrays.fill(g, true);\n}\nint k = 0, mx = 1;\nfor (int i = n - 2; i >= 0; --i) {\nfor (int j = i + 1; j < n; ++j) {\nf[i][j] = false;\nif (s.charAt(i) == s.charAt(j)) {\nf[i][j] = f[i + 1][j - 1];\nif (f[i][j] && mx < j - i + 1) {\nmx = j - i + 1;\nk = i;\n}\n}\n}\n}\nreturn s.substring(k, k + mx);\n}\n}\n", "\nclass Solution {\nprivate String s;\nprivate int n;\n\npublic String longestPalindrome(String s) {\nthis.s = s;\nn = s.length();\nint start = 0, mx = 1;\nfor (int i = 0; i < n; ++i) {\nint a = f(i, i);\nint b = f(i, i + 1);\nint t = Math.max(a, b);\nif (mx < t) {\nmx = t;\nstart = i - ((t - 1) >> 1);\n}\n}\nreturn s.substring(start, start + mx);\n}\n\nprivate int f(int l, int r) {\nwhile (l >= 0 && r < n && s.charAt(l) == s.charAt(r)) {\n--l;\n++r;\n}\nreturn r - l - 1;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} s\n* @return {string}\n*/\nvar longestPalindrome = function (s) {\nconst n = s.length;\nconst f = Array(n)\n.fill(0)\n.map(() => Array(n).fill(true));\nlet k = 0;\nlet mx = 1;\nfor (let i = n - 2; i >= 0; --i) {\nfor (let j = i + 1; j < n; ++j) {\nf[i][j] = false;\nif (s[i] === s[j]) {\nf[i][j] = f[i + 1][j - 1];\nif (f[i][j] && mx < j - i + 1) {\nmx = j - i + 1;\nk = i;\n}\n}\n}\n}\nreturn s.slice(k, k + mx);\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nstring longestPalindrome(string s) {\nint n = s.size();\nvector<vector<bool>> f(n, vector<bool>(n, true));\nint k = 0, mx = 1;\nfor (int i = n - 2; ~i; --i) {\nfor (int j = i + 1; j < n; ++j) {\nf[i][j] = false;\nif (s[i] == s[j]) {\nf[i][j] = f[i + 1][j - 1];\nif (f[i][j] && mx < j - i + 1) {\nmx = j - i + 1;\nk = i;\n}\n}\n}\n}\nreturn s.substr(k, mx);\n}\n};\n", "\nclass Solution {\npublic:\nstring longestPalindrome(string s) {\nint n = s.size();\nint start = 0, mx = 1;\nauto f = [&](int l, int r) {\nwhile (l >= 0 && r < n && s[l] == s[r]) {\nl--, r++;\n}\nreturn r - l - 1;\n};\nfor (int i = 0; i < n; ++i) {\nint a = f(i, i);\nint b = f(i, i + 1);\nint t = max(a, b);\nif (mx < t) {\nmx = t;\nstart = i - (t - 1 >> 1);\n}\n}\nreturn s.substr(start, mx);\n}\n};\n"]}, {"leetCodeID": "0006", "level": "middle", "question_description": "The string &quot;PAYPALISHIRING&quot; is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\nP   A   H   N\nA P L S I I G\nY   I   R\nAnd then read line by line: &quot;PAHNAPLSIIGYIR&quot;\nWrite the code that will take a string and make this conversion given a number of rows:\nstring convert(string s, int numRows);", "examples": ["Example 1:\nInput: s = &quot;PAYPALISHIRING&quot;, numRows = 3\nOutput: &quot;PAHNAPLSIIGYIR&quot;\n", "Example 2:\nInput: s = &quot;PAYPALISHIRING&quot;, numRows = 4\nOutput: &quot;PINALSIGYAHRPI&quot;\nExplanation:\nP     I    N\nA   L S  I G\nY A   H R\nP     I\n", "Example 3:\nInput: s = &quot;A&quot;, numRows = 1\nOutput: &quot;A&quot;\n"], "constraints": "\nConstraints:\n1 <= s.length <= 1000\ns consists of English letters (lower-case and upper-case), &#39;,&#39; and &#39;.&#39;.\n1 <= numRows <= 1000\n", "java_context": "\nclass Solution {\n    public String convert(String s, int numRows) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} s\n* @param {number} numRows\n* @return {string}\n*/\nvar convert = function (s, numRows) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    string convert(string s, int numRows) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic String convert(String s, int numRows) {\nif (numRows == 1) {\nreturn s;\n}\nStringBuilder[] g = new StringBuilder[numRows];\nArrays.setAll(g, k -> new StringBuilder());\nint i = 0, k = -1;\nfor (char c : s.toCharArray()) {\ng[i].append(c);\nif (i == 0 || i == numRows - 1) {\nk = -k;\n}\ni += k;\n}\nreturn String.join(\"\", g);\n}\n}\n", "\nclass Solution {\npublic String convert(String s, int numRows) {\nif (numRows == 1) {\nreturn s;\n}\nStringBuilder ans = new StringBuilder();\nint group = 2 * numRows - 2;\nfor (int i = 1; i <= numRows; i++) {\nint interval = i == numRows ? group : 2 * numRows - 2 * i;\nint idx = i - 1;\nwhile (idx < s.length()) {\nans.append(s.charAt(idx));\nidx += interval;\ninterval = group - interval;\nif (interval == 0) {\ninterval = group;\n}\n}\n}\nreturn ans.toString();\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} s\n* @param {number} numRows\n* @return {string}\n*/\nvar convert = function (s, numRows) {\nif (numRows === 1) {\nreturn s;\n}\nconst g = new Array(numRows).fill(_).map(() => []);\nlet i = 0;\nlet k = -1;\nfor (const c of s) {\ng[i].push(c);\nif (i === 0 || i === numRows - 1) {\nk = -k;\n}\ni += k;\n}\nreturn g.flat().join('');\n};\n", "\n/**\n* @param {string} s\n* @param {number} numRows\n* @return {string}\n*/\nvar convert = function (s, numRows) {\nif (numRows == 1) return s;\nconst arr = new Array(numRows);\nfor (let i = 0; i < numRows; i++) arr[i] = [];\nlet mi = 0,\nisDown = true;\nfor (const c of s) {\narr[mi].push(c);\n\nif (mi >= numRows - 1) isDown = false;\nelse if (mi <= 0) isDown = true;\n\nif (isDown) mi++;\nelse mi--;\n}\nlet ans = [];\nfor (const item of arr) {\nans = ans.concat(item);\n}\nreturn ans.join('');\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nstring convert(string s, int numRows) {\nif (numRows == 1) {\nreturn s;\n}\nvector<string> g(numRows);\nint i = 0, k = -1;\nfor (char c : s) {\ng[i] += c;\nif (i == 0 || i == numRows - 1) {\nk = -k;\n}\ni += k;\n}\nstring ans;\nfor (auto& t : g) {\nans += t;\n}\nreturn ans;\n}\n};\n", "\nclass Solution {\npublic:\nstring convert(string s, int numRows) {\nif (numRows == 1) return s;\nstring ans;\nint group = 2 * numRows - 2;\nfor (int i = 1; i <= numRows; ++i) {\nint interval = i == numRows ? group : 2 * numRows - 2 * i;\nint idx = i - 1;\nwhile (idx < s.length()) {\nans.push_back(s[idx]);\nidx += interval;\ninterval = group - interval;\nif (interval == 0) interval = group;\n}\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0007", "level": "middle", "question_description": "Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).", "examples": ["Example 1:\nInput: x = 123\nOutput: 321\n", "Example 2:\nInput: x = -123\nOutput: -321\n", "Example 3:\nInput: x = 120\nOutput: 21\n"], "constraints": "\nConstraints:\n-231 <= x <= 231 - 1\n", "java_context": "\nclass Solution {\n    public int reverse(int x) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number} x\n* @return {number}\n*/\nvar reverse = function (x) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int reverse(int x) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int reverse(int x) {\nint ans = 0;\nfor (; x != 0; x /= 10) {\nif (ans < Integer.MIN_VALUE / 10 || ans > Integer.MAX_VALUE / 10) {\nreturn 0;\n}\nans = ans * 10 + x % 10;\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number} x\n* @return {number}\n*/\nvar reverse = function (x) {\nconst mi = -(2 ** 31);\nconst mx = 2 ** 31 - 1;\nlet ans = 0;\nfor (; x != 0; x = ~~(x / 10)) {\nif (ans < ~~(mi / 10) || ans > ~~(mx / 10)) {\nreturn 0;\n}\nans = ans * 10 + (x % 10);\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint reverse(int x) {\nint ans = 0;\nfor (; x; x /= 10) {\nif (ans < INT_MIN / 10 || ans > INT_MAX / 10) {\nreturn 0;\n}\nans = ans * 10 + x % 10;\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0011", "level": "middle", "question_description": "You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\nReturn the maximum amount of water a container can store.\nNotice that you may not slant the container.", "examples": ["Example 1:\n\n\nInput: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49\nExplanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.\n\n\nExample 2:\nInput: height = [1,1]\nOutput: 1\n"], "constraints": "\nConstraints:\nn == height.length\n2 <= n <= 105\n0 <= height[i] <= 104\n", "java_context": "\nclass Solution {\n    public int maxArea(int[] height) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} height\n* @return {number}\n*/\nvar maxArea = function (height) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int maxArea(vector<int>& height) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int maxArea(int[] height) {\nint i = 0, j = height.length - 1;\nint ans = 0;\nwhile (i < j) {\nint t = Math.min(height[i], height[j]) * (j - i);\nans = Math.max(ans, t);\nif (height[i] < height[j]) {\n++i;\n} else {\n--j;\n}\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} height\n* @return {number}\n*/\nvar maxArea = function (height) {\nlet i = 0;\nlet j = height.length - 1;\nlet ans = 0;\nwhile (i < j) {\nconst t = Math.min(height[i], height[j]) * (j - i);\nans = Math.max(ans, t);\nif (height[i] < height[j]) {\n++i;\n} else {\n--j;\n}\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint maxArea(vector<int>& height) {\nint i = 0, j = height.size() - 1;\nint ans = 0;\nwhile (i < j) {\nint t = min(height[i], height[j]) * (j - i);\nans = max(ans, t);\nif (height[i] < height[j]) {\n++i;\n} else {\n--j;\n}\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0015", "level": "middle", "question_description": "Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\nNotice that the solution set must not contain duplicate triplets.", "examples": ["Example 1:\nInput: nums = [-1,0,1,2,-1,-4]\nOutput: [[-1,-1,2],[-1,0,1]]\nExplanation:\nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\nNotice that the order of the output and the order of the triplets does not matter.\n", "Example 2:\nInput: nums = [0,1,1]\nOutput: []\nExplanation: The only possible triplet does not sum up to 0.\n", "Example 3:\nInput: nums = [0,0,0]\nOutput: [[0,0,0]]\nExplanation: The only possible triplet sums up to 0.\n"], "constraints": "\nConstraints:\n3 <= nums.length <= 3000\n-105 <= nums[i] <= 105\n", "java_context": "\nclass Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number[][]}\n*/\nvar threeSum = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic List<List<Integer>> threeSum(int[] nums) {\nArrays.sort(nums);\nList<List<Integer>> ans = new ArrayList<>();\nint n = nums.length;\nfor (int i = 0; i < n - 2 && nums[i] <= 0; ++i) {\nif (i > 0 && nums[i] == nums[i - 1]) {\ncontinue;\n}\nint j = i + 1, k = n - 1;\nwhile (j < k) {\nint x = nums[i] + nums[j] + nums[k];\nif (x < 0) {\n++j;\n} else if (x > 0) {\n--k;\n} else {\nans.add(List.of(nums[i], nums[j++], nums[k--]));\nwhile (j < k && nums[j] == nums[j - 1]) {\n++j;\n}\nwhile (j < k && nums[k] == nums[k + 1]) {\n--k;\n}\n}\n}\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number[][]}\n*/\nvar threeSum = function (nums) {\nconst n = nums.length;\nnums.sort((a, b) => a - b);\nconst ans = [];\nfor (let i = 0; i < n - 2 && nums[i] <= 0; ++i) {\nif (i > 0 && nums[i] === nums[i - 1]) {\ncontinue;\n}\nlet j = i + 1;\nlet k = n - 1;\nwhile (j < k) {\nconst x = nums[i] + nums[j] + nums[k];\nif (x < 0) {\n++j;\n} else if (x > 0) {\n--k;\n} else {\nans.push([nums[i], nums[j++], nums[k--]]);\nwhile (j < k && nums[j] === nums[j - 1]) {\n++j;\n}\nwhile (j < k && nums[k] === nums[k + 1]) {\n--k;\n}\n}\n}\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<vector<int>> threeSum(vector<int>& nums) {\nsort(nums.begin(), nums.end());\nvector<vector<int>> ans;\nint n = nums.size();\nfor (int i = 0; i < n - 2 && nums[i] <= 0; ++i) {\nif (i && nums[i] == nums[i - 1]) {\ncontinue;\n}\nint j = i + 1, k = n - 1;\nwhile (j < k) {\nint x = nums[i] + nums[j] + nums[k];\nif (x < 0) {\n++j;\n} else if (x > 0) {\n--k;\n} else {\nans.push_back({nums[i], nums[j++], nums[k--]});\nwhile (j < k && nums[j] == nums[j - 1]) {\n++j;\n}\nwhile (j < k && nums[k] == nums[k + 1]) {\n--k;\n}\n}\n}\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0016", "level": "middle", "question_description": "Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.\nReturn the sum of the three integers.\nYou may assume that each input would have exactly one solution.", "examples": ["Example 1:\nInput: nums = [-1,2,1,-4], target = 1\nOutput: 2\nExplanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\n", "Example 2:\nInput: nums = [0,0,0], target = 1\nOutput: 0\nExplanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0).\n"], "constraints": "\nConstraints:\n3 <= nums.length <= 500\n-1000 <= nums[i] <= 1000\n-104 <= target <= 104\n", "java_context": "\nclass Solution {\n    public int threeSumClosest(int[] nums, int target) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @param {number} target\n* @return {number}\n*/\nvar threeSumClosest = function (nums, target) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int threeSumClosest(vector<int>& nums, int target) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int threeSumClosest(int[] nums, int target) {\nArrays.sort(nums);\nint ans = 1 << 30;\nint n = nums.length;\nfor (int i = 0; i < n; ++i) {\nint j = i + 1, k = n - 1;\nwhile (j < k) {\nint t = nums[i] + nums[j] + nums[k];\nif (t == target) {\nreturn t;\n}\nif (Math.abs(t - target) < Math.abs(ans - target)) {\nans = t;\n}\nif (t > target) {\n--k;\n} else {\n++j;\n}\n}\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @param {number} target\n* @return {number}\n*/\nvar threeSumClosest = function (nums, target) {\nnums.sort((a, b) => a - b);\nlet ans = 1 << 30;\nconst n = nums.length;\nfor (let i = 0; i < n; ++i) {\nlet j = i + 1;\nlet k = n - 1;\nwhile (j < k) {\nconst t = nums[i] + nums[j] + nums[k];\nif (t === target) {\nreturn t;\n}\nif (Math.abs(t - target) < Math.abs(ans - target)) {\nans = t;\n}\nif (t > target) {\n--k;\n} else {\n++j;\n}\n}\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint threeSumClosest(vector<int>& nums, int target) {\nsort(nums.begin(), nums.end());\nint ans = 1 << 30;\nint n = nums.size();\nfor (int i = 0; i < n; ++i) {\nint j = i + 1, k = n - 1;\nwhile (j < k) {\nint t = nums[i] + nums[j] + nums[k];\nif (t == target) return t;\nif (abs(t - target) < abs(ans - target)) ans = t;\nif (t > target)\n--k;\nelse\n++j;\n}\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0017", "level": "middle", "question_description": "Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.\nA mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.", "examples": ["Example 1:\nInput: digits = &quot;23&quot;\nOutput: [&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]\n", "Example 2:\nInput: digits = &quot;&quot;\nOutput: []\n", "Example 3:\nInput: digits = &quot;2&quot;\nOutput: [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]\n"], "constraints": "\nConstraints:\n0 <= digits.length <= 4\ndigits[i] is a digit in the range [&#39;2&#39;, &#39;9&#39;].\n", "java_context": "\nclass Solution {\n    public List<String> letterCombinations(String digits) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} digits\n* @return {string[]}\n*/\nvar letterCombinations = function (digits) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<string> letterCombinations(string digits) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic List<String> letterCombinations(String digits) {\nList<String> ans = new ArrayList<>();\nif (digits.length() == 0) {\nreturn ans;\n}\nans.add(\"\");\nString[] d = new String[] {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\nfor (char i : digits.toCharArray()) {\nString s = d[i - '2'];\nList<String> t = new ArrayList<>();\nfor (String a : ans) {\nfor (String b : s.split(\"\")) {\nt.add(a + b);\n}\n}\nans = t;\n}\nreturn ans;\n}\n}\n", "\nclass Solution {\nprivate final String[] d = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\nprivate String digits;\nprivate List<String> ans = new ArrayList<>();\nprivate StringBuilder t = new StringBuilder();\n\npublic List<String> letterCombinations(String digits) {\nif (digits.length() == 0) {\nreturn ans;\n}\nthis.digits = digits;\ndfs(0);\nreturn ans;\n}\n\nprivate void dfs(int i) {\nif (i >= digits.length()) {\nans.add(t.toString());\nreturn;\n}\nString s = d[digits.charAt(i) - '2'];\nfor (char c : s.toCharArray()) {\nt.append(c);\ndfs(i + 1);\nt.deleteCharAt(t.length() - 1);\n}\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} digits\n* @return {string[]}\n*/\nvar letterCombinations = function (digits) {\nif (digits.length == 0) {\nreturn [];\n}\nconst ans = [''];\nconst d = ['abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz'];\nfor (const i of digits) {\nconst s = d[parseInt(i) - 2];\nconst t = [];\nfor (const a of ans) {\nfor (const b of s) {\nt.push(a + b);\n}\n}\nans.splice(0, ans.length, ...t);\n}\nreturn ans;\n};\n", "\n/**\n* @param {string} digits\n* @return {string[]}\n*/\nvar letterCombinations = function (digits) {\nif (digits.length == 0) {\nreturn [];\n}\nconst ans = [];\nconst t = [];\nconst d = ['abc', 'def', 'ghi', 'jkl', 'mno', 'pqrs', 'tuv', 'wxyz'];\nconst dfs = i => {\nif (i >= digits.length) {\nans.push(t.join(''));\nreturn;\n}\nconst s = d[parseInt(digits[i]) - 2];\nfor (const c of s) {\nt.push(c);\ndfs(i + 1);\nt.pop();\n}\n};\ndfs(0);\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<string> letterCombinations(string digits) {\nif (digits.empty()) {\nreturn {};\n}\nvector<string> d = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\nvector<string> ans = {\"\"};\nfor (auto& i : digits) {\nstring s = d[i - '2'];\nvector<string> t;\nfor (auto& a : ans) {\nfor (auto& b : s) {\nt.push_back(a + b);\n}\n}\nans = move(t);\n}\nreturn ans;\n}\n};\n", "\nclass Solution {\npublic:\nvector<string> letterCombinations(string digits) {\nif (digits.empty()) {\nreturn {};\n}\nvector<string> d = {\"abc\", \"def\", \"ghi\", \"jkl\", \"mno\", \"pqrs\", \"tuv\", \"wxyz\"};\nvector<string> ans;\nstring t;\nfunction<void(int)> dfs = [&](int i) {\nif (i >= digits.size()) {\nans.push_back(t);\nreturn;\n}\nfor (auto& c : d[digits[i] - '2']) {\nt.push_back(c);\ndfs(i + 1);\nt.pop_back();\n}\n};\ndfs(0);\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0018", "level": "middle", "question_description": "Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\n0 &lt;= a, b, c, d &lt; n\na, b, c, and d are distinct.\nnums[a] + nums[b] + nums[c] + nums[d] == target\nYou may return the answer in any order.", "examples": ["Example 1:\nInput: nums = [1,0,-1,0,-2,2], target = 0\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\n", "Example 2:\nInput: nums = [2,2,2,2,2], target = 8\nOutput: [[2,2,2,2]]\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 200\n-109 <= nums[i] <= 109\n-109 <= target <= 109\n", "java_context": "\nclass Solution {\n    public List<List<Integer>> fourSum(int[] nums, int target) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @param {number} target\n* @return {number[][]}\n*/\nvar fourSum = function (nums, target) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<vector<int>> fourSum(vector<int>& nums, int target) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic List<List<Integer>> fourSum(int[] nums, int target) {\nint n = nums.length;\nList<List<Integer>> ans = new ArrayList<>();\nif (n < 4) {\nreturn ans;\n}\nArrays.sort(nums);\nfor (int i = 0; i < n - 3; ++i) {\nif (i > 0 && nums[i] == nums[i - 1]) {\ncontinue;\n}\nfor (int j = i + 1; j < n - 2; ++j) {\nif (j > i + 1 && nums[j] == nums[j - 1]) {\ncontinue;\n}\nint k = j + 1, l = n - 1;\nwhile (k < l) {\nlong x = (long) nums[i] + nums[j] + nums[k] + nums[l];\nif (x < target) {\n++k;\n} else if (x > target) {\n--l;\n} else {\nans.add(List.of(nums[i], nums[j], nums[k++], nums[l--]));\nwhile (k < l && nums[k] == nums[k - 1]) {\n++k;\n}\nwhile (k < l && nums[l] == nums[l + 1]) {\n--l;\n}\n}\n}\n}\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @param {number} target\n* @return {number[][]}\n*/\nvar fourSum = function (nums, target) {\nconst n = nums.length;\nconst ans = [];\nif (n < 4) {\nreturn ans;\n}\nnums.sort((a, b) => a - b);\nfor (let i = 0; i < n - 3; ++i) {\nif (i > 0 && nums[i] === nums[i - 1]) {\ncontinue;\n}\nfor (let j = i + 1; j < n - 2; ++j) {\nif (j > i + 1 && nums[j] === nums[j - 1]) {\ncontinue;\n}\nlet [k, l] = [j + 1, n - 1];\nwhile (k < l) {\nconst x = nums[i] + nums[j] + nums[k] + nums[l];\nif (x < target) {\n++k;\n} else if (x > target) {\n--l;\n} else {\nans.push([nums[i], nums[j], nums[k++], nums[l--]]);\nwhile (k < l && nums[k] === nums[k - 1]) {\n++k;\n}\nwhile (k < l && nums[l] === nums[l + 1]) {\n--l;\n}\n}\n}\n}\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<vector<int>> fourSum(vector<int>& nums, int target) {\nint n = nums.size();\nvector<vector<int>> ans;\nif (n < 4) {\nreturn ans;\n}\nsort(nums.begin(), nums.end());\nfor (int i = 0; i < n - 3; ++i) {\nif (i && nums[i] == nums[i - 1]) {\ncontinue;\n}\nfor (int j = i + 1; j < n - 2; ++j) {\nif (j > i + 1 && nums[j] == nums[j - 1]) {\ncontinue;\n}\nint k = j + 1, l = n - 1;\nwhile (k < l) {\nlong long x = (long long) nums[i] + nums[j] + nums[k] + nums[l];\nif (x < target) {\n++k;\n} else if (x > target) {\n--l;\n} else {\nans.push_back({nums[i], nums[j], nums[k++], nums[l--]});\nwhile (k < l && nums[k] == nums[k - 1]) {\n++k;\n}\nwhile (k < l && nums[l] == nums[l + 1]) {\n--l;\n}\n}\n}\n}\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0019", "level": "middle", "question_description": "Given the head of a linked list, remove the nth node from the end of the list and return its head.", "examples": ["Example 1:\n\n\nInput: head = [1,2,3,4,5], n = 2\nOutput: [1,2,3,5]\n\n\nExample 2:\nInput: head = [1], n = 1\nOutput: []\n", "Example 3:\nInput: head = [1,2], n = 1\nOutput: [1]\n"], "constraints": "\nConstraints:\nThe number of nodes in the list is sz.\n1 <= sz <= 30\n0 <= Node.val <= 100\n1 <= n <= sz\n", "java_context": "\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode() {}\n*     ListNode(int val) { this.val = val; }\n*     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n* }\n*/\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for singly-linked list.\n* function ListNode(val, next) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.next = (next===undefined ? null : next)\n* }\n*/\n/**\n* @param {ListNode} head\n* @param {number} n\n* @return {ListNode}\n*/\nvar removeNthFromEnd = function (head, n) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode() {}\n*     ListNode(int val) { this.val = val; }\n*     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n* }\n*/\nclass Solution {\npublic ListNode removeNthFromEnd(ListNode head, int n) {\nListNode dummy = new ListNode(0, head);\nListNode fast = dummy, slow = dummy;\nwhile (n-- > 0) {\nfast = fast.next;\n}\nwhile (fast.next != null) {\nslow = slow.next;\nfast = fast.next;\n}\nslow.next = slow.next.next;\nreturn dummy.next;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for singly-linked list.\n* function ListNode(val, next) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.next = (next===undefined ? null : next)\n* }\n*/\n/**\n* @param {ListNode} head\n* @param {number} n\n* @return {ListNode}\n*/\nvar removeNthFromEnd = function (head, n) {\nconst dummy = new ListNode(0, head);\nlet fast = dummy,\nslow = dummy;\nwhile (n--) {\nfast = fast.next;\n}\nwhile (fast.next) {\nslow = slow.next;\nfast = fast.next;\n}\nslow.next = slow.next.next;\nreturn dummy.next;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\nclass Solution {\npublic:\nListNode* removeNthFromEnd(ListNode* head, int n) {\nListNode* dummy = new ListNode(0, head);\nListNode* fast = dummy;\nListNode* slow = dummy;\nwhile (n--) {\nfast = fast->next;\n}\nwhile (fast->next) {\nslow = slow->next;\nfast = fast->next;\n}\nslow->next = slow->next->next;\nreturn dummy->next;\n}\n};\n"]}, {"leetCodeID": "0022", "level": "middle", "question_description": "Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.", "examples": ["Example 1:Input: n = 3\nOutput: [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n", "Example 2:Input: n = 1\nOutput: [\"()\"]\n"], "constraints": "\nConstraints:\n1 <= n <= 8\n", "java_context": "\nclass Solution {\n    private List<String> ans = new ArrayList<>();\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number} n\n* @return {string[]}\n*/\nvar generateParenthesis = function (n) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<string> generateParenthesis(int n) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\nprivate List<String> ans = new ArrayList<>();\nprivate int n;\n\npublic List<String> generateParenthesis(int n) {\nthis.n = n;\ndfs(0, 0, \"\");\nreturn ans;\n}\n\nprivate void dfs(int l, int r, String t) {\nif (l > n || r > n || l < r) {\nreturn;\n}\nif (l == n && r == n) {\nans.add(t);\nreturn;\n}\ndfs(l + 1, r, t + \"(\");\ndfs(l, r + 1, t + \")\");\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number} n\n* @return {string[]}\n*/\nvar generateParenthesis = function (n) {\nfunction dfs(l, r, t) {\nif (l > n || r > n || l < r) {\nreturn;\n}\nif (l == n && r == n) {\nans.push(t);\nreturn;\n}\ndfs(l + 1, r, t + '(');\ndfs(l, r + 1, t + ')');\n}\nlet ans = [];\ndfs(0, 0, '');\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<string> generateParenthesis(int n) {\nvector<string> ans;\nfunction<void(int, int, string)> dfs = [&](int l, int r, string t) {\nif (l > n || r > n || l < r) return;\nif (l == n && r == n) {\nans.push_back(t);\nreturn;\n}\ndfs(l + 1, r, t + \"(\");\ndfs(l, r + 1, t + \")\");\n};\ndfs(0, 0, \"\");\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0024", "level": "middle", "question_description": "Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list&#39;s nodes (i.e., only nodes themselves may be changed.)", "examples": ["Example 1:\n\n\nInput: head = [1,2,3,4]\nOutput: [2,1,4,3]\n\n\nExample 2:\nInput: head = []\nOutput: []\n", "Example 3:\nInput: head = [1]\nOutput: [1]\n"], "constraints": "\nConstraints:\nThe number of nodes in the&nbsp;list&nbsp;is in the range [0, 100].\n0 <= Node.val <= 100\n", "java_context": "\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode() {}\n*     ListNode(int val) { this.val = val; }\n*     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n* }\n*/\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for singly-linked list.\n* function ListNode(val, next) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.next = (next===undefined ? null : next)\n* }\n*/\n/**\n* @param {ListNode} head\n* @return {ListNode}\n*/\nvar swapPairs = function (head) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode() {}\n*     ListNode(int val) { this.val = val; }\n*     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n* }\n*/\nclass Solution {\npublic ListNode swapPairs(ListNode head) {\nif (head == null || head.next == null) {\nreturn head;\n}\nListNode t = swapPairs(head.next.next);\nListNode p = head.next;\np.next = head;\nhead.next = t;\nreturn p;\n}\n}\n", "\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode() {}\n*     ListNode(int val) { this.val = val; }\n*     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n* }\n*/\nclass Solution {\npublic ListNode swapPairs(ListNode head) {\nListNode dummy = new ListNode(0, head);\nListNode pre = dummy;\nListNode cur = head;\nwhile (cur != null && cur.next != null) {\nListNode t = cur.next;\ncur.next = t.next;\nt.next = cur;\npre.next = t;\npre = cur;\ncur = cur.next;\n}\nreturn dummy.next;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for singly-linked list.\n* function ListNode(val, next) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.next = (next===undefined ? null : next)\n* }\n*/\n/**\n* @param {ListNode} head\n* @return {ListNode}\n*/\nvar swapPairs = function (head) {\nif (!head || !head.next) {\nreturn head;\n}\nconst t = swapPairs(head.next.next);\nconst p = head.next;\np.next = head;\nhead.next = t;\nreturn p;\n};\n", "\n/**\n* Definition for singly-linked list.\n* function ListNode(val, next) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.next = (next===undefined ? null : next)\n* }\n*/\n/**\n* @param {ListNode} head\n* @return {ListNode}\n*/\nvar swapPairs = function (head) {\nconst dummy = new ListNode(0, head);\nlet [pre, cur] = [dummy, head];\nwhile (cur && cur.next) {\nconst t = cur.next;\ncur.next = t.next;\nt.next = cur;\npre.next = t;\n[pre, cur] = [cur, cur.next];\n}\nreturn dummy.next;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\nclass Solution {\npublic:\nListNode* swapPairs(ListNode* head) {\nif (!head || !head->next) {\nreturn head;\n}\nListNode* t = swapPairs(head->next->next);\nListNode* p = head->next;\np->next = head;\nhead->next = t;\nreturn p;\n}\n};\n", "\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\nclass Solution {\npublic:\nListNode* swapPairs(ListNode* head) {\nListNode* dummy = new ListNode(0, head);\nListNode* pre = dummy;\nListNode* cur = head;\nwhile (cur && cur->next) {\nListNode* t = cur->next;\ncur->next = t->next;\nt->next = cur;\npre->next = t;\npre = cur;\ncur = cur->next;\n}\nreturn dummy->next;\n}\n};\n"]}, {"leetCodeID": "0031", "level": "middle", "question_description": "A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\nFor example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\nThe next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\nFor example, the next permutation of arr = [1,2,3] is [1,3,2].\nSimilarly, the next permutation of arr = [2,3,1] is [3,1,2].\nWhile the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.\nGiven an array of integers nums, find the next permutation of nums.\nThe replacement must be in place and use only constant extra memory.", "examples": ["Example 1:\nInput: nums = [1,2,3]\nOutput: [1,3,2]\n", "Example 2:\nInput: nums = [3,2,1]\nOutput: [1,2,3]\n", "Example 3:\nInput: nums = [1,1,5]\nOutput: [1,5,1]\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 100\n0 <= nums[i] <= 100\n", "java_context": "\nclass Solution {\n    public void nextPermutation(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {void} Do not return anything, modify nums in-place instead.\n*/\nvar nextPermutation = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    void nextPermutation(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic void nextPermutation(int[] nums) {\nint n = nums.length;\nint i = n - 2;\nfor (; i >= 0; --i) {\nif (nums[i] < nums[i + 1]) {\nbreak;\n}\n}\nif (i >= 0) {\nfor (int j = n - 1; j > i; --j) {\nif (nums[j] > nums[i]) {\nswap(nums, i, j);\nbreak;\n}\n}\n}\n\nfor (int j = i + 1, k = n - 1; j < k; ++j, --k) {\nswap(nums, j, k);\n}\n}\n\nprivate void swap(int[] nums, int i, int j) {\nint t = nums[j];\nnums[j] = nums[i];\nnums[i] = t;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {void} Do not return anything, modify nums in-place instead.\n*/\nvar nextPermutation = function (nums) {\nconst n = nums.length;\nlet i = n - 2;\nwhile (i >= 0 && nums[i] >= nums[i + 1]) {\n--i;\n}\nif (i >= 0) {\nlet j = n - 1;\nwhile (j > i && nums[j] <= nums[i]) {\n--j;\n}\n[nums[i], nums[j]] = [nums[j], nums[i]];\n}\nfor (i = i + 1, j = n - 1; i < j; ++i, --j) {\n[nums[i], nums[j]] = [nums[j], nums[i]];\n}\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvoid nextPermutation(vector<int>& nums) {\nint n = nums.size();\nint i = n - 2;\nwhile (~i && nums[i] >= nums[i + 1]) {\n--i;\n}\nif (~i) {\nfor (int j = n - 1; j > i; --j) {\nif (nums[j] > nums[i]) {\nswap(nums[i], nums[j]);\nbreak;\n}\n}\n}\nreverse(nums.begin() + i + 1, nums.end());\n}\n};\n"]}, {"leetCodeID": "0033", "level": "middle", "question_description": "There is an integer array nums sorted in ascending order (with distinct values).\nPrior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 &lt;= k &lt; nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\nGiven the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\nYou must write an algorithm with O(log n) runtime complexity.", "examples": ["Example 1:Input: nums = [4,5,6,7,0,1,2], target = 0\nOutput: 4\n", "Example 2:Input: nums = [4,5,6,7,0,1,2], target = 3\nOutput: -1\n", "Example 3:Input: nums = [1], target = 0\nOutput: -1\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 5000\n-104 <= nums[i] <= 104\nAll values of nums are unique.\nnums is an ascending array that is possibly rotated.\n-104 <= target <= 104\n", "java_context": "\nclass Solution {\n    public int search(int[] nums, int target) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @param {number} target\n* @return {number}\n*/\nvar search = function (nums, target) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int search(int[] nums, int target) {\nint n = nums.length;\nint left = 0, right = n - 1;\nwhile (left < right) {\nint mid = (left + right) >> 1;\nif (nums[0] <= nums[mid]) {\nif (nums[0] <= target && target <= nums[mid]) {\nright = mid;\n} else {\nleft = mid + 1;\n}\n} else {\nif (nums[mid] < target && target <= nums[n - 1]) {\nleft = mid + 1;\n} else {\nright = mid;\n}\n}\n}\nreturn nums[left] == target ? left : -1;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @param {number} target\n* @return {number}\n*/\nvar search = function (nums, target) {\nconst n = nums.length;\nlet left = 0,\nright = n - 1;\nwhile (left < right) {\nconst mid = (left + right) >> 1;\nif (nums[0] <= nums[mid]) {\nif (nums[0] <= target && target <= nums[mid]) {\nright = mid;\n} else {\nleft = mid + 1;\n}\n} else {\nif (nums[mid] < target && target <= nums[n - 1]) {\nleft = mid + 1;\n} else {\nright = mid;\n}\n}\n}\nreturn nums[left] == target ? left : -1;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint search(vector<int>& nums, int target) {\nint n = nums.size();\nint left = 0, right = n - 1;\nwhile (left < right) {\nint mid = (left + right) >> 1;\nif (nums[0] <= nums[mid]) {\nif (nums[0] <= target && target <= nums[mid])\nright = mid;\nelse\nleft = mid + 1;\n} else {\nif (nums[mid] < target && target <= nums[n - 1])\nleft = mid + 1;\nelse\nright = mid;\n}\n}\nreturn nums[left] == target ? left : -1;\n}\n};\n"]}, {"leetCodeID": "0034", "level": "middle", "question_description": "Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\nIf target is not found in the array, return [-1, -1].\nYou must write an algorithm with O(log n) runtime complexity.", "examples": ["Example 1:Input: nums = [5,7,7,8,8,10], target = 8\nOutput: [3,4]\n", "Example 2:Input: nums = [5,7,7,8,8,10], target = 6\nOutput: [-1,-1]\n", "Example 3:Input: nums = [], target = 0\nOutput: [-1,-1]\n"], "constraints": "\nConstraints:\n0 <= nums.length <= 105\n-109&nbsp;<= nums[i]&nbsp;<= 109\nnums is a non-decreasing array.\n-109&nbsp;<= target&nbsp;<= 109\n", "java_context": "    \n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @param {number} target\n* @return {number[]}\n*/\nvar searchRange = function (nums, target) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> searchRange(vector<int>& nums, int target) {\n        // your code\n    }\n};", "java_solutions": ["\nboolean check(int x) {\n}\n\nint search(int left, int right) {\nwhile (left < right) {\nint mid = (left + right) >> 1;\nif (check(mid)) {\nright = mid;\n} else {\nleft = mid + 1;\n}\n}\nreturn left;\n}\n", "\nboolean check(int x) {\n}\n\nint search(int left, int right) {\nwhile (left < right) {\nint mid = (left + right + 1) >> 1;\nif (check(mid)) {\nleft = mid;\n} else {\nright = mid - 1;\n}\n}\nreturn left;\n}\n", "\nclass Solution {\npublic int[] searchRange(int[] nums, int target) {\nint l = search(nums, target);\nint r = search(nums, target + 1);\nreturn l == r ? new int[] {-1, -1} : new int[] {l, r - 1};\n}\n\nprivate int search(int[] nums, int x) {\nint left = 0, right = nums.length;\nwhile (left < right) {\nint mid = (left + right) >>> 1;\nif (nums[mid] >= x) {\nright = mid;\n} else {\nleft = mid + 1;\n}\n}\nreturn left;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @param {number} target\n* @return {number[]}\n*/\nvar searchRange = function (nums, target) {\nfunction search(x) {\nlet left = 0,\nright = nums.length;\nwhile (left < right) {\nconst mid = (left + right) >> 1;\nif (nums[mid] >= x) {\nright = mid;\n} else {\nleft = mid + 1;\n}\n}\nreturn left;\n}\nconst l = search(target);\nconst r = search(target + 1);\nreturn l == r ? [-1, -1] : [l, r - 1];\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> searchRange(vector<int>& nums, int target) {\nint l = lower_bound(nums.begin(), nums.end(), target) - nums.begin();\nint r = lower_bound(nums.begin(), nums.end(), target + 1) - nums.begin();\nif (l == r) return {-1, -1};\nreturn {l, r - 1};\n}\n};\n"]}, {"leetCodeID": "0036", "level": "middle", "question_description": "Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\nEach row must contain the digits 1-9 without repetition.\nEach column must contain the digits 1-9 without repetition.\nEach of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.\nNote:\nA Sudoku board (partially filled) could be valid but is not necessarily solvable.\nOnly the filled cells need to be validated according to the mentioned rules.", "examples": ["Example 1:\n\n\nInput: board =\n[[&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]\n,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]\n,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]\n,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]\n,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]\n,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]\n,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]\n,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]\n,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]\nOutput: true\n\n\nExample 2:\nInput: board =\n[[&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]\n,[&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;]\n,[&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;]\n,[&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;]\n,[&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;]\n,[&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;]\n,[&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;]\n,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;]\n,[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]\nOutput: false\nExplanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8&#39;s in the top left 3x3 sub-box, it is invalid.\n"], "constraints": "\nConstraints:\nboard.length == 9\nboard[i].length == 9\nboard[i][j] is a digit 1-9 or &#39;.&#39;.\n", "java_context": "\nclass Solution {\n    public boolean isValidSudoku(char[][] board) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {character[][]} board\n* @return {boolean}\n*/\nvar isValidSudoku = function (board) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    bool isValidSudoku(vector<vector<char>>& board) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic boolean isValidSudoku(char[][] board) {\nboolean[][] row = new boolean[9][9];\nboolean[][] col = new boolean[9][9];\nboolean[][] sub = new boolean[9][9];\nfor (int i = 0; i < 9; ++i) {\nfor (int j = 0; j < 9; ++j) {\nchar c = board[i][j];\nif (c == '.') {\ncontinue;\n}\nint num = c - '0' - 1;\nint k = i / 3 * 3 + j / 3;\nif (row[i][num] || col[j][num] || sub[k][num]) {\nreturn false;\n}\nrow[i][num] = true;\ncol[j][num] = true;\nsub[k][num] = true;\n}\n}\nreturn true;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {character[][]} board\n* @return {boolean}\n*/\nvar isValidSudoku = function (board) {\nconst row = [...Array(9)].map(() => Array(9).fill(false));\nconst col = [...Array(9)].map(() => Array(9).fill(false));\nconst sub = [...Array(9)].map(() => Array(9).fill(false));\nfor (let i = 0; i < 9; ++i) {\nfor (let j = 0; j < 9; ++j) {\nconst num = board[i][j].charCodeAt() - '1'.charCodeAt();\nif (num < 0 || num > 8) {\ncontinue;\n}\nconst k = Math.floor(i / 3) * 3 + Math.floor(j / 3);\nif (row[i][num] || col[j][num] || sub[k][num]) {\nreturn false;\n}\nrow[i][num] = true;\ncol[j][num] = true;\nsub[k][num] = true;\n}\n}\nreturn true;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nbool isValidSudoku(vector<vector<char>>& board) {\nvector<vector<bool>> row(9, vector<bool>(9, false));\nvector<vector<bool>> col(9, vector<bool>(9, false));\nvector<vector<bool>> sub(9, vector<bool>(9, false));\nfor (int i = 0; i < 9; ++i) {\nfor (int j = 0; j < 9; ++j) {\nchar c = board[i][j];\nif (c == '.') continue;\nint num = c - '0' - 1;\nint k = i / 3 * 3 + j / 3;\nif (row[i][num] || col[j][num] || sub[k][num]) {\nreturn false;\n}\nrow[i][num] = true;\ncol[j][num] = true;\nsub[k][num] = true;\n}\n}\nreturn true;\n}\n};\n"]}, {"leetCodeID": "0038", "level": "middle", "question_description": "The count-and-say sequence is a sequence of digit strings defined by the recursive formula:\ncountAndSay(1) = &quot;1&quot;\ncountAndSay(n) is the run-length encoding of countAndSay(n - 1).\nRun-length encoding (RLE) is a string compression method that works by replacing consecutive identical characters (repeated 2 or more times) with the concatenation of the character and the number marking the count of the characters (length of the run). For example, to compress the string &quot;3322251&quot; we replace &quot;33&quot; with &quot;23&quot;, replace &quot;222&quot; with &quot;32&quot;, replace &quot;5&quot; with &quot;15&quot; and replace &quot;1&quot; with &quot;11&quot;. Thus the compressed string becomes &quot;23321511&quot;.\nGiven a positive integer n, return the nth element of the count-and-say sequence.", "examples": ["Example 1:\n\n\nInput: n = 4\n\nOutput: &quot;1211&quot;\n\nExplanation:\ncountAndSay(1) = &quot;1&quot;\ncountAndSay(2) = RLE of &quot;1&quot; = &quot;11&quot;\ncountAndSay(3) = RLE of &quot;11&quot; = &quot;21&quot;\ncountAndSay(4) = RLE of &quot;21&quot; = &quot;1211&quot;\n"], "constraints": "\nConstraints:\n1 <= n <= 30\n", "java_context": "\nclass Solution {\n    public String countAndSay(int n) {\n        // your code\n    }\n}", "js_context": "\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    string countAndSay(int n) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic String countAndSay(int n) {\nString s = \"1\";\nwhile (--n > 0) {\nStringBuilder t = new StringBuilder();\nfor (int i = 0; i < s.length();) {\nint j = i;\nwhile (j < s.length() && s.charAt(j) == s.charAt(i)) {\n++j;\n}\nt.append((j - i) + \"\");\nt.append(s.charAt(i));\ni = j;\n}\ns = t.toString();\n}\nreturn s;\n}\n}\n"], "js_solutions": ["\nconst countAndSay = function (n) {\nlet s = '1';\n\nfor (let i = 2; i <= n; i++) {\nlet count = 1,\nstr = '',\nlen = s.length;\n\nfor (let j = 0; j < len; j++) {\nif (j < len - 1 && s[j] === s[j + 1]) {\ncount++;\n} else {\nstr += `${count}${s[j]}`;\ncount = 1;\n}\n}\ns = str;\n}\nreturn s;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nstring countAndSay(int n) {\nstring s = \"1\";\nwhile (--n) {\nstring t = \"\";\nfor (int i = 0; i < s.size();) {\nint j = i;\nwhile (j < s.size() && s[j] == s[i]) ++j;\nt += to_string(j - i);\nt += s[i];\ni = j;\n}\ns = t;\n}\nreturn s;\n}\n};\n"]}, {"leetCodeID": "0040", "level": "middle", "question_description": "Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\nEach number in candidates may only be used once in the combination.\nNote: The solution set must not contain duplicate combinations.", "examples": ["Example 1:\nInput: candidates = [10,1,2,7,6,1,5], target = 8\nOutput:\n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]\n", "Example 2:\nInput: candidates = [2,5,2,1,2], target = 5\nOutput:\n[\n[1,2,2],\n[5]\n]\n"], "constraints": "\nConstraints:\n1 <=&nbsp;candidates.length <= 100\n1 <=&nbsp;candidates[i] <= 50\n1 <= target <= 30\n", "java_context": "\nclass Solution {\n    private List<List<Integer>> ans = new ArrayList<>();\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} candidates\n* @param {number} target\n* @return {number[][]}\n*/\nvar combinationSum2 = function (candidates, target) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\nprivate List<List<Integer>> ans = new ArrayList<>();\nprivate List<Integer> t = new ArrayList<>();\nprivate int[] candidates;\n\npublic List<List<Integer>> combinationSum2(int[] candidates, int target) {\nArrays.sort(candidates);\nthis.candidates = candidates;\ndfs(0, target);\nreturn ans;\n}\n\nprivate void dfs(int i, int s) {\nif (s == 0) {\nans.add(new ArrayList<>(t));\nreturn;\n}\nif (i >= candidates.length || s < candidates[i]) {\nreturn;\n}\nfor (int j = i; j < candidates.length; ++j) {\nif (j > i && candidates[j] == candidates[j - 1]) {\ncontinue;\n}\nt.add(candidates[j]);\ndfs(j + 1, s - candidates[j]);\nt.remove(t.size() - 1);\n}\n}\n}\n", "\nclass Solution {\nprivate List<List<Integer>> ans = new ArrayList<>();\nprivate List<Integer> t = new ArrayList<>();\nprivate int[] candidates;\n\npublic List<List<Integer>> combinationSum2(int[] candidates, int target) {\nArrays.sort(candidates);\nthis.candidates = candidates;\ndfs(0, target);\nreturn ans;\n}\n\nprivate void dfs(int i, int s) {\nif (s == 0) {\nans.add(new ArrayList<>(t));\nreturn;\n}\nif (i >= candidates.length || s < candidates[i]) {\nreturn;\n}\nint x = candidates[i];\nt.add(x);\ndfs(i + 1, s - x);\nt.remove(t.size() - 1);\nwhile (i < candidates.length && candidates[i] == x) {\n++i;\n}\ndfs(i, s);\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} candidates\n* @param {number} target\n* @return {number[][]}\n*/\nvar combinationSum2 = function (candidates, target) {\ncandidates.sort((a, b) => a - b);\nconst ans = [];\nconst t = [];\nconst dfs = (i, s) => {\nif (s === 0) {\nans.push(t.slice());\nreturn;\n}\nif (i >= candidates.length || s < candidates[i]) {\nreturn;\n}\nfor (let j = i; j < candidates.length; ++j) {\nif (j > i && candidates[j] === candidates[j - 1]) {\ncontinue;\n}\nt.push(candidates[j]);\ndfs(j + 1, s - candidates[j]);\nt.pop();\n}\n};\ndfs(0, target);\nreturn ans;\n};\n", "\n/**\n* @param {number[]} candidates\n* @param {number} target\n* @return {number[][]}\n*/\nvar combinationSum2 = function (candidates, target) {\ncandidates.sort((a, b) => a - b);\nconst ans = [];\nconst t = [];\nconst dfs = (i, s) => {\nif (s === 0) {\nans.push(t.slice());\nreturn;\n}\nif (i >= candidates.length || s < candidates[i]) {\nreturn;\n}\nconst x = candidates[i];\nt.push(x);\ndfs(i + 1, s - x);\nt.pop();\nwhile (i < candidates.length && candidates[i] === x) {\n++i;\n}\ndfs(i, s);\n};\ndfs(0, target);\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\nsort(candidates.begin(), candidates.end());\nvector<vector<int>> ans;\nvector<int> t;\nfunction<void(int, int)> dfs = [&](int i, int s) {\nif (s == 0) {\nans.emplace_back(t);\nreturn;\n}\nif (i >= candidates.size() || s < candidates[i]) {\nreturn;\n}\nfor (int j = i; j < candidates.size(); ++j) {\nif (j > i && candidates[j] == candidates[j - 1]) {\ncontinue;\n}\nt.emplace_back(candidates[j]);\ndfs(j + 1, s - candidates[j]);\nt.pop_back();\n}\n};\ndfs(0, target);\nreturn ans;\n}\n};\n", "\nclass Solution {\npublic:\nvector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\nsort(candidates.begin(), candidates.end());\nvector<vector<int>> ans;\nvector<int> t;\nfunction<void(int, int)> dfs = [&](int i, int s) {\nif (s == 0) {\nans.emplace_back(t);\nreturn;\n}\nif (i >= candidates.size() || s < candidates[i]) {\nreturn;\n}\nint x = candidates[i];\nt.emplace_back(x);\ndfs(i + 1, s - x);\nt.pop_back();\nwhile (i < candidates.size() && candidates[i] == x) {\n++i;\n}\ndfs(i, s);\n};\ndfs(0, target);\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0046", "level": "middle", "question_description": "Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.", "examples": ["Example 1:Input: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n", "Example 2:Input: nums = [0,1]\nOutput: [[0,1],[1,0]]\n", "Example 3:Input: nums = [1]\nOutput: [[1]]\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 6\n-10 <= nums[i] <= 10\nAll the integers of nums are unique.\n", "java_context": "\nclass Solution {\n    private List<List<Integer>> ans = new ArrayList<>();\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number[][]}\n*/\nvar permute = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<vector<int>> permute(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\nprivate List<List<Integer>> ans = new ArrayList<>();\nprivate List<Integer> t = new ArrayList<>();\nprivate boolean[] vis;\nprivate int[] nums;\n\npublic List<List<Integer>> permute(int[] nums) {\nthis.nums = nums;\nvis = new boolean[nums.length];\ndfs(0);\nreturn ans;\n}\n\nprivate void dfs(int i) {\nif (i == nums.length) {\nans.add(new ArrayList<>(t));\nreturn;\n}\nfor (int j = 0; j < nums.length; ++j) {\nif (!vis[j]) {\nvis[j] = true;\nt.add(nums[j]);\ndfs(i + 1);\nt.remove(t.size() - 1);\nvis[j] = false;\n}\n}\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number[][]}\n*/\nvar permute = function (nums) {\nconst n = nums.length;\nconst ans = [];\nconst t = [];\nconst vis = new Array(n).fill(false);\nfunction dfs(i) {\nif (i >= n) {\nans.push([...t]);\nreturn;\n}\nfor (let j = 0; j < n; ++j) {\nif (!vis[j]) {\nvis[j] = true;\nt.push(nums[j]);\ndfs(i + 1);\nvis[j] = false;\nt.pop();\n}\n}\n}\ndfs(0);\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<vector<int>> permute(vector<int>& nums) {\nint n = nums.size();\nvector<vector<int>> ans;\nvector<int> t(n);\nvector<bool> vis(n);\nfunction<void(int)> dfs = [&](int i) {\nif (i == n) {\nans.emplace_back(t);\nreturn;\n}\nfor (int j = 0; j < n; ++j) {\nif (!vis[j]) {\nvis[j] = true;\nt[i] = nums[j];\ndfs(i + 1);\nvis[j] = false;\n}\n}\n};\ndfs(0);\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0048", "level": "middle", "question_description": "You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.", "examples": [], "constraints": "\nConstraints:\nn == matrix.length == matrix[i].length\n1 <= n <= 20\n-1000 <= matrix[i][j] <= 1000\n", "java_context": "\nclass Solution {\n    public void rotate(int[][] matrix) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[][]} matrix\n* @return {void} Do not return anything, modify matrix in-place instead.\n*/\nvar rotate = function (matrix) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic void rotate(int[][] matrix) {\nint n = matrix.length;\nfor (int i = 0; i < n >> 1; ++i) {\nfor (int j = 0; j < n; ++j) {\nint t = matrix[i][j];\nmatrix[i][j] = matrix[n - i - 1][j];\nmatrix[n - i - 1][j] = t;\n}\n}\nfor (int i = 0; i < n; ++i) {\nfor (int j = 0; j < i; ++j) {\nint t = matrix[i][j];\nmatrix[i][j] = matrix[j][i];\nmatrix[j][i] = t;\n}\n}\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[][]} matrix\n* @return {void} Do not return anything, modify matrix in-place instead.\n*/\nvar rotate = function (matrix) {\nmatrix.reverse();\nfor (let i = 0; i < matrix.length; ++i) {\nfor (let j = 0; j < i; ++j) {\n[matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]];\n}\n}\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvoid rotate(vector<vector<int>>& matrix) {\nint n = matrix.size();\nfor (int i = 0; i < n >> 1; ++i) {\nfor (int j = 0; j < n; ++j) {\nswap(matrix[i][j], matrix[n - i - 1][j]);\n}\n}\nfor (int i = 0; i < n; ++i) {\nfor (int j = 0; j < i; ++j) {\nswap(matrix[i][j], matrix[j][i]);\n}\n}\n}\n};\n"]}, {"leetCodeID": "0050", "level": "middle", "question_description": "Implement pow(x, n), which calculates x raised to the power n (i.e., xn).", "examples": ["Example 1:\nInput: x = 2.00000, n = 10\nOutput: 1024.00000\n", "Example 2:\nInput: x = 2.10000, n = 3\nOutput: 9.26100\n", "Example 3:\nInput: x = 2.00000, n = -2\nOutput: 0.25000\nExplanation: 2-2 = 1/22 = 1/4 = 0.25\n"], "constraints": "\nConstraints:\n-100.0 < x < 100.0\n-231 <= n <= 231-1\nn is an integer.\nEither x is not zero or n &gt; 0.\n-104 <= xn <= 104\n", "java_context": "\nclass Solution {\n    public double myPow(double x, int n) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number} x\n* @param {number} n\n* @return {number}\n*/\nvar myPow = function (x, n) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    double myPow(double x, int n) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic double myPow(double x, int n) {\nreturn n >= 0 ? qpow(x, n) : 1 / qpow(x, -(long) n);\n}\n\nprivate double qpow(double a, long n) {\ndouble ans = 1;\nfor (; n > 0; n >>= 1) {\nif ((n & 1) == 1) {\nans = ans * a;\n}\na = a * a;\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number} x\n* @param {number} n\n* @return {number}\n*/\nvar myPow = function (x, n) {\nconst qpow = (a, n) => {\nlet ans = 1;\nfor (; n; n >>>= 1) {\nif (n & 1) {\nans *= a;\n}\na *= a;\n}\nreturn ans;\n};\nreturn n >= 0 ? qpow(x, n) : 1 / qpow(x, -n);\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\ndouble myPow(double x, int n) {\nauto qpow = [](double a, long long n) {\ndouble ans = 1;\nfor (; n; n >>= 1) {\nif (n & 1) {\nans *= a;\n}\na *= a;\n}\nreturn ans;\n};\nreturn n >= 0 ? qpow(x, n) : 1 / qpow(x, -(long long) n);\n}\n};\n"]}, {"leetCodeID": "0053", "level": "middle", "question_description": "Given an integer array nums, find the subarray with the largest sum, and return its sum.", "examples": ["Example 1:\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\n", "Example 2:\nInput: nums = [1]\nOutput: 1\nExplanation: The subarray [1] has the largest sum 1.\n", "Example 3:\nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23.\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 105\n-104 <= nums[i] <= 104\n", "java_context": "\nclass Solution {\n    public int maxSubArray(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar maxSubArray = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int maxSubArray(int[] nums) {\nint ans = nums[0];\nfor (int i = 1, f = nums[0]; i < nums.length; ++i) {\nf = Math.max(f, 0) + nums[i];\nans = Math.max(ans, f);\n}\nreturn ans;\n}\n}\n", "\nclass Solution {\npublic int maxSubArray(int[] nums) {\nreturn maxSub(nums, 0, nums.length - 1);\n}\n\nprivate int maxSub(int[] nums, int left, int right) {\nif (left == right) {\nreturn nums[left];\n}\nint mid = (left + right) >>> 1;\nint lsum = maxSub(nums, left, mid);\nint rsum = maxSub(nums, mid + 1, right);\nreturn Math.max(Math.max(lsum, rsum), crossMaxSub(nums, left, mid, right));\n}\n\nprivate int crossMaxSub(int[] nums, int left, int mid, int right) {\nint lsum = 0, rsum = 0;\nint lmx = Integer.MIN_VALUE, rmx = Integer.MIN_VALUE;\nfor (int i = mid; i >= left; --i) {\nlsum += nums[i];\nlmx = Math.max(lmx, lsum);\n}\nfor (int i = mid + 1; i <= right; ++i) {\nrsum += nums[i];\nrmx = Math.max(rmx, rsum);\n}\nreturn lmx + rmx;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar maxSubArray = function (nums) {\nlet [ans, f] = [nums[0], nums[0]];\nfor (let i = 1; i < nums.length; ++i) {\nf = Math.max(f, 0) + nums[i];\nans = Math.max(ans, f);\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint maxSubArray(vector<int>& nums) {\nint ans = nums[0], f = nums[0];\nfor (int i = 1; i < nums.size(); ++i) {\nf = max(f, 0) + nums[i];\nans = max(ans, f);\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0054", "level": "middle", "question_description": "Given an m x n matrix, return all elements of the matrix in spiral order.", "examples": [], "constraints": "\nConstraints:\nm == matrix.length\nn == matrix[i].length\n1 <= m, n <= 10\n-100 <= matrix[i][j] <= 100\n", "java_context": "\nclass Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[][]} matrix\n* @return {number[]}\n*/\nvar spiralOrder = function (matrix) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> spiralOrder(vector<vector<int>>& matrix) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic List<Integer> spiralOrder(int[][] matrix) {\nint m = matrix.length, n = matrix[0].length;\nint[] dirs = {0, 1, 0, -1, 0};\nint i = 0, j = 0, k = 0;\nList<Integer> ans = new ArrayList<>();\nboolean[][] vis = new boolean[m][n];\nfor (int h = m * n; h > 0; --h) {\nans.add(matrix[i][j]);\nvis[i][j] = true;\nint x = i + dirs[k], y = j + dirs[k + 1];\nif (x < 0 || x >= m || y < 0 || y >= n || vis[x][y]) {\nk = (k + 1) % 4;\n}\ni += dirs[k];\nj += dirs[k + 1];\n}\nreturn ans;\n}\n}\n", "\nclass Solution {\npublic List<Integer> spiralOrder(int[][] matrix) {\nint m = matrix.length, n = matrix[0].length;\nint[] dirs = {0, 1, 0, -1, 0};\nList<Integer> ans = new ArrayList<>();\nfor (int h = m * n, i = 0, j = 0, k = 0; h > 0; --h) {\nans.add(matrix[i][j]);\nmatrix[i][j] += 300;\nint x = i + dirs[k], y = j + dirs[k + 1];\nif (x < 0 || x >= m || y < 0 || y >= n || matrix[x][y] > 100) {\nk = (k + 1) % 4;\n}\ni += dirs[k];\nj += dirs[k + 1];\n}\n// for (int i = 0; i < m; ++i) {\n//     for (int j = 0; j < n; ++j) {\n//         matrix[i][j] -= 300;\n//     }\n// }\nreturn ans;\n}\n}\n", "\nclass Solution {\npublic List<Integer> spiralOrder(int[][] matrix) {\nint m = matrix.length, n = matrix[0].length;\nint x1 = 0, y1 = 0, x2 = m - 1, y2 = n - 1;\nList<Integer> ans = new ArrayList<>();\nwhile (x1 <= x2 && y1 <= y2) {\nfor (int j = y1; j <= y2; ++j) {\nans.add(matrix[x1][j]);\n}\nfor (int i = x1 + 1; i <= x2; ++i) {\nans.add(matrix[i][y2]);\n}\nif (x1 < x2 && y1 < y2) {\nfor (int j = y2 - 1; j >= y1; --j) {\nans.add(matrix[x2][j]);\n}\nfor (int i = x2 - 1; i > x1; --i) {\nans.add(matrix[i][y1]);\n}\n}\n++x1;\n++y1;\n--x2;\n--y2;\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[][]} matrix\n* @return {number[]}\n*/\nvar spiralOrder = function (matrix) {\nconst m = matrix.length;\nconst n = matrix[0].length;\nconst ans = [];\nconst vis = new Array(m).fill(0).map(() => new Array(n).fill(false));\nconst dirs = [0, 1, 0, -1, 0];\nfor (let h = m * n, i = 0, j = 0, k = 0; h > 0; --h) {\nans.push(matrix[i][j]);\nvis[i][j] = true;\nconst x = i + dirs[k];\nconst y = j + dirs[k + 1];\nif (x < 0 || x >= m || y < 0 || y >= n || vis[x][y]) {\nk = (k + 1) % 4;\n}\ni += dirs[k];\nj += dirs[k + 1];\n}\nreturn ans;\n};\n", "\n/**\n* @param {number[][]} matrix\n* @return {number[]}\n*/\nvar spiralOrder = function (matrix) {\nconst m = matrix.length;\nconst n = matrix[0].length;\nconst ans = [];\nconst dirs = [0, 1, 0, -1, 0];\nfor (let h = m * n, i = 0, j = 0, k = 0; h > 0; --h) {\nans.push(matrix[i][j]);\nmatrix[i][j] += 300;\nconst x = i + dirs[k];\nconst y = j + dirs[k + 1];\nif (x < 0 || x >= m || y < 0 || y >= n || matrix[x][y] > 100) {\nk = (k + 1) % 4;\n}\ni += dirs[k];\nj += dirs[k + 1];\n}\n// for (let i = 0; i < m; ++i) {\n//     for (let j = 0; j < n; ++j) {\n//         matrix[i][j] -= 300;\n//     }\n// }\nreturn ans;\n};\n", "\n/**\n* @param {number[][]} matrix\n* @return {number[]}\n*/\nvar spiralOrder = function (matrix) {\nconst m = matrix.length;\nconst n = matrix[0].length;\nlet x1 = 0;\nlet y1 = 0;\nlet x2 = m - 1;\nlet y2 = n - 1;\nconst ans = [];\nwhile (x1 <= x2 && y1 <= y2) {\nfor (let j = y1; j <= y2; ++j) {\nans.push(matrix[x1][j]);\n}\nfor (let i = x1 + 1; i <= x2; ++i) {\nans.push(matrix[i][y2]);\n}\nif (x1 < x2 && y1 < y2) {\nfor (let j = y2 - 1; j >= y1; --j) {\nans.push(matrix[x2][j]);\n}\nfor (let i = x2 - 1; i > x1; --i) {\nans.push(matrix[i][y1]);\n}\n}\n++x1;\n++y1;\n--x2;\n--y2;\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\nint m = matrix.size(), n = matrix[0].size();\nint dirs[5] = {0, 1, 0, -1, 0};\nint i = 0, j = 0, k = 0;\nvector<int> ans;\nbool vis[m][n];\nmemset(vis, false, sizeof(vis));\nfor (int h = m * n; h; --h) {\nans.push_back(matrix[i][j]);\nvis[i][j] = true;\nint x = i + dirs[k], y = j + dirs[k + 1];\nif (x < 0 || x >= m || y < 0 || y >= n || vis[x][y]) {\nk = (k + 1) % 4;\n}\ni += dirs[k];\nj += dirs[k + 1];\n}\nreturn ans;\n}\n};\n", "\nclass Solution {\npublic:\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\nint m = matrix.size(), n = matrix[0].size();\nint dirs[5] = {0, 1, 0, -1, 0};\nvector<int> ans;\nfor (int h = m * n, i = 0, j = 0, k = 0; h; --h) {\nans.push_back(matrix[i][j]);\nmatrix[i][j] += 300;\nint x = i + dirs[k], y = j + dirs[k + 1];\nif (x < 0 || x >= m || y < 0 || y >= n || matrix[x][y] > 100) {\nk = (k + 1) % 4;\n}\ni += dirs[k];\nj += dirs[k + 1];\n}\n// for (int i = 0; i < m; ++i) {\n//     for (int j = 0; j < n; ++j) {\n//         matrix[i][j] -= 300;\n//     }\n// }\nreturn ans;\n}\n};\n", "\nclass Solution {\npublic:\nvector<int> spiralOrder(vector<vector<int>>& matrix) {\nint m = matrix.size(), n = matrix[0].size();\nint x1 = 0, y1 = 0, x2 = m - 1, y2 = n - 1;\nvector<int> ans;\nwhile (x1 <= x2 && y1 <= y2) {\nfor (int j = y1; j <= y2; ++j) {\nans.push_back(matrix[x1][j]);\n}\nfor (int i = x1 + 1; i <= x2; ++i) {\nans.push_back(matrix[i][y2]);\n}\nif (x1 < x2 && y1 < y2) {\nfor (int j = y2 - 1; j >= y1; --j) {\nans.push_back(matrix[x2][j]);\n}\nfor (int i = x2 - 1; i > x1; --i) {\nans.push_back(matrix[i][y1]);\n}\n}\n++x1, ++y1;\n--x2, --y2;\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0055", "level": "middle", "question_description": "You are given an integer array nums. You are initially positioned at the array&#39;s first index, and each element in the array represents your maximum jump length at that position.\nReturn true if you can reach the last index, or false otherwise.", "examples": ["Example 1:\nInput: nums = [2,3,1,1,4]\nOutput: true\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\n", "Example 2:\nInput: nums = [3,2,1,0,4]\nOutput: false\nExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 104\n0 <= nums[i] <= 105\n", "java_context": "\nclass Solution {\n    public boolean canJump(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {boolean}\n*/\nvar canJump = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    bool canJump(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic boolean canJump(int[] nums) {\nint mx = 0;\nfor (int i = 0; i < nums.length; ++i) {\nif (mx < i) {\nreturn false;\n}\nmx = Math.max(mx, i + nums[i]);\n}\nreturn true;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {boolean}\n*/\nvar canJump = function (nums) {\nlet mx = 0;\nfor (let i = 0; i < nums.length; ++i) {\nif (mx < i) {\nreturn false;\n}\nmx = Math.max(mx, i + nums[i]);\n}\nreturn true;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nbool canJump(vector<int>& nums) {\nint mx = 0;\nfor (int i = 0; i < nums.size(); ++i) {\nif (mx < i) {\nreturn false;\n}\nmx = max(mx, i + nums[i]);\n}\nreturn true;\n}\n};\n"]}, {"leetCodeID": "0059", "level": "middle", "question_description": "Given a positive integer n, generate an n x n matrix filled with elements from 1 to n2 in spiral order.", "examples": ["Example 1:\n\n\nInput: n = 3\nOutput: [[1,2,3],[8,9,4],[7,6,5]]\n\n\nExample 2:\nInput: n = 1\nOutput: [[1]]\n"], "constraints": "\nConstraints:\n1 <= n <= 20\n", "java_context": "\nclass Solution {\n    public int[][] generateMatrix(int n) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number} n\n* @return {number[][]}\n*/\nvar generateMatrix = function (n) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    const int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int[][] generateMatrix(int n) {\nint[][] ans = new int[n][n];\nint i = 0, j = 0, k = 0;\nint[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\nfor (int v = 1; v <= n * n; ++v) {\nans[i][j] = v;\nint x = i + dirs[k][0], y = j + dirs[k][1];\nif (x < 0 || y < 0 || x >= n || y >= n || ans[x][y] > 0) {\nk = (k + 1) % 4;\nx = i + dirs[k][0];\ny = j + dirs[k][1];\n}\ni = x;\nj = y;\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number} n\n* @return {number[][]}\n*/\nvar generateMatrix = function (n) {\nconst ans = new Array(n).fill(0).map(() => new Array(n).fill(0));\nlet [i, j, k] = [0, 0, 0];\nconst dirs = [\n[0, 1],\n[1, 0],\n[0, -1],\n[-1, 0],\n];\nfor (let v = 1; v <= n * n; ++v) {\nans[i][j] = v;\nlet [x, y] = [i + dirs[k][0], j + dirs[k][1]];\nif (x < 0 || y < 0 || x >= n || y >= n || ans[x][y] > 0) {\nk = (k + 1) % 4;\n[x, y] = [i + dirs[k][0], j + dirs[k][1]];\n}\n[i, j] = [x, y];\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nconst int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\nvector<vector<int>> generateMatrix(int n) {\nvector<vector<int>> ans(n, vector<int>(n));\nint i = 0, j = 0, k = 0;\nfor (int v = 1; v <= n * n; ++v) {\nans[i][j] = v;\nint x = i + dirs[k][0], y = j + dirs[k][1];\nif (x < 0 || y < 0 || x >= n || y >= n || ans[x][y]) {\nk = (k + 1) % 4;\nx = i + dirs[k][0], y = j + dirs[k][1];\n}\ni = x, j = y;\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0062", "level": "middle", "question_description": "There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.\nGiven the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.\nThe test cases are generated so that the answer will be less than or equal to 2 * 109.", "examples": ["Example 1:\n\n\nInput: m = 3, n = 7\nOutput: 28\n\n\nExample 2:\nInput: m = 3, n = 2\nOutput: 3\nExplanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n1. Right -&gt; Down -&gt; Down\n2. Down -&gt; Down -&gt; Right\n3. Down -&gt; Right -&gt; Down\n"], "constraints": "\nConstraints:\n1 <= m, n <= 100\n", "java_context": "\nclass Solution {\n    public int uniquePaths(int m, int n) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number} m\n* @param {number} n\n* @return {number}\n*/\nvar uniquePaths = function (m, n) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int uniquePaths(int m, int n) {\nvar f = new int[m][n];\nf[0][0] = 1;\nfor (int i = 0; i < m; ++i) {\nfor (int j = 0; j < n; ++j) {\nif (i > 0) {\nf[i][j] += f[i - 1][j];\n}\nif (j > 0) {\nf[i][j] += f[i][j - 1];\n}\n}\n}\nreturn f[m - 1][n - 1];\n}\n}\n", "\nclass Solution {\npublic int uniquePaths(int m, int n) {\nvar f = new int[m][n];\nfor (var g : f) {\nArrays.fill(g, 1);\n}\nfor (int i = 1; i < m; ++i) {\nfor (int j = 1; j < n; j++) {\nf[i][j] = f[i - 1][j] + f[i][j - 1];\n}\n}\nreturn f[m - 1][n - 1];\n}\n}\n", "\nclass Solution {\npublic int uniquePaths(int m, int n) {\nint[] f = new int[n];\nArrays.fill(f, 1);\nfor (int i = 1; i < m; ++i) {\nfor (int j = 1; j < n; ++j) {\nf[j] += f[j - 1];\n}\n}\nreturn f[n - 1];\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number} m\n* @param {number} n\n* @return {number}\n*/\nvar uniquePaths = function (m, n) {\nconst f = Array(m)\n.fill(0)\n.map(() => Array(n).fill(0));\nf[0][0] = 1;\nfor (let i = 0; i < m; ++i) {\nfor (let j = 0; j < n; ++j) {\nif (i > 0) {\nf[i][j] += f[i - 1][j];\n}\nif (j > 0) {\nf[i][j] += f[i][j - 1];\n}\n}\n}\nreturn f[m - 1][n - 1];\n};\n", "\n/**\n* @param {number} m\n* @param {number} n\n* @return {number}\n*/\nvar uniquePaths = function (m, n) {\nconst f = Array(m)\n.fill(0)\n.map(() => Array(n).fill(1));\nfor (let i = 1; i < m; ++i) {\nfor (let j = 1; j < n; ++j) {\nf[i][j] = f[i - 1][j] + f[i][j - 1];\n}\n}\nreturn f[m - 1][n - 1];\n};\n", "\n/**\n* @param {number} m\n* @param {number} n\n* @return {number}\n*/\nvar uniquePaths = function (m, n) {\nconst f = Array(n).fill(1);\nfor (let i = 1; i < m; ++i) {\nfor (let j = 1; j < n; ++j) {\nf[j] += f[j - 1];\n}\n}\nreturn f[n - 1];\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint uniquePaths(int m, int n) {\nvector<vector<int>> f(m, vector<int>(n));\nf[0][0] = 1;\nfor (int i = 0; i < m; ++i) {\nfor (int j = 0; j < n; ++j) {\nif (i) {\nf[i][j] += f[i - 1][j];\n}\nif (j) {\nf[i][j] += f[i][j - 1];\n}\n}\n}\nreturn f[m - 1][n - 1];\n}\n};\n", "\nclass Solution {\npublic:\nint uniquePaths(int m, int n) {\nvector<vector<int>> f(m, vector<int>(n, 1));\nfor (int i = 1; i < m; ++i) {\nfor (int j = 1; j < n; ++j) {\nf[i][j] = f[i - 1][j] + f[i][j - 1];\n}\n}\nreturn f[m - 1][n - 1];\n}\n};\n", "\nclass Solution {\npublic:\nint uniquePaths(int m, int n) {\nvector<int> f(n, 1);\nfor (int i = 1; i < m; ++i) {\nfor (int j = 1; j < n; ++j) {\nf[j] += f[j - 1];\n}\n}\nreturn f[n - 1];\n}\n};\n"]}, {"leetCodeID": "0064", "level": "middle", "question_description": "Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right, which minimizes the sum of all numbers along its path.\nNote: You can only move either down or right at any point in time.", "examples": ["Example 1:\n\n\nInput: grid = [[1,3,1],[1,5,1],[4,2,1]]\nOutput: 7\nExplanation: Because the path 1 &rarr; 3 &rarr; 1 &rarr; 1 &rarr; 1 minimizes the sum.\n\n\nExample 2:\nInput: grid = [[1,2,3],[4,5,6]]\nOutput: 12\n"], "constraints": "\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 200\n0 <= grid[i][j] <= 200\n", "java_context": "\nclass Solution {\n    public int minPathSum(int[][] grid) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[][]} grid\n* @return {number}\n*/\nvar minPathSum = function (grid) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int minPathSum(vector<vector<int>>& grid) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int minPathSum(int[][] grid) {\nint m = grid.length, n = grid[0].length;\nint[][] f = new int[m][n];\nf[0][0] = grid[0][0];\nfor (int i = 1; i < m; ++i) {\nf[i][0] = f[i - 1][0] + grid[i][0];\n}\nfor (int j = 1; j < n; ++j) {\nf[0][j] = f[0][j - 1] + grid[0][j];\n}\nfor (int i = 1; i < m; ++i) {\nfor (int j = 1; j < n; ++j) {\nf[i][j] = Math.min(f[i - 1][j], f[i][j - 1]) + grid[i][j];\n}\n}\nreturn f[m - 1][n - 1];\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[][]} grid\n* @return {number}\n*/\nvar minPathSum = function (grid) {\nconst m = grid.length;\nconst n = grid[0].length;\nconst f = Array(m)\n.fill(0)\n.map(() => Array(n).fill(0));\nf[0][0] = grid[0][0];\nfor (let i = 1; i < m; ++i) {\nf[i][0] = f[i - 1][0] + grid[i][0];\n}\nfor (let j = 1; j < n; ++j) {\nf[0][j] = f[0][j - 1] + grid[0][j];\n}\nfor (let i = 1; i < m; ++i) {\nfor (let j = 1; j < n; ++j) {\nf[i][j] = Math.min(f[i - 1][j], f[i][j - 1]) + grid[i][j];\n}\n}\nreturn f[m - 1][n - 1];\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint minPathSum(vector<vector<int>>& grid) {\nint m = grid.size(), n = grid[0].size();\nint f[m][n];\nf[0][0] = grid[0][0];\nfor (int i = 1; i < m; ++i) {\nf[i][0] = f[i - 1][0] + grid[i][0];\n}\nfor (int j = 1; j < n; ++j) {\nf[0][j] = f[0][j - 1] + grid[0][j];\n}\nfor (int i = 1; i < m; ++i) {\nfor (int j = 1; j < n; ++j) {\nf[i][j] = min(f[i - 1][j], f[i][j - 1]) + grid[i][j];\n}\n}\nreturn f[m - 1][n - 1];\n}\n};\n"]}, {"leetCodeID": "0072", "level": "middle", "question_description": "Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\nYou have the following three operations permitted on a word:\nInsert a character\nDelete a character\nReplace a character", "examples": ["Example 1:\nInput: word1 = &quot;horse&quot;, word2 = &quot;ros&quot;\nOutput: 3\nExplanation:\nhorse -&gt; rorse (replace &#39;h&#39; with &#39;r&#39;)\nrorse -&gt; rose (remove &#39;r&#39;)\nrose -&gt; ros (remove &#39;e&#39;)\n", "Example 2:\nInput: word1 = &quot;intention&quot;, word2 = &quot;execution&quot;\nOutput: 5\nExplanation:\nintention -&gt; inention (remove &#39;t&#39;)\ninention -&gt; enention (replace &#39;i&#39; with &#39;e&#39;)\nenention -&gt; exention (replace &#39;n&#39; with &#39;x&#39;)\nexention -&gt; exection (replace &#39;n&#39; with &#39;c&#39;)\nexection -&gt; execution (insert &#39;u&#39;)\n"], "constraints": "\nConstraints:\n0 <= word1.length, word2.length <= 500\nword1 and word2 consist of lowercase English letters.\n", "java_context": "\nclass Solution {\n    public int minDistance(String word1, String word2) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} word1\n* @param {string} word2\n* @return {number}\n*/\nvar minDistance = function (word1, word2) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int minDistance(String word1, String word2) {\nint m = word1.length(), n = word2.length();\nint[][] f = new int[m + 1][n + 1];\nfor (int j = 1; j <= n; ++j) {\nf[0][j] = j;\n}\nfor (int i = 1; i <= m; ++i) {\nf[i][0] = i;\nfor (int j = 1; j <= n; ++j) {\nif (word1.charAt(i - 1) == word2.charAt(j - 1)) {\nf[i][j] = f[i - 1][j - 1];\n} else {\nf[i][j] = Math.min(f[i - 1][j], Math.min(f[i][j - 1], f[i - 1][j - 1])) + 1;\n}\n}\n}\nreturn f[m][n];\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} word1\n* @param {string} word2\n* @return {number}\n*/\nvar minDistance = function (word1, word2) {\nconst m = word1.length;\nconst n = word2.length;\nconst f = Array(m + 1)\n.fill(0)\n.map(() => Array(n + 1).fill(0));\nfor (let j = 1; j <= n; ++j) {\nf[0][j] = j;\n}\nfor (let i = 1; i <= m; ++i) {\nf[i][0] = i;\nfor (let j = 1; j <= n; ++j) {\nif (word1[i - 1] === word2[j - 1]) {\nf[i][j] = f[i - 1][j - 1];\n} else {\nf[i][j] = Math.min(f[i - 1][j], f[i][j - 1], f[i - 1][j - 1]) + 1;\n}\n}\n}\nreturn f[m][n];\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint minDistance(string word1, string word2) {\nint m = word1.size(), n = word2.size();\nint f[m + 1][n + 1];\nfor (int j = 0; j <= n; ++j) {\nf[0][j] = j;\n}\nfor (int i = 1; i <= m; ++i) {\nf[i][0] = i;\nfor (int j = 1; j <= n; ++j) {\nif (word1[i - 1] == word2[j - 1]) {\nf[i][j] = f[i - 1][j - 1];\n} else {\nf[i][j] = min({f[i - 1][j], f[i][j - 1], f[i - 1][j - 1]}) + 1;\n}\n}\n}\nreturn f[m][n];\n}\n};\n"]}, {"leetCodeID": "0073", "level": "middle", "question_description": "Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0&#39;s.\nYou must do it in place.", "examples": [], "constraints": "\nConstraints:\nm == matrix.length\nn == matrix[0].length\n1 <= m, n <= 200\n-231 <= matrix[i][j] <= 231 - 1\n", "java_context": "\nclass Solution {\n    public void setZeroes(int[][] matrix) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[][]} matrix\n* @return {void} Do not return anything, modify matrix in-place instead.\n*/\nvar setZeroes = function (matrix) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    void setZeroes(vector<vector<int>>& matrix) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic void setZeroes(int[][] matrix) {\nint m = matrix.length, n = matrix[0].length;\nboolean[] rows = new boolean[m];\nboolean[] cols = new boolean[n];\nfor (int i = 0; i < m; ++i) {\nfor (int j = 0; j < n; ++j) {\nif (matrix[i][j] == 0) {\nrows[i] = true;\ncols[j] = true;\n}\n}\n}\nfor (int i = 0; i < m; ++i) {\nfor (int j = 0; j < n; ++j) {\nif (rows[i] || cols[j]) {\nmatrix[i][j] = 0;\n}\n}\n}\n}\n}\n", "\nclass Solution {\npublic void setZeroes(int[][] matrix) {\nint m = matrix.length, n = matrix[0].length;\nboolean i0 = false, j0 = false;\nfor (int j = 0; j < n; ++j) {\nif (matrix[0][j] == 0) {\ni0 = true;\nbreak;\n}\n}\nfor (int i = 0; i < m; ++i) {\nif (matrix[i][0] == 0) {\nj0 = true;\nbreak;\n}\n}\nfor (int i = 1; i < m; ++i) {\nfor (int j = 1; j < n; ++j) {\nif (matrix[i][j] == 0) {\nmatrix[i][0] = 0;\nmatrix[0][j] = 0;\n}\n}\n}\nfor (int i = 1; i < m; ++i) {\nfor (int j = 1; j < n; ++j) {\nif (matrix[i][0] == 0 || matrix[0][j] == 0) {\nmatrix[i][j] = 0;\n}\n}\n}\nif (i0) {\nfor (int j = 0; j < n; ++j) {\nmatrix[0][j] = 0;\n}\n}\nif (j0) {\nfor (int i = 0; i < m; ++i) {\nmatrix[i][0] = 0;\n}\n}\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[][]} matrix\n* @return {void} Do not return anything, modify matrix in-place instead.\n*/\nvar setZeroes = function (matrix) {\nconst m = matrix.length;\nconst n = matrix[0].length;\nconst rows = new Array(m).fill(false);\nconst cols = new Array(n).fill(false);\nfor (let i = 0; i < m; ++i) {\nfor (let j = 0; j < n; ++j) {\nif (matrix[i][j] == 0) {\nrows[i] = true;\ncols[j] = true;\n}\n}\n}\nfor (let i = 0; i < m; ++i) {\nfor (let j = 0; j < n; ++j) {\nif (rows[i] || cols[j]) {\nmatrix[i][j] = 0;\n}\n}\n}\n};\n", "\n/**\n* @param {number[][]} matrix\n* @return {void} Do not return anything, modify matrix in-place instead.\n*/\nvar setZeroes = function (matrix) {\nconst m = matrix.length;\nconst n = matrix[0].length;\nlet i0 = matrix[0].some(v => v == 0);\nlet j0 = false;\nfor (let i = 0; i < m; ++i) {\nif (matrix[i][0] == 0) {\nj0 = true;\nbreak;\n}\n}\nfor (let i = 1; i < m; ++i) {\nfor (let j = 1; j < n; ++j) {\nif (matrix[i][j] == 0) {\nmatrix[i][0] = 0;\nmatrix[0][j] = 0;\n}\n}\n}\nfor (let i = 1; i < m; ++i) {\nfor (let j = 1; j < n; ++j) {\nif (matrix[i][0] == 0 || matrix[0][j] == 0) {\nmatrix[i][j] = 0;\n}\n}\n}\nif (i0) {\nfor (let j = 0; j < n; ++j) {\nmatrix[0][j] = 0;\n}\n}\nif (j0) {\nfor (let i = 0; i < m; ++i) {\nmatrix[i][0] = 0;\n}\n}\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvoid setZeroes(vector<vector<int>>& matrix) {\nint m = matrix.size(), n = matrix[0].size();\nvector<bool> rows(m);\nvector<bool> cols(n);\nfor (int i = 0; i < m; ++i) {\nfor (int j = 0; j < n; ++j) {\nif (!matrix[i][j]) {\nrows[i] = 1;\ncols[j] = 1;\n}\n}\n}\nfor (int i = 0; i < m; ++i) {\nfor (int j = 0; j < n; ++j) {\nif (rows[i] || cols[j]) {\nmatrix[i][j] = 0;\n}\n}\n}\n}\n};\n", "\nclass Solution {\npublic:\nvoid setZeroes(vector<vector<int>>& matrix) {\nint m = matrix.size(), n = matrix[0].size();\nbool i0 = false, j0 = false;\nfor (int j = 0; j < n; ++j) {\nif (matrix[0][j] == 0) {\ni0 = true;\nbreak;\n}\n}\nfor (int i = 0; i < m; ++i) {\nif (matrix[i][0] == 0) {\nj0 = true;\nbreak;\n}\n}\nfor (int i = 1; i < m; ++i) {\nfor (int j = 1; j < n; ++j) {\nif (matrix[i][j] == 0) {\nmatrix[i][0] = 0;\nmatrix[0][j] = 0;\n}\n}\n}\nfor (int i = 1; i < m; ++i) {\nfor (int j = 1; j < n; ++j) {\nif (matrix[i][0] == 0 || matrix[0][j] == 0) {\nmatrix[i][j] = 0;\n}\n}\n}\nif (i0) {\nfor (int j = 0; j < n; ++j) {\nmatrix[0][j] = 0;\n}\n}\nif (j0) {\nfor (int i = 0; i < m; ++i) {\nmatrix[i][0] = 0;\n}\n}\n}\n};\n"]}, {"leetCodeID": "0074", "level": "middle", "question_description": "You are given an m x n integer matrix matrix with the following two properties:\nEach row is sorted in non-decreasing order.\nThe first integer of each row is greater than the last integer of the previous row.\nGiven an integer target, return true if target is in matrix or false otherwise.\nYou must write a solution in O(log(m * n)) time complexity.", "examples": [], "constraints": "\nConstraints:\nm == matrix.length\nn == matrix[i].length\n1 <= m, n <= 100\n-104 <= matrix[i][j], target <= 104\n", "java_context": "\nclass Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[][]} matrix\n* @param {number} target\n* @return {boolean}\n*/\nvar searchMatrix = function (matrix, target) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic boolean searchMatrix(int[][] matrix, int target) {\nint m = matrix.length, n = matrix[0].length;\nint left = 0, right = m * n - 1;\nwhile (left < right) {\nint mid = (left + right) >> 1;\nint x = mid / n, y = mid % n;\nif (matrix[x][y] >= target) {\nright = mid;\n} else {\nleft = mid + 1;\n}\n}\nreturn matrix[left / n][left % n] == target;\n}\n}\n", "\nclass Solution {\npublic boolean searchMatrix(int[][] matrix, int target) {\nint m = matrix.length, n = matrix[0].length;\nfor (int i = m - 1, j = 0; i >= 0 && j < n;) {\nif (matrix[i][j] == target) {\nreturn true;\n}\nif (matrix[i][j] > target) {\n--i;\n} else {\n++j;\n}\n}\nreturn false;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[][]} matrix\n* @param {number} target\n* @return {boolean}\n*/\nvar searchMatrix = function (matrix, target) {\nconst m = matrix.length,\nn = matrix[0].length;\nlet left = 0,\nright = m * n - 1;\nwhile (left < right) {\nconst mid = (left + right + 1) >> 1;\nconst x = Math.floor(mid / n);\nconst y = mid % n;\nif (matrix[x][y] <= target) {\nleft = mid;\n} else {\nright = mid - 1;\n}\n}\nreturn matrix[Math.floor(left / n)][left % n] == target;\n};\n", "\n/**\n* @param {number[][]} matrix\n* @param {number} target\n* @return {boolean}\n*/\nvar searchMatrix = function (matrix, target) {\nconst m = matrix.length,\nn = matrix[0].length;\nfor (let i = m - 1, j = 0; i >= 0 && j < n; ) {\nif (matrix[i][j] == target) {\nreturn true;\n}\nif (matrix[i][j] > target) {\n--i;\n} else {\n++j;\n}\n}\nreturn false;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\nint m = matrix.size(), n = matrix[0].size();\nint left = 0, right = m * n - 1;\nwhile (left < right) {\nint mid = left + right >> 1;\nint x = mid / n, y = mid % n;\nif (matrix[x][y] >= target) {\nright = mid;\n} else {\nleft = mid + 1;\n}\n}\nreturn matrix[left / n][left % n] == target;\n}\n};\n", "\nclass Solution {\npublic:\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\nint m = matrix.size(), n = matrix[0].size();\nfor (int i = m - 1, j = 0; i >= 0 && j < n;) {\nif (matrix[i][j] == target) return true;\nif (matrix[i][j] > target)\n--i;\nelse\n++j;\n}\nreturn false;\n}\n};\n"]}, {"leetCodeID": "0080", "level": "middle", "question_description": "Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nCustom Judge:\nThe judge will test your solution with the following code:\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\nint k = removeDuplicates(nums); // Calls your implementation\nassert k == expectedNums.length;\nfor (int i = 0; i &lt; k; i++) {\nassert nums[i] == expectedNums[i];\n}\nIf all assertions pass, then your solution will be accepted.", "examples": ["Example 1:\nInput: nums = [1,1,1,2,2,3]\nOutput: 5, nums = [1,1,2,2,3,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n", "Example 2:\nInput: nums = [0,0,1,1,1,1,2,3,3]\nOutput: 7, nums = [0,0,1,1,2,3,3,_,_]\nExplanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 3 * 104\n-104 <= nums[i] <= 104\nnums is sorted in non-decreasing order.\n", "java_context": "\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar removeDuplicates = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int removeDuplicates(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int removeDuplicates(int[] nums) {\nint k = 0;\nfor (int x : nums) {\nif (k < 2 || x != nums[k - 2]) {\nnums[k++] = x;\n}\n}\nreturn k;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar removeDuplicates = function (nums) {\nlet k = 0;\nfor (const x of nums) {\nif (k < 2 || x !== nums[k - 2]) {\nnums[k++] = x;\n}\n}\nreturn k;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint removeDuplicates(vector<int>& nums) {\nint k = 0;\nfor (int x : nums) {\nif (k < 2 || x != nums[k - 2]) {\nnums[k++] = x;\n}\n}\nreturn k;\n}\n};\n"]}, {"leetCodeID": "0082", "level": "middle", "question_description": "Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.", "examples": [], "constraints": "\nConstraints:\nThe number of nodes in the list is in the range [0, 300].\n-100 <= Node.val <= 100\nThe list is guaranteed to be sorted in ascending order.\n", "java_context": "\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode() {}\n*     ListNode(int val) { this.val = val; }\n*     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n* }\n*/\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for singly-linked list.\n* function ListNode(val, next) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.next = (next===undefined ? null : next)\n* }\n*/\n/**\n* @param {ListNode} head\n* @return {ListNode}\n*/\nvar deleteDuplicates = function (head) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\nclass Solution {\npublic:\n    ListNode* deleteDuplicates(ListNode* head) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode() {}\n*     ListNode(int val) { this.val = val; }\n*     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n* }\n*/\nclass Solution {\npublic ListNode deleteDuplicates(ListNode head) {\nListNode dummy = new ListNode(0, head);\nListNode pre = dummy;\nListNode cur = head;\nwhile (cur != null) {\nwhile (cur.next != null && cur.next.val == cur.val) {\ncur = cur.next;\n}\nif (pre.next == cur) {\npre = cur;\n} else {\npre.next = cur.next;\n}\ncur = cur.next;\n}\nreturn dummy.next;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for singly-linked list.\n* function ListNode(val, next) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.next = (next===undefined ? null : next)\n* }\n*/\n/**\n* @param {ListNode} head\n* @return {ListNode}\n*/\nvar deleteDuplicates = function (head) {\nconst dummy = new ListNode(0, head);\nlet pre = dummy;\nlet cur = head;\nwhile (cur) {\nwhile (cur.next && cur.val === cur.next.val) {\ncur = cur.next;\n}\nif (pre.next === cur) {\npre = cur;\n} else {\npre.next = cur.next;\n}\ncur = cur.next;\n}\nreturn dummy.next;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\nclass Solution {\npublic:\nListNode* deleteDuplicates(ListNode* head) {\nListNode* dummy = new ListNode(0, head);\nListNode* pre = dummy;\nListNode* cur = head;\nwhile (cur) {\nwhile (cur->next && cur->next->val == cur->val) {\ncur = cur->next;\n}\nif (pre->next == cur) {\npre = cur;\n} else {\npre->next = cur->next;\n}\ncur = cur->next;\n}\nreturn dummy->next;\n}\n};\n"]}, {"leetCodeID": "0086", "level": "middle", "question_description": "Given the head of a linked list and a value x, partition it such that all nodes less than x come before nodes greater than or equal to x.\nYou should preserve the original relative order of the nodes in each of the two partitions.", "examples": ["Example 1:\n\n\nInput: head = [1,4,3,2,5,2], x = 3\nOutput: [1,2,2,4,3,5]\n\n\nExample 2:\nInput: head = [2,1], x = 2\nOutput: [1,2]\n"], "constraints": "\nConstraints:\nThe number of nodes in the list is in the range [0, 200].\n-100 <= Node.val <= 100\n-200 <= x <= 200\n", "java_context": "\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode() {}\n*     ListNode(int val) { this.val = val; }\n*     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n* }\n*/\nclass Solution {\n    public ListNode partition(ListNode head, int x) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for singly-linked list.\n* function ListNode(val, next) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.next = (next===undefined ? null : next)\n* }\n*/\n/**\n* @param {ListNode} head\n* @param {number} x\n* @return {ListNode}\n*/\nvar partition = function (head, x) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\nclass Solution {\npublic:\n    ListNode* partition(ListNode* head, int x) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode() {}\n*     ListNode(int val) { this.val = val; }\n*     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n* }\n*/\nclass Solution {\npublic ListNode partition(ListNode head, int x) {\nListNode d1 = new ListNode();\nListNode d2 = new ListNode();\nListNode t1 = d1, t2 = d2;\nwhile (head != null) {\nif (head.val < x) {\nt1.next = head;\nt1 = t1.next;\n} else {\nt2.next = head;\nt2 = t2.next;\n}\nhead = head.next;\n}\nt1.next = d2.next;\nt2.next = null;\nreturn d1.next;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for singly-linked list.\n* function ListNode(val, next) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.next = (next===undefined ? null : next)\n* }\n*/\n/**\n* @param {ListNode} head\n* @param {number} x\n* @return {ListNode}\n*/\nvar partition = function (head, x) {\nconst d1 = new ListNode();\nconst d2 = new ListNode();\nlet t1 = d1,\nt2 = d2;\nwhile (head) {\nif (head.val < x) {\nt1.next = head;\nt1 = t1.next;\n} else {\nt2.next = head;\nt2 = t2.next;\n}\nhead = head.next;\n}\nt1.next = d2.next;\nt2.next = null;\nreturn d1.next;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\nclass Solution {\npublic:\nListNode* partition(ListNode* head, int x) {\nListNode* d1 = new ListNode();\nListNode* d2 = new ListNode();\nListNode* t1 = d1;\nListNode* t2 = d2;\nwhile (head) {\nif (head->val < x) {\nt1->next = head;\nt1 = t1->next;\n} else {\nt2->next = head;\nt2 = t2->next;\n}\nhead = head->next;\n}\nt1->next = d2->next;\nt2->next = nullptr;\nreturn d1->next;\n}\n};\n"]}, {"leetCodeID": "0089", "level": "middle", "question_description": "An n-bit gray code sequence is a sequence of 2n integers where:\nEvery integer is in the inclusive range [0, 2n - 1],\nThe first integer is 0,\nAn integer appears no more than once in the sequence,\nThe binary representation of every pair of adjacent integers differs by exactly one bit, and\nThe binary representation of the first and last integers differs by exactly one bit.\nGiven an integer n, return any valid n-bit gray code sequence.", "examples": ["Example 1:\nInput: n = 2\nOutput: [0,1,3,2]\nExplanation:\nThe binary representation of [0,1,3,2] is [00,01,11,10].\n- 00 and 01 differ by one bit\n- 01 and 11 differ by one bit\n- 11 and 10 differ by one bit\n- 10 and 00 differ by one bit\n[0,2,3,1] is also a valid gray code sequence, whose binary representation is [00,10,11,01].\n- 00 and 10 differ by one bit\n- 10 and 11 differ by one bit\n- 11 and 01 differ by one bit\n- 01 and 00 differ by one bit\n", "Example 2:\nInput: n = 1\nOutput: [0,1]\n"], "constraints": "\nConstraints:\n1 <= n <= 16\n", "java_context": "    \n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number} n\n* @return {number[]}\n*/\nvar grayCode = function (n) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> grayCode(int n) {\n        // your code\n    }\n};", "java_solutions": ["\nint gray(x) {\nreturn x ^ (x >> 1);\n}\n", "\nclass Solution {\npublic List<Integer> grayCode(int n) {\nList<Integer> ans = new ArrayList<>();\nfor (int i = 0; i < 1 << n; ++i) {\nans.add(i ^ (i >> 1));\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number} n\n* @return {number[]}\n*/\nvar grayCode = function (n) {\nconst ans = [];\nfor (let i = 0; i < 1 << n; ++i) {\nans.push(i ^ (i >> 1));\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> grayCode(int n) {\nvector<int> ans;\nfor (int i = 0; i < 1 << n; ++i) {\nans.push_back(i ^ (i >> 1));\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0092", "level": "middle", "question_description": "Given the head of a singly linked list and two integers left and right where left &lt;= right, reverse the nodes of the list from position left to position right, and return the reversed list.", "examples": ["Example 1:\n\n\nInput: head = [1,2,3,4,5], left = 2, right = 4\nOutput: [1,4,3,2,5]\n\n\nExample 2:\nInput: head = [5], left = 1, right = 1\nOutput: [5]\n"], "constraints": "\nConstraints:\nThe number of nodes in the list is n.\n1 <= n <= 500\n-500 <= Node.val <= 500\n1 <= left <= right <= n\n", "java_context": "\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode() {}\n*     ListNode(int val) { this.val = val; }\n*     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n* }\n*/\nclass Solution {\n    public ListNode reverseBetween(ListNode head, int left, int right) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for singly-linked list.\n* function ListNode(val, next) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.next = (next===undefined ? null : next)\n* }\n*/\n/**\n* @param {ListNode} head\n* @param {number} left\n* @param {number} right\n* @return {ListNode}\n*/\nvar reverseBetween = function (head, left, right) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\nclass Solution {\npublic:\n    ListNode* reverseBetween(ListNode* head, int left, int right) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode() {}\n*     ListNode(int val) { this.val = val; }\n*     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n* }\n*/\nclass Solution {\npublic ListNode reverseBetween(ListNode head, int left, int right) {\nif (head.next == null || left == right) {\nreturn head;\n}\nListNode dummy = new ListNode(0, head);\nListNode pre = dummy;\nfor (int i = 0; i < left - 1; ++i) {\npre = pre.next;\n}\nListNode p = pre;\nListNode q = pre.next;\nListNode cur = q;\nfor (int i = 0; i < right - left + 1; ++i) {\nListNode t = cur.next;\ncur.next = pre;\npre = cur;\ncur = t;\n}\np.next = pre;\nq.next = cur;\nreturn dummy.next;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for singly-linked list.\n* function ListNode(val, next) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.next = (next===undefined ? null : next)\n* }\n*/\n/**\n* @param {ListNode} head\n* @param {number} left\n* @param {number} right\n* @return {ListNode}\n*/\nvar reverseBetween = function (head, left, right) {\nif (!head.next || left == right) {\nreturn head;\n}\nconst dummy = new ListNode(0, head);\nlet pre = dummy;\nfor (let i = 0; i < left - 1; ++i) {\npre = pre.next;\n}\nconst p = pre;\nconst q = pre.next;\nlet cur = q;\nfor (let i = 0; i < right - left + 1; ++i) {\nconst t = cur.next;\ncur.next = pre;\npre = cur;\ncur = t;\n}\np.next = pre;\nq.next = cur;\nreturn dummy.next;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\nclass Solution {\npublic:\nListNode* reverseBetween(ListNode* head, int left, int right) {\nif (!head->next || left == right) {\nreturn head;\n}\nListNode* dummy = new ListNode(0, head);\nListNode* pre = dummy;\nfor (int i = 0; i < left - 1; ++i) {\npre = pre->next;\n}\nListNode *p = pre, *q = pre->next;\nListNode* cur = q;\nfor (int i = 0; i < right - left + 1; ++i) {\nListNode* t = cur->next;\ncur->next = pre;\npre = cur;\ncur = t;\n}\np->next = pre;\nq->next = cur;\nreturn dummy->next;\n}\n};\n"]}, {"leetCodeID": "0098", "level": "middle", "question_description": "Given the root of a binary tree, determine if it is a valid binary search tree (BST).\nA valid BST is defined as follows:\nThe left subtree of a node contains only nodes with keys less than the node&#39;s key.\nThe right subtree of a node contains only nodes with keys greater than the node&#39;s key.\nBoth the left and right subtrees must also be binary search trees.", "examples": [], "constraints": "\nConstraints:\nThe number of nodes in the tree is in the range [1, 104].\n-231 <= Node.val <= 231 - 1\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\n    private TreeNode prev;\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {boolean}\n*/\nvar isValidBST = function (root) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    bool isValidBST(TreeNode* root) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\nprivate TreeNode prev;\n\npublic boolean isValidBST(TreeNode root) {\nreturn dfs(root);\n}\n\nprivate boolean dfs(TreeNode root) {\nif (root == null) {\nreturn true;\n}\nif (!dfs(root.left)) {\nreturn false;\n}\nif (prev != null && prev.val >= root.val) {\nreturn false;\n}\nprev = root;\nreturn dfs(root.right);\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {boolean}\n*/\nvar isValidBST = function (root) {\nlet prev = null;\nconst dfs = root => {\nif (!root) {\nreturn true;\n}\nif (!dfs(root.left)) {\nreturn false;\n}\nif (prev && prev.val >= root.val) {\nreturn false;\n}\nprev = root;\nreturn dfs(root.right);\n};\nreturn dfs(root);\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nbool isValidBST(TreeNode* root) {\nTreeNode* prev = nullptr;\nfunction<bool(TreeNode*)> dfs = [&](TreeNode* root) {\nif (!root) {\nreturn true;\n}\nif (!dfs(root->left)) {\nreturn false;\n}\nif (prev && prev->val >= root->val) {\nreturn false;\n}\nprev = root;\nreturn dfs(root->right);\n};\nreturn dfs(root);\n}\n};\n"]}, {"leetCodeID": "0099", "level": "middle", "question_description": "You are given the root of a binary search tree (BST), where the values of exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure.", "examples": [], "constraints": "\nConstraints:\nThe number of nodes in the tree is in the range [2, 1000].\n-231 <= Node.val <= 231 - 1\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\n    private TreeNode prev;\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {void} Do not return anything, modify root in-place instead.\n*/\nvar recoverTree = function (root) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    void recoverTree(TreeNode* root) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\nprivate TreeNode prev;\nprivate TreeNode first;\nprivate TreeNode second;\n\npublic void recoverTree(TreeNode root) {\ndfs(root);\nint t = first.val;\nfirst.val = second.val;\nsecond.val = t;\n}\n\nprivate void dfs(TreeNode root) {\nif (root == null) {\nreturn;\n}\ndfs(root.left);\nif (prev != null && prev.val > root.val) {\nif (first == null) {\nfirst = prev;\n}\nsecond = root;\n}\nprev = root;\ndfs(root.right);\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {void} Do not return anything, modify root in-place instead.\n*/\nvar recoverTree = function (root) {\nlet prev = null;\nlet first = null;\nlet second = null;\nfunction dfs(root) {\nif (!root) {\nreturn;\n}\ndfs(root.left);\nif (prev && prev.val > root.val) {\nif (!first) {\nfirst = prev;\n}\nsecond = root;\n}\nprev = root;\ndfs(root.right);\n}\ndfs(root);\nconst t = first.val;\nfirst.val = second.val;\nsecond.val = t;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nvoid recoverTree(TreeNode* root) {\nTreeNode* prev = nullptr;\nTreeNode* first = nullptr;\nTreeNode* second = nullptr;\nfunction<void(TreeNode * root)> dfs = [&](TreeNode* root) {\nif (!root) return;\ndfs(root->left);\nif (prev && prev->val > root->val) {\nif (!first) first = prev;\nsecond = root;\n}\nprev = root;\ndfs(root->right);\n};\ndfs(root);\nswap(first->val, second->val);\n}\n};\n"]}, {"leetCodeID": "0102", "level": "middle", "question_description": "Given the root of a binary tree, return the level order traversal of its nodes&#39; values. (i.e., from left to right, level by level).", "examples": ["Example 1:\n\n\nInput: root = [3,9,20,null,null,15,7]\nOutput: [[3],[9,20],[15,7]]\n\n\nExample 2:\nInput: root = [1]\nOutput: [[1]]\n", "Example 3:\nInput: root = []\nOutput: []\n"], "constraints": "\nConstraints:\nThe number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {number[][]}\n*/\nvar levelOrder = function (root) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\npublic List<List<Integer>> levelOrder(TreeNode root) {\nList<List<Integer>> ans = new ArrayList<>();\nif (root == null) {\nreturn ans;\n}\nDeque<TreeNode> q = new ArrayDeque<>();\nq.offer(root);\nwhile (!q.isEmpty()) {\nList<Integer> t = new ArrayList<>();\nfor (int n = q.size(); n > 0; --n) {\nTreeNode node = q.poll();\nt.add(node.val);\nif (node.left != null) {\nq.offer(node.left);\n}\nif (node.right != null) {\nq.offer(node.right);\n}\n}\nans.add(t);\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {number[][]}\n*/\nvar levelOrder = function (root) {\nconst ans = [];\nif (!root) {\nreturn ans;\n}\nconst q = [root];\nwhile (q.length) {\nconst t = [];\nconst qq = [];\nfor (const { val, left, right } of q) {\nt.push(val);\nleft && qq.push(left);\nright && qq.push(right);\n}\nans.push(t);\nq.splice(0, q.length, ...qq);\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nvector<vector<int>> levelOrder(TreeNode* root) {\nvector<vector<int>> ans;\nif (!root) return ans;\nqueue<TreeNode*> q{{root}};\nwhile (!q.empty()) {\nvector<int> t;\nfor (int n = q.size(); n; --n) {\nauto node = q.front();\nq.pop();\nt.push_back(node->val);\nif (node->left) {\nq.push(node->left);\n}\nif (node->right) {\nq.push(node->right);\n}\n}\nans.push_back(t);\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0103", "level": "middle", "question_description": "Given the root of a binary tree, return the zigzag level order traversal of its nodes&#39; values. (i.e., from left to right, then right to left for the next level and alternate between).", "examples": ["Example 1:\n\n\nInput: root = [3,9,20,null,null,15,7]\nOutput: [[3],[20,9],[15,7]]\n\n\nExample 2:\nInput: root = [1]\nOutput: [[1]]\n", "Example 3:\nInput: root = []\nOutput: []\n"], "constraints": "\nConstraints:\nThe number of nodes in the tree is in the range [0, 2000].\n-100 <= Node.val <= 100\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {number[][]}\n*/\nvar zigzagLevelOrder = function (root) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    vector<vector<int>> zigzagLevelOrder(TreeNode* root) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\npublic List<List<Integer>> zigzagLevelOrder(TreeNode root) {\nList<List<Integer>> ans = new ArrayList<>();\nif (root == null) {\nreturn ans;\n}\nDeque<TreeNode> q = new ArrayDeque<>();\nq.offer(root);\nboolean left = true;\nwhile (!q.isEmpty()) {\nList<Integer> t = new ArrayList<>();\nfor (int n = q.size(); n > 0; --n) {\nTreeNode node = q.poll();\nt.add(node.val);\nif (node.left != null) {\nq.offer(node.left);\n}\nif (node.right != null) {\nq.offer(node.right);\n}\n}\nif (!left) {\nCollections.reverse(t);\n}\nans.add(t);\nleft = !left;\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {number[][]}\n*/\nvar zigzagLevelOrder = function (root) {\nconst ans = [];\nif (!root) {\nreturn ans;\n}\nconst q = [root];\nlet left = 1;\nwhile (q.length) {\nconst t = [];\nconst qq = [];\nfor (const { val, left, right } of q) {\nt.push(val);\nleft && qq.push(left);\nright && qq.push(right);\n}\nans.push(left ? t : t.reverse());\nq.splice(0, q.length, ...qq);\nleft ^= 1;\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nvector<vector<int>> zigzagLevelOrder(TreeNode* root) {\nvector<vector<int>> ans;\nif (!root) {\nreturn ans;\n}\nqueue<TreeNode*> q{{root}};\nint left = 1;\nwhile (!q.empty()) {\nvector<int> t;\nfor (int n = q.size(); n; --n) {\nauto node = q.front();\nq.pop();\nt.emplace_back(node->val);\nif (node->left) {\nq.push(node->left);\n}\nif (node->right) {\nq.push(node->right);\n}\n}\nif (!left) {\nreverse(t.begin(), t.end());\n}\nans.emplace_back(t);\nleft ^= 1;\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0105", "level": "middle", "question_description": "Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.", "examples": ["Example 1:\n\n\nInput: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]\nOutput: [3,9,20,null,null,15,7]\n\n\nExample 2:\nInput: preorder = [-1], inorder = [-1]\nOutput: [-1]\n"], "constraints": "\nConstraints:\n1 <= preorder.length <= 3000\ninorder.length == preorder.length\n-3000 <= preorder[i], inorder[i] <= 3000\npreorder and inorder consist of unique values.\nEach value of inorder also appears in preorder.\npreorder is guaranteed to be the preorder traversal of the tree.\ninorder is guaranteed to be the inorder traversal of the tree.\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\n    private int[] preorder;\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {number[]} preorder\n* @param {number[]} inorder\n* @return {TreeNode}\n*/\nvar buildTree = function (preorder, inorder) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\nprivate int[] preorder;\nprivate Map<Integer, Integer> d = new HashMap<>();\n\npublic TreeNode buildTree(int[] preorder, int[] inorder) {\nint n = preorder.length;\nthis.preorder = preorder;\nfor (int i = 0; i < n; ++i) {\nd.put(inorder[i], i);\n}\nreturn dfs(0, 0, n);\n}\n\nprivate TreeNode dfs(int i, int j, int n) {\nif (n <= 0) {\nreturn null;\n}\nint v = preorder[i];\nint k = d.get(v);\nTreeNode l = dfs(i + 1, j, k - j);\nTreeNode r = dfs(i + 1 + k - j, k + 1, n - 1 - (k - j));\nreturn new TreeNode(v, l, r);\n}\n}\n", "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\nprivate int[] preorder;\nprivate Map<Integer, Integer> d = new HashMap<>();\n\npublic TreeNode buildTree(int[] preorder, int[] inorder) {\nint n = preorder.length;\nthis.preorder = preorder;\nfor (int i = 0; i < n; ++i) {\nd.put(inorder[i], i);\n}\nreturn dfs(0, 0, n);\n}\n\nprivate TreeNode dfs(int i, int j, int n) {\nif (n <= 0) {\nreturn null;\n}\nint v = preorder[i];\nint k = d.get(v);\nTreeNode l = dfs(i + 1, j, k - j);\nTreeNode r = dfs(i + 1 + k - j, k + 1, n - 1 - (k - j));\nreturn new TreeNode(v, l, r);\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {number[]} preorder\n* @param {number[]} inorder\n* @return {TreeNode}\n*/\nvar buildTree = function (preorder, inorder) {\nconst d = new Map();\nconst n = inorder.length;\nfor (let i = 0; i < n; ++i) {\nd.set(inorder[i], i);\n}\nconst dfs = (i, j, n) => {\nif (n <= 0) {\nreturn null;\n}\nconst v = preorder[i];\nconst k = d.get(v);\nconst l = dfs(i + 1, j, k - j);\nconst r = dfs(i + 1 + k - j, k + 1, n - 1 - (k - j));\nreturn new TreeNode(v, l, r);\n};\nreturn dfs(0, 0, n);\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nTreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\nint n = preorder.size();\nunordered_map<int, int> d;\nfor (int i = 0; i < n; ++i) {\nd[inorder[i]] = i;\n}\nfunction<TreeNode*(int, int, int)> dfs = [&](int i, int j, int n) -> TreeNode* {\nif (n <= 0) {\nreturn nullptr;\n}\nint v = preorder[i];\nint k = d[v];\nTreeNode* l = dfs(i + 1, j, k - j);\nTreeNode* r = dfs(i + 1 + k - j, k + 1, n - 1 - (k - j));\nreturn new TreeNode(v, l, r);\n};\nreturn dfs(0, 0, n);\n}\n};\n", "\n/**\n* struct TreeNode {\n*\tint val;\n*\tstruct TreeNode *left;\n*\tstruct TreeNode *right;\n*\tTreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n* };\n*/\nclass Solution {\npublic:\nvector<TreeNode*> getBinaryTrees(vector<int>& preOrder, vector<int>& inOrder) {\nint n = inOrder.size();\nunordered_map<int, vector<int>> d;\nfor (int i = 0; i < n; ++i) {\nd[inOrder[i]].push_back(i);\n}\nfunction<vector<TreeNode*>(int, int, int)> dfs = [&](int i, int j, int n) -> vector<TreeNode*> {\nvector<TreeNode*> ans;\nif (n <= 0) {\nans.push_back(nullptr);\nreturn ans;\n}\nint v = preOrder[i];\nfor (int k : d[v]) {\nif (k >= j && k < j + n) {\nauto lefts = dfs(i + 1, j, k - j);\nauto rights = dfs(i + 1 + k - j, k + 1, n - 1 - (k - j));\nfor (TreeNode* l : lefts) {\nfor (TreeNode* r : rights) {\nTreeNode* node = new TreeNode(v);\nnode->left = l;\nnode->right = r;\nans.push_back(node);\n}\n}\n}\n}\nreturn ans;\n};\nreturn dfs(0, 0, n);\n}\n};\n"]}, {"leetCodeID": "0107", "level": "middle", "question_description": "Given the root of a binary tree, return the bottom-up level order traversal of its nodes&#39; values. (i.e., from left to right, level by level from leaf to root).", "examples": ["Example 1:\n\n\nInput: root = [3,9,20,null,null,15,7]\nOutput: [[15,7],[9,20],[3]]\n\n\nExample 2:\nInput: root = [1]\nOutput: [[1]]\n", "Example 3:\nInput: root = []\nOutput: []\n"], "constraints": "\nConstraints:\nThe number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\n    public List<List<Integer>> levelOrderBottom(TreeNode root) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {number[][]}\n*/\nvar levelOrderBottom = function (root) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    vector<vector<int>> levelOrderBottom(TreeNode* root) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\npublic List<List<Integer>> levelOrderBottom(TreeNode root) {\nLinkedList<List<Integer>> ans = new LinkedList<>();\nif (root == null) {\nreturn ans;\n}\nDeque<TreeNode> q = new LinkedList<>();\nq.offerLast(root);\nwhile (!q.isEmpty()) {\nList<Integer> t = new ArrayList<>();\nfor (int i = q.size(); i > 0; --i) {\nTreeNode node = q.pollFirst();\nt.add(node.val);\nif (node.left != null) {\nq.offerLast(node.left);\n}\nif (node.right != null) {\nq.offerLast(node.right);\n}\n}\nans.addFirst(t);\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {number[][]}\n*/\nvar levelOrderBottom = function (root) {\nconst ans = [];\nif (!root) {\nreturn ans;\n}\nconst q = [root];\nwhile (q.length) {\nconst t = [];\nconst qq = [];\nfor (const { val, left, right } of q) {\nt.push(val);\nleft && qq.push(left);\nright && qq.push(right);\n}\nans.push(t);\nq.splice(0, q.length, ...qq);\n}\nreturn ans.reverse();\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nvector<vector<int>> levelOrderBottom(TreeNode* root) {\nvector<vector<int>> ans;\nif (!root) {\nreturn ans;\n}\nqueue<TreeNode*> q{{root}};\nwhile (!q.empty()) {\nvector<int> t;\nfor (int n = q.size(); n; --n) {\nauto node = q.front();\nq.pop();\nt.push_back(node->val);\nif (node->left) {\nq.push(node->left);\n}\nif (node->right) {\nq.push(node->right);\n}\n}\nans.push_back(t);\n}\nreverse(ans.begin(), ans.end());\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0109", "level": "middle", "question_description": "Given the head of a singly linked list where elements are sorted in ascending order, convert it to a height-balanced binary search tree.", "examples": ["Example 1:\n\n\nInput: head = [-10,-3,0,5,9]\nOutput: [0,-3,9,-10,null,5]\nExplanation: One possible answer is [0,-3,9,-10,null,5], which represents the shown height balanced BST.\n\n\nExample 2:\nInput: head = []\nOutput: []\n"], "constraints": "\nConstraints:\nThe number of nodes in head is in the range [0, 2 * 104].\n-105 <= Node.val <= 105\n", "java_context": "\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode() {}\n*     ListNode(int val) { this.val = val; }\n*     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n* }\n*/\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for singly-linked list.\n* function ListNode(val, next) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.next = (next===undefined ? null : next)\n* }\n*/\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {ListNode} head\n* @return {TreeNode}\n*/\nvar sortedListToBST = function (head) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    TreeNode* sortedListToBST(ListNode* head) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode() {}\n*     ListNode(int val) { this.val = val; }\n*     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n* }\n*/\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\npublic TreeNode sortedListToBST(ListNode head) {\nList<Integer> nums = new ArrayList<>();\nfor (; head != null; head = head.next) {\nnums.add(head.val);\n}\nreturn buildBST(nums, 0, nums.size() - 1);\n}\n\nprivate TreeNode buildBST(List<Integer> nums, int start, int end) {\nif (start > end) {\nreturn null;\n}\nint mid = (start + end) >> 1;\nTreeNode root = new TreeNode(nums.get(mid));\nroot.left = buildBST(nums, start, mid - 1);\nroot.right = buildBST(nums, mid + 1, end);\nreturn root;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for singly-linked list.\n* function ListNode(val, next) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.next = (next===undefined ? null : next)\n* }\n*/\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {ListNode} head\n* @return {TreeNode}\n*/\nvar sortedListToBST = function (head) {\nconst buildBST = (nums, start, end) => {\nif (start > end) {\nreturn null;\n}\nconst mid = (start + end) >> 1;\nconst root = new TreeNode(nums[mid]);\nroot.left = buildBST(nums, start, mid - 1);\nroot.right = buildBST(nums, mid + 1, end);\nreturn root;\n};\n\nconst nums = new Array();\nfor (; head != null; head = head.next) {\nnums.push(head.val);\n}\nreturn buildBST(nums, 0, nums.length - 1);\n};\n"], "cpp_solutions": ["\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nTreeNode* sortedListToBST(ListNode* head) {\nvector<int> nums;\nfor (; head != nullptr; head = head->next) {\nnums.push_back(head->val);\n}\nreturn buildBST(nums, 0, nums.size() - 1);\n}\n\nprivate:\nTreeNode* buildBST(vector<int>& nums, int start, int end) {\nif (start > end) {\nreturn nullptr;\n}\nint mid = (start + end) / 2;\nTreeNode* root = new TreeNode(nums[mid]);\nroot->left = buildBST(nums, start, mid - 1);\nroot->right = buildBST(nums, mid + 1, end);\nreturn root;\n}\n};\n"]}, {"leetCodeID": "0113", "level": "middle", "question_description": "Given the root of a binary tree and an integer targetSum, return all root-to-leaf paths where the sum of the node values in the path equals targetSum. Each path should be returned as a list of the node values, not node references.\nA root-to-leaf path is a path starting from the root and ending at any leaf node. A leaf is a node with no children.", "examples": ["Example 1:\n\n\nInput: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\nOutput: [[5,4,11,2],[5,8,4,5]]\nExplanation: There are two paths whose sum equals targetSum:\n5 + 4 + 11 + 2 = 22\n5 + 8 + 4 + 5 = 22\n\n\nExample 2:\n\n\nInput: root = [1,2,3], targetSum = 5\nOutput: []\n\n\nExample 3:\nInput: root = [1,2], targetSum = 0\nOutput: []\n"], "constraints": "\nConstraints:\nThe number of nodes in the tree is in the range [0, 5000].\n-1000 <= Node.val <= 1000\n-1000 <= targetSum <= 1000\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\n    private List<List<Integer>> ans = new ArrayList<>();\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @param {number} targetSum\n* @return {number[][]}\n*/\nvar pathSum = function (root, targetSum) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    vector<vector<int>> pathSum(TreeNode* root, int targetSum) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\nprivate List<List<Integer>> ans = new ArrayList<>();\nprivate List<Integer> t = new ArrayList<>();\n\npublic List<List<Integer>> pathSum(TreeNode root, int targetSum) {\ndfs(root, targetSum);\nreturn ans;\n}\n\nprivate void dfs(TreeNode root, int s) {\nif (root == null) {\nreturn;\n}\ns -= root.val;\nt.add(root.val);\nif (root.left == null && root.right == null && s == 0) {\nans.add(new ArrayList<>(t));\n}\ndfs(root.left, s);\ndfs(root.right, s);\nt.remove(t.size() - 1);\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @param {number} targetSum\n* @return {number[][]}\n*/\nvar pathSum = function (root, targetSum) {\nconst ans = [];\nconst t = [];\nfunction dfs(root, s) {\nif (!root) return;\ns -= root.val;\nt.push(root.val);\nif (!root.left && !root.right && s == 0) ans.push([...t]);\ndfs(root.left, s);\ndfs(root.right, s);\nt.pop();\n}\ndfs(root, targetSum);\nreturn ans;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nvector<vector<int>> pathSum(TreeNode* root, int targetSum) {\nvector<vector<int>> ans;\nvector<int> t;\nfunction<void(TreeNode*, int)> dfs = [&](TreeNode* root, int s) {\nif (!root) return;\ns -= root->val;\nt.emplace_back(root->val);\nif (!root->left && !root->right && s == 0) ans.emplace_back(t);\ndfs(root->left, s);\ndfs(root->right, s);\nt.pop_back();\n};\ndfs(root, targetSum);\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0114", "level": "middle", "question_description": "Given the root of a binary tree, flatten the tree into a &quot;linked list&quot;:\nThe &quot;linked list&quot; should use the same TreeNode class where the right child pointer points to the next node in the list and the left child pointer is always null.\nThe &quot;linked list&quot; should be in the same order as a pre-order traversal of the binary tree.", "examples": ["Example 1:\n\n\nInput: root = [1,2,5,3,4,null,6]\nOutput: [1,null,2,null,3,null,4,null,5,null,6]\n\n\nExample 2:\nInput: root = []\nOutput: []\n", "Example 3:\nInput: root = [0]\nOutput: [0]\n"], "constraints": "\nConstraints:\nThe number of nodes in the tree is in the range [0, 2000].\n-100 <= Node.val <= 100\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\n    public void flatten(TreeNode root) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {void} Do not return anything, modify root in-place instead.\n*/\nvar flatten = function (root) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    void flatten(TreeNode* root) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\npublic void flatten(TreeNode root) {\nwhile (root != null) {\nif (root.left != null) {\n// \u627e\u5230\u5f53\u524d\u8282\u70b9\u5de6\u5b50\u6811\u7684\u6700\u53f3\u8282\u70b9\nTreeNode pre = root.left;\nwhile (pre.right != null) {\npre = pre.right;\n}\n\n// \u5c06\u5de6\u5b50\u6811\u7684\u6700\u53f3\u8282\u70b9\u6307\u5411\u539f\u6765\u7684\u53f3\u5b50\u6811\npre.right = root.right;\n\n// \u5c06\u5f53\u524d\u8282\u70b9\u6307\u5411\u5de6\u5b50\u6811\nroot.right = root.left;\nroot.left = null;\n}\nroot = root.right;\n}\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {void} Do not return anything, modify root in-place instead.\n*/\nvar flatten = function (root) {\nwhile (root) {\nif (root.left) {\nlet pre = root.left;\nwhile (pre.right) {\npre = pre.right;\n}\npre.right = root.right;\nroot.right = root.left;\nroot.left = null;\n}\nroot = root.right;\n}\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nvoid flatten(TreeNode* root) {\nwhile (root) {\nif (root->left) {\nTreeNode* pre = root->left;\nwhile (pre->right) {\npre = pre->right;\n}\npre->right = root->right;\nroot->right = root->left;\nroot->left = nullptr;\n}\nroot = root->right;\n}\n}\n};\n"]}, {"leetCodeID": "0122", "level": "middle", "question_description": "You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\nFind and return the maximum profit you can achieve.", "examples": ["Example 1:\nInput: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\n", "Example 2:\nInput: prices = [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.\n", "Example 3:\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.\n"], "constraints": "\nConstraints:\n1 <= prices.length <= 3 * 104\n0 <= prices[i] <= 104\n", "java_context": "\nclass Solution {\n    public int maxProfit(int[] prices) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} prices\n* @return {number}\n*/\nvar maxProfit = function (prices) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int maxProfit(int[] prices) {\nint ans = 0;\nfor (int i = 1; i < prices.length; ++i) {\nans += Math.max(0, prices[i] - prices[i - 1]);\n}\nreturn ans;\n}\n}\n", "\nclass Solution {\npublic int maxProfit(int[] prices) {\nint n = prices.length;\nint[][] f = new int[n][2];\nf[0][0] = -prices[0];\nfor (int i = 1; i < n; ++i) {\nf[i][0] = Math.max(f[i - 1][0], f[i - 1][1] - prices[i]);\nf[i][1] = Math.max(f[i - 1][1], f[i - 1][0] + prices[i]);\n}\nreturn f[n - 1][1];\n}\n}\n", "\nclass Solution {\npublic int maxProfit(int[] prices) {\nint n = prices.length;\nint[] f = new int[] {-prices[0], 0};\nfor (int i = 1; i < n; ++i) {\nint[] g = new int[2];\ng[0] = Math.max(f[0], f[1] - prices[i]);\ng[1] = Math.max(f[1], f[0] + prices[i]);\nf = g;\n}\nreturn f[1];\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} prices\n* @return {number}\n*/\nvar maxProfit = function (prices) {\nlet ans = 0;\nfor (let i = 1; i < prices.length; i++) {\nans += Math.max(0, prices[i] - prices[i - 1]);\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint maxProfit(vector<int>& prices) {\nint ans = 0;\nfor (int i = 1; i < prices.size(); ++i) ans += max(0, prices[i] - prices[i - 1]);\nreturn ans;\n}\n};\n", "\nclass Solution {\npublic:\nint maxProfit(vector<int>& prices) {\nint n = prices.size();\nint f[n][2];\nf[0][0] = -prices[0];\nf[0][1] = 0;\nfor (int i = 1; i < n; ++i) {\nf[i][0] = max(f[i - 1][0], f[i - 1][1] - prices[i]);\nf[i][1] = max(f[i - 1][1], f[i - 1][0] + prices[i]);\n}\nreturn f[n - 1][1];\n}\n};\n", "\nclass Solution {\npublic:\nint maxProfit(vector<int>& prices) {\nint n = prices.size();\nint f[2] = {-prices[0], 0};\nfor (int i = 1; i < n; ++i) {\nint g[2];\ng[0] = max(f[0], f[1] - prices[i]);\ng[1] = max(f[1], f[0] + prices[i]);\nf[0] = g[0], f[1] = g[1];\n}\nreturn f[1];\n}\n};\n"]}, {"leetCodeID": "0128", "level": "middle", "question_description": "Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.\nYou must write an algorithm that runs in O(n) time.", "examples": ["Example 1:\nInput: nums = [100,4,200,1,3,2]\nOutput: 4\nExplanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.\n", "Example 2:\nInput: nums = [0,3,7,2,5,8,4,6,0,1]\nOutput: 9\n"], "constraints": "\nConstraints:\n0 <= nums.length <= 105\n-109 <= nums[i] <= 109\n", "java_context": "\nclass Solution {\n    public int longestConsecutive(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar longestConsecutive = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int longestConsecutive(int[] nums) {\nint n = nums.length;\nif (n < 2) {\nreturn n;\n}\nArrays.sort(nums);\nint ans = 1, t = 1;\nfor (int i = 1; i < n; ++i) {\nif (nums[i] == nums[i - 1]) {\ncontinue;\n}\nif (nums[i] == nums[i - 1] + 1) {\nans = Math.max(ans, ++t);\n} else {\nt = 1;\n}\n}\nreturn ans;\n}\n}\n", "\nclass Solution {\npublic int longestConsecutive(int[] nums) {\nSet<Integer> s = new HashSet<>();\nfor (int x : nums) {\ns.add(x);\n}\nint ans = 0;\nfor (int x : nums) {\nif (!s.contains(x - 1)) {\nint y = x + 1;\nwhile (s.contains(y)) {\n++y;\n}\nans = Math.max(ans, y - x);\n}\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar longestConsecutive = function (nums) {\nconst n = nums.length;\nif (n < 2) {\nreturn n;\n}\nnums.sort((a, b) => a - b);\nlet ans = 1;\nlet t = 1;\nfor (let i = 1; i < n; ++i) {\nif (nums[i] === nums[i - 1]) {\ncontinue;\n}\nif (nums[i] === nums[i - 1] + 1) {\nans = Math.max(ans, ++t);\n} else {\nt = 1;\n}\n}\nreturn ans;\n};\n", "\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar longestConsecutive = function (nums) {\nconst s = new Set(nums);\nlet ans = 0;\nfor (const x of nums) {\nif (!s.has(x - 1)) {\nlet y = x + 1;\nwhile (s.has(y)) {\ny++;\n}\nans = Math.max(ans, y - x);\n}\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint longestConsecutive(vector<int>& nums) {\nint n = nums.size();\nif (n < 2) {\nreturn n;\n}\nsort(nums.begin(), nums.end());\nint ans = 1, t = 1;\nfor (int i = 1; i < n; ++i) {\nif (nums[i] == nums[i - 1]) {\ncontinue;\n}\nif (nums[i] == nums[i - 1] + 1) {\nans = max(ans, ++t);\n} else {\nt = 1;\n}\n}\nreturn ans;\n}\n};\n", "\nclass Solution {\npublic:\nint longestConsecutive(vector<int>& nums) {\nunordered_set<int> s(nums.begin(), nums.end());\nint ans = 0;\nfor (int x : nums) {\nif (!s.count(x - 1)) {\nint y = x + 1;\nwhile (s.count(y)) {\ny++;\n}\nans = max(ans, y - x);\n}\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0129", "level": "middle", "question_description": "You are given the root of a binary tree containing digits from 0 to 9 only.\nEach root-to-leaf path in the tree represents a number.\nFor example, the root-to-leaf path 1 -&gt; 2 -&gt; 3 represents the number 123.\nReturn the total sum of all root-to-leaf numbers. Test cases are generated so that the answer will fit in a 32-bit integer.\nA leaf node is a node with no children.", "examples": [], "constraints": "\nConstraints:\nThe number of nodes in the tree is in the range [1, 1000].\n0 <= Node.val <= 9\nThe depth of the tree will not exceed 10.\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {number}\n*/\nvar sumNumbers = function (root) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    int sumNumbers(TreeNode* root) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\npublic int sumNumbers(TreeNode root) {\nreturn dfs(root, 0);\n}\n\nprivate int dfs(TreeNode root, int s) {\nif (root == null) {\nreturn 0;\n}\ns = s * 10 + root.val;\nif (root.left == null && root.right == null) {\nreturn s;\n}\nreturn dfs(root.left, s) + dfs(root.right, s);\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {number}\n*/\nvar sumNumbers = function (root) {\nfunction dfs(root, s) {\nif (!root) return 0;\ns = s * 10 + root.val;\nif (!root.left && !root.right) return s;\nreturn dfs(root.left, s) + dfs(root.right, s);\n}\nreturn dfs(root, 0);\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nint sumNumbers(TreeNode* root) {\nfunction<int(TreeNode*, int)> dfs = [&](TreeNode* root, int s) -> int {\nif (!root) return 0;\ns = s * 10 + root->val;\nif (!root->left && !root->right) return s;\nreturn dfs(root->left, s) + dfs(root->right, s);\n};\nreturn dfs(root, 0);\n}\n};\n"]}, {"leetCodeID": "0138", "level": "middle", "question_description": "A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null.\nConstruct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list.\nFor example, if there are two nodes X and Y in the original list, where X.random --&gt; Y, then for the corresponding two nodes x and y in the copied list, x.random --&gt; y.\nReturn the head of the copied linked list.\nThe linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of [val, random_index] where:\nval: an integer representing Node.val\nrandom_index: the index of the node (range from 0 to n-1) that the random pointer points to, or null if it does not point to any node.\nYour code will only be given the head of the original linked list.", "examples": ["Example 1:\n\n\nInput: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]\nOutput: [[7,null],[13,0],[11,4],[10,2],[1,0]]\n\n\nExample 2:\n\n\nInput: head = [[1,1],[2,1]]\nOutput: [[1,1],[2,1]]\n\n\nExample 3:\n\n\nInput: head = [[3,null],[3,0],[3,null]]\nOutput: [[3,null],[3,0],[3,null]]\n"], "constraints": "\nConstraints:\n0 <= n <= 1000\n-104 <= Node.val <= 104\nNode.random is null or is pointing to some node in the linked list.\n", "java_context": "\n/*\n// Definition for a Node.\nclass Node {\nint val;\nNode next;\nNode random;\n\npublic Node(int val) {\nthis.val = val;\nthis.next = null;\nthis.random = null;\n}\n}\n*/\nclass Solution {\n    public Node copyRandomList(Node head) {\n        // your code\n    }\n}", "js_context": "\n/**\n* // Definition for a Node.\n* function Node(val, next, random) {\n*    this.val = val;\n*    this.next = next;\n*    this.random = random;\n* };\n*/\n\n/**\n* @param {Node} head\n* @return {Node}\n*/\nvar copyRandomList = function (head) {\n    // your code\n};", "cpp_context": "\n/*\n// Definition for a Node.\nclass Node {\npublic:\nint val;\nNode* next;\nNode* random;\n\nNode(int _val) {\nval = _val;\nnext = NULL;\nrandom = NULL;\n}\n};\n*/\nclass Solution {\npublic:\n    Node* copyRandomList(Node* head) {\n        // your code\n    }\n};", "java_solutions": ["\n/*\n// Definition for a Node.\nclass Node {\nint val;\nNode next;\nNode random;\n\npublic Node(int val) {\nthis.val = val;\nthis.next = null;\nthis.random = null;\n}\n}\n*/\nclass Solution {\npublic Node copyRandomList(Node head) {\nMap<Node, Node> d = new HashMap<>();\nNode dummy = new Node(0);\nNode tail = dummy;\nfor (Node cur = head; cur != null; cur = cur.next) {\ntail.next = new Node(cur.val);\ntail = tail.next;\nd.put(cur, tail);\n}\ntail = dummy.next;\nfor (Node cur = head; cur != null; cur = cur.next) {\ntail.random = d.get(cur.random);\ntail = tail.next;\n}\nreturn dummy.next;\n}\n}\n", "\n/*\n// Definition for a Node.\nclass Node {\nint val;\nNode next;\nNode random;\n\npublic Node(int val) {\nthis.val = val;\nthis.next = null;\nthis.random = null;\n}\n}\n*/\nclass Solution {\npublic Node copyRandomList(Node head) {\nif (head == null) {\nreturn null;\n}\nfor (Node cur = head; cur != null;) {\nNode node = new Node(cur.val, cur.next);\ncur.next = node;\ncur = node.next;\n}\nfor (Node cur = head; cur != null; cur = cur.next.next) {\nif (cur.random != null) {\ncur.next.random = cur.random.next;\n}\n}\nNode ans = head.next;\nfor (Node cur = head; cur != null;) {\nNode nxt = cur.next;\nif (nxt != null) {\ncur.next = nxt.next;\n}\ncur = nxt;\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* // Definition for a Node.\n* function Node(val, next, random) {\n*    this.val = val;\n*    this.next = next;\n*    this.random = random;\n* };\n*/\n\n/**\n* @param {Node} head\n* @return {Node}\n*/\nvar copyRandomList = function (head) {\nconst d = new Map();\nconst dummy = new Node(0);\nlet tail = dummy;\nfor (let cur = head; cur; cur = cur.next) {\ntail.next = new Node(cur.val);\ntail = tail.next;\nd.set(cur, tail);\n}\ntail = dummy.next;\nfor (let cur = head; cur; cur = cur.next) {\ntail.random = d.get(cur.random);\ntail = tail.next;\n}\nreturn dummy.next;\n};\n", "\n/**\n* // Definition for a Node.\n* function Node(val, next, random) {\n*    this.val = val;\n*    this.next = next;\n*    this.random = random;\n* };\n*/\n\n/**\n* @param {Node} head\n* @return {Node}\n*/\nvar copyRandomList = function (head) {\nif (!head) {\nreturn null;\n}\nfor (let cur = head; cur; ) {\nconst node = new Node(cur.val, cur.next, null);\ncur.next = node;\ncur = node.next;\n}\nfor (let cur = head; cur; cur = cur.next.next) {\nif (cur.random) {\ncur.next.random = cur.random.next;\n}\n}\nconst ans = head.next;\nfor (let cur = head; cur; ) {\nconst nxt = cur.next;\nif (nxt) {\ncur.next = nxt.next;\n}\ncur = nxt;\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\n/*\n// Definition for a Node.\nclass Node {\npublic:\nint val;\nNode* next;\nNode* random;\n\nNode(int _val) {\nval = _val;\nnext = NULL;\nrandom = NULL;\n}\n};\n*/\nclass Solution {\npublic:\nNode* copyRandomList(Node* head) {\nunordered_map<Node*, Node*> d;\nNode* dummy = new Node(0);\nNode* tail = dummy;\nfor (auto cur = head; cur; cur = cur->next) {\ntail->next = new Node(cur->val);\ntail = tail->next;\nd[cur] = tail;\n}\ntail = dummy->next;\nfor (auto cur = head; cur; cur = cur->next) {\ntail->random = d[cur->random];\ntail = tail->next;\n}\nreturn dummy->next;\n}\n};\n", "\n/*\n// Definition for a Node.\nclass Node {\npublic:\nint val;\nNode* next;\nNode* random;\n\nNode(int _val) {\nval = _val;\nnext = NULL;\nrandom = NULL;\n}\n};\n*/\nclass Solution {\npublic:\nNode* copyRandomList(Node* head) {\nif (!head) {\nreturn nullptr;\n}\nfor (Node* cur = head; cur;) {\nNode* node = new Node(cur->val);\nnode->next = cur->next;\ncur->next = node;\ncur = node->next;\n}\nfor (Node* cur = head; cur; cur = cur->next->next) {\nif (cur->random) {\ncur->next->random = cur->random->next;\n}\n}\nNode* ans = head->next;\nfor (Node* cur = head; cur;) {\nNode* nxt = cur->next;\nif (nxt) {\ncur->next = nxt->next;\n}\ncur = nxt;\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0142", "level": "middle", "question_description": "Given the head of a linked list, return the node where the cycle begins. If there is no cycle, return null.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail&#39;s next pointer is connected to (0-indexed). It is -1 if there is no cycle. Note that pos is not passed as a parameter.\nDo not modify the linked list.", "examples": [], "constraints": "\nConstraints:\nThe number of the nodes in the list is in the range [0, 104].\n-105 <= Node.val <= 105\npos is -1 or a valid index in the linked-list.\n", "java_context": "    \n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for singly-linked list.\n* function ListNode(val) {\n*     this.val = val;\n*     this.next = null;\n* }\n*/\n\n/**\n* @param {ListNode} head\n* @return {ListNode}\n*/\nvar detectCycle = function (head) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode(int x) : val(x), next(NULL) {}\n* };\n*/\nclass Solution {\npublic:\n    ListNode* detectCycle(ListNode* head) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for singly-linked list.\n* class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode(int x) {\n*         val = x;\n*         next = null;\n*     }\n* }\n*/\npublic class Solution {\npublic ListNode detectCycle(ListNode head) {\nListNode fast = head, slow = head;\nwhile (fast != null && fast.next != null) {\nslow = slow.next;\nfast = fast.next.next;\nif (slow == fast) {\nListNode ans = head;\nwhile (ans != slow) {\nans = ans.next;\nslow = slow.next;\n}\nreturn ans;\n}\n}\nreturn null;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for singly-linked list.\n* function ListNode(val) {\n*     this.val = val;\n*     this.next = null;\n* }\n*/\n\n/**\n* @param {ListNode} head\n* @return {ListNode}\n*/\nvar detectCycle = function (head) {\nlet [slow, fast] = [head, head];\nwhile (fast && fast.next) {\nslow = slow.next;\nfast = fast.next.next;\nif (slow === fast) {\nlet ans = head;\nwhile (ans !== slow) {\nans = ans.next;\nslow = slow.next;\n}\nreturn ans;\n}\n}\nreturn null;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode(int x) : val(x), next(NULL) {}\n* };\n*/\nclass Solution {\npublic:\nListNode* detectCycle(ListNode* head) {\nListNode* fast = head;\nListNode* slow = head;\nwhile (fast && fast->next) {\nslow = slow->next;\nfast = fast->next->next;\nif (slow == fast) {\nListNode* ans = head;\nwhile (ans != slow) {\nans = ans->next;\nslow = slow->next;\n}\nreturn ans;\n}\n}\nreturn nullptr;\n}\n};\n"]}, {"leetCodeID": "0143", "level": "middle", "question_description": "You are given the head of a singly linked-list. The list can be represented as:\nL0 &rarr; L1 &rarr; &hellip; &rarr; Ln - 1 &rarr; Ln\nReorder the list to be on the following form:\nL0 &rarr; Ln &rarr; L1 &rarr; Ln - 1 &rarr; L2 &rarr; Ln - 2 &rarr; &hellip;\nYou may not modify the values in the list&#39;s nodes. Only nodes themselves may be changed.", "examples": [], "constraints": "\nConstraints:\nThe number of nodes in the list is in the range [1, 5 * 104].\n1 <= Node.val <= 1000\n", "java_context": "\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode() {}\n*     ListNode(int val) { this.val = val; }\n*     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n* }\n*/\nclass Solution {\n    public void reorderList(ListNode head) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for singly-linked list.\n* function ListNode(val, next) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.next = (next===undefined ? null : next)\n* }\n*/\n/**\n* @param {ListNode} head\n* @return {void} Do not return anything, modify head in-place instead.\n*/\nvar reorderList = function (head) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\nclass Solution {\npublic:\n    void reorderList(ListNode* head) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode() {}\n*     ListNode(int val) { this.val = val; }\n*     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n* }\n*/\nclass Solution {\npublic void reorderList(ListNode head) {\nListNode fast = head, slow = head;\nwhile (fast.next != null && fast.next.next != null) {\nslow = slow.next;\nfast = fast.next.next;\n}\n\nListNode cur = slow.next;\nslow.next = null;\n\nListNode pre = null;\nwhile (cur != null) {\nListNode t = cur.next;\ncur.next = pre;\npre = cur;\ncur = t;\n}\ncur = head;\n\nwhile (pre != null) {\nListNode t = pre.next;\npre.next = cur.next;\ncur.next = pre;\ncur = pre.next;\npre = t;\n}\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for singly-linked list.\n* function ListNode(val, next) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.next = (next===undefined ? null : next)\n* }\n*/\n/**\n* @param {ListNode} head\n* @return {void} Do not return anything, modify head in-place instead.\n*/\nvar reorderList = function (head) {\nlet slow = head;\nlet fast = head;\nwhile (fast.next && fast.next.next) {\nslow = slow.next;\nfast = fast.next.next;\n}\n\nlet cur = slow.next;\nslow.next = null;\n\nlet pre = null;\nwhile (cur) {\nconst t = cur.next;\ncur.next = pre;\npre = cur;\ncur = t;\n}\ncur = head;\n\nwhile (pre) {\nconst t = pre.next;\npre.next = cur.next;\ncur.next = pre;\ncur = pre.next;\npre = t;\n}\n};\n"], "cpp_solutions": ["\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\nclass Solution {\npublic:\nvoid reorderList(ListNode* head) {\nListNode* fast = head;\nListNode* slow = head;\nwhile (fast->next && fast->next->next) {\nslow = slow->next;\nfast = fast->next->next;\n}\n\nListNode* cur = slow->next;\nslow->next = nullptr;\n\nListNode* pre = nullptr;\nwhile (cur) {\nListNode* t = cur->next;\ncur->next = pre;\npre = cur;\ncur = t;\n}\ncur = head;\n\nwhile (pre) {\nListNode* t = pre->next;\npre->next = cur->next;\ncur->next = pre;\ncur = pre->next;\npre = t;\n}\n}\n};\n"]}, {"leetCodeID": "0148", "level": "middle", "question_description": "Given the head of a linked list, return the list after sorting it in ascending order.", "examples": ["Example 1:\n\n\nInput: head = [4,2,1,3]\nOutput: [1,2,3,4]\n\n\nExample 2:\n\n\nInput: head = [-1,5,3,4,0]\nOutput: [-1,0,3,4,5]\n\n\nExample 3:\nInput: head = []\nOutput: []\n"], "constraints": "\nConstraints:\nThe number of nodes in the list is in the range [0, 5 * 104].\n-105 <= Node.val <= 105\n", "java_context": "\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode() {}\n*     ListNode(int val) { this.val = val; }\n*     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n* }\n*/\nclass Solution {\n    public ListNode sortList(ListNode head) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for singly-linked list.\n* function ListNode(val, next) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.next = (next===undefined ? null : next)\n* }\n*/\n/**\n* @param {ListNode} head\n* @return {ListNode}\n*/\nvar sortList = function (head) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\nclass Solution {\npublic:\n    ListNode* sortList(ListNode* head) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode() {}\n*     ListNode(int val) { this.val = val; }\n*     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n* }\n*/\nclass Solution {\npublic ListNode sortList(ListNode head) {\nif (head == null || head.next == null) {\nreturn head;\n}\nListNode slow = head, fast = head.next;\nwhile (fast != null && fast.next != null) {\nslow = slow.next;\nfast = fast.next.next;\n}\nListNode t = slow.next;\nslow.next = null;\nListNode l1 = sortList(head);\nListNode l2 = sortList(t);\nListNode dummy = new ListNode();\nListNode cur = dummy;\nwhile (l1 != null && l2 != null) {\nif (l1.val <= l2.val) {\ncur.next = l1;\nl1 = l1.next;\n} else {\ncur.next = l2;\nl2 = l2.next;\n}\ncur = cur.next;\n}\ncur.next = l1 == null ? l2 : l1;\nreturn dummy.next;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for singly-linked list.\n* function ListNode(val, next) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.next = (next===undefined ? null : next)\n* }\n*/\n/**\n* @param {ListNode} head\n* @return {ListNode}\n*/\nvar sortList = function (head) {\nif (!head || !head.next) {\nreturn head;\n}\nlet slow = head;\nlet fast = head.next;\nwhile (fast && fast.next) {\nslow = slow.next;\nfast = fast.next.next;\n}\nlet t = slow.next;\nslow.next = null;\nlet l1 = sortList(head);\nlet l2 = sortList(t);\nconst dummy = new ListNode();\nlet cur = dummy;\nwhile (l1 && l2) {\nif (l1.val <= l2.val) {\ncur.next = l1;\nl1 = l1.next;\n} else {\ncur.next = l2;\nl2 = l2.next;\n}\ncur = cur.next;\n}\ncur.next = l1 || l2;\nreturn dummy.next;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\nclass Solution {\npublic:\nListNode* sortList(ListNode* head) {\nif (!head || !head->next) return head;\nauto* slow = head;\nauto* fast = head->next;\nwhile (fast && fast->next) {\nslow = slow->next;\nfast = fast->next->next;\n}\nauto* t = slow->next;\nslow->next = nullptr;\nauto* l1 = sortList(head);\nauto* l2 = sortList(t);\nauto* dummy = new ListNode();\nauto* cur = dummy;\nwhile (l1 && l2) {\nif (l1->val <= l2->val) {\ncur->next = l1;\nl1 = l1->next;\n} else {\ncur->next = l2;\nl2 = l2->next;\n}\ncur = cur->next;\n}\ncur->next = l1 ? l1 : l2;\nreturn dummy->next;\n}\n};\n"]}, {"leetCodeID": "0152", "level": "middle", "question_description": "Given an integer array nums, find a subarray that has the largest product, and return the product.\nThe test cases are generated so that the answer will fit in a 32-bit integer.", "examples": ["Example 1:\nInput: nums = [2,3,-2,4]\nOutput: 6\nExplanation: [2,3] has the largest product 6.\n", "Example 2:\nInput: nums = [-2,0,-1]\nOutput: 0\nExplanation: The result cannot be 2, because [-2,-1] is not a subarray.\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 2 * 104\n-10 <= nums[i] <= 10\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\n", "java_context": "\nclass Solution {\n    public int maxProduct(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar maxProduct = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int maxProduct(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int maxProduct(int[] nums) {\nint f = nums[0], g = nums[0], ans = nums[0];\nfor (int i = 1; i < nums.length; ++i) {\nint ff = f, gg = g;\nf = Math.max(nums[i], Math.max(ff * nums[i], gg * nums[i]));\ng = Math.min(nums[i], Math.min(ff * nums[i], gg * nums[i]));\nans = Math.max(ans, f);\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar maxProduct = function (nums) {\nlet [f, g, ans] = [nums[0], nums[0], nums[0]];\nfor (let i = 1; i < nums.length; ++i) {\nconst [ff, gg] = [f, g];\nf = Math.max(nums[i], ff * nums[i], gg * nums[i]);\ng = Math.min(nums[i], ff * nums[i], gg * nums[i]);\nans = Math.max(ans, f);\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint maxProduct(vector<int>& nums) {\nint f = nums[0], g = nums[0], ans = nums[0];\nfor (int i = 1; i < nums.size(); ++i) {\nint ff = f, gg = g;\nf = max({nums[i], ff * nums[i], gg * nums[i]});\ng = min({nums[i], ff * nums[i], gg * nums[i]});\nans = max(ans, f);\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0153", "level": "middle", "question_description": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:\n[4,5,6,7,0,1,2] if it was rotated 4 times.\n[0,1,2,4,5,6,7] if it was rotated 7 times.\nNotice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].\nGiven the sorted rotated array nums of unique elements, return the minimum element of this array.\nYou must write an algorithm that runs in O(log n) time.", "examples": ["Example 1:\nInput: nums = [3,4,5,1,2]\nOutput: 1\nExplanation: The original array was [1,2,3,4,5] rotated 3 times.\n", "Example 2:\nInput: nums = [4,5,6,7,0,1,2]\nOutput: 0\nExplanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.\n", "Example 3:\nInput: nums = [11,13,15,17]\nOutput: 11\nExplanation: The original array was [11,13,15,17] and it was rotated 4 times.\n"], "constraints": "\nConstraints:\nn == nums.length\n1 <= n <= 5000\n-5000 <= nums[i] <= 5000\nAll the integers of nums are unique.\nnums is sorted and rotated between 1 and n times.\n", "java_context": "\nclass Solution {\n    public int findMin(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar findMin = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int findMin(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int findMin(int[] nums) {\nint n = nums.length;\nif (nums[0] <= nums[n - 1]) {\nreturn nums[0];\n}\nint left = 0, right = n - 1;\nwhile (left < right) {\nint mid = (left + right) >> 1;\nif (nums[0] <= nums[mid]) {\nleft = mid + 1;\n} else {\nright = mid;\n}\n}\nreturn nums[left];\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar findMin = function (nums) {\nlet l = 0,\nr = nums.length - 1;\nif (nums[l] < nums[r]) return nums[0];\nwhile (l < r) {\nconst m = (l + r) >> 1;\nif (nums[m] > nums[r]) l = m + 1;\nelse r = m;\n}\nreturn nums[l];\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint findMin(vector<int>& nums) {\nint n = nums.size();\nif (nums[0] <= nums[n - 1]) return nums[0];\nint left = 0, right = n - 1;\nwhile (left < right) {\nint mid = (left + right) >> 1;\nif (nums[0] <= nums[mid])\nleft = mid + 1;\nelse\nright = mid;\n}\nreturn nums[left];\n}\n};\n"]}, {"leetCodeID": "0155", "level": "middle", "question_description": "Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\nImplement the MinStack class:\nMinStack() initializes the stack object.\nvoid push(int val) pushes the element val onto the stack.\nvoid pop() removes the element on the top of the stack.\nint top() gets the top element of the stack.\nint getMin() retrieves the minimum element in the stack.\nYou must implement a solution with O(1) time complexity for each function.", "examples": ["Example 1:\nInput\n[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;]\n[[],[-2],[0],[-3],[],[],[],[]]\n\nOutput\n[null,null,null,null,-3,null,0,-2]\n\nExplanation\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin(); // return -3\nminStack.pop();\nminStack.top();    // return 0\nminStack.getMin(); // return -2\n"], "constraints": "\nConstraints:\n-231 <= val <= 231 - 1\nMethods pop, top and getMin operations will always be called on non-empty stacks.\nAt most 3 * 104 calls will be made to push, pop, top, and getMin.\n", "java_context": "    \n        // your code\n    }\n}", "js_context": "\nvar MinStack = function () {\n    // your code\n};", "cpp_context": "    \n        // your code\n    }\n};", "java_solutions": ["\nclass MinStack {\nprivate Deque<Integer> stk1 = new ArrayDeque<>();\nprivate Deque<Integer> stk2 = new ArrayDeque<>();\n\npublic MinStack() {\nstk2.push(Integer.MAX_VALUE);\n}\n\npublic void push(int val) {\nstk1.push(val);\nstk2.push(Math.min(val, stk2.peek()));\n}\n\npublic void pop() {\nstk1.pop();\nstk2.pop();\n}\n\npublic int top() {\nreturn stk1.peek();\n}\n\npublic int getMin() {\nreturn stk2.peek();\n}\n}\n\n/**\n* Your MinStack object will be instantiated and called as such:\n* MinStack obj = new MinStack();\n* obj.push(val);\n* obj.pop();\n* int param_3 = obj.top();\n* int param_4 = obj.getMin();\n*/\n"], "js_solutions": ["\nvar MinStack = function () {\nthis.stk1 = [];\nthis.stk2 = [Infinity];\n};\n\n/**\n* @param {number} val\n* @return {void}\n*/\nMinStack.prototype.push = function (val) {\nthis.stk1.push(val);\nthis.stk2.push(Math.min(this.stk2[this.stk2.length - 1], val));\n};\n\n/**\n* @return {void}\n*/\nMinStack.prototype.pop = function () {\nthis.stk1.pop();\nthis.stk2.pop();\n};\n\n/**\n* @return {number}\n*/\nMinStack.prototype.top = function () {\nreturn this.stk1[this.stk1.length - 1];\n};\n\n/**\n* @return {number}\n*/\nMinStack.prototype.getMin = function () {\nreturn this.stk2[this.stk2.length - 1];\n};\n\n/**\n* Your MinStack object will be instantiated and called as such:\n* var obj = new MinStack()\n* obj.push(val)\n* obj.pop()\n* var param_3 = obj.top()\n* var param_4 = obj.getMin()\n*/\n"], "cpp_solutions": ["\nclass MinStack {\npublic:\nMinStack() {\nstk2.push(INT_MAX);\n}\n\nvoid push(int val) {\nstk1.push(val);\nstk2.push(min(val, stk2.top()));\n}\n\nvoid pop() {\nstk1.pop();\nstk2.pop();\n}\n\nint top() {\nreturn stk1.top();\n}\n\nint getMin() {\nreturn stk2.top();\n}\n\nprivate:\nstack<int> stk1;\nstack<int> stk2;\n};\n\n/**\n* Your MinStack object will be instantiated and called as such:\n* MinStack* obj = new MinStack();\n* obj->push(val);\n* obj->pop();\n* int param_3 = obj->top();\n* int param_4 = obj->getMin();\n*/\n"]}, {"leetCodeID": "0167", "level": "middle", "question_description": "Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 &lt;= index1 &lt; index2 &lt;= numbers.length.\nReturn the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.\nThe tests are generated such that there is exactly one solution. You may not use the same element twice.\nYour solution must use only constant extra space.", "examples": ["Example 1:\nInput: numbers = [2,7,11,15], target = 9\nOutput: [1,2]\nExplanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2].\n", "Example 2:\nInput: numbers = [2,3,4], target = 6\nOutput: [1,3]\nExplanation: The sum of 2 and 4 is 6. Therefore index1 = 1, index2 = 3. We return [1, 3].\n", "Example 3:\nInput: numbers = [-1,0], target = -1\nOutput: [1,2]\nExplanation: The sum of -1 and 0 is -1. Therefore index1 = 1, index2 = 2. We return [1, 2].\n"], "constraints": "\nConstraints:\n2 <= numbers.length <= 3 * 104\n-1000 <= numbers[i] <= 1000\nnumbers is sorted in non-decreasing order.\n-1000 <= target <= 1000\nThe tests are generated such that there is exactly one solution.\n", "java_context": "\nclass Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} numbers\n* @param {number} target\n* @return {number[]}\n*/\nvar twoSum = function (numbers, target) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> twoSum(vector<int>& numbers, int target) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int[] twoSum(int[] numbers, int target) {\nfor (int i = 0, n = numbers.length;; ++i) {\nint x = target - numbers[i];\nint l = i + 1, r = n - 1;\nwhile (l < r) {\nint mid = (l + r) >> 1;\nif (numbers[mid] >= x) {\nr = mid;\n} else {\nl = mid + 1;\n}\n}\nif (numbers[l] == x) {\nreturn new int[] {i + 1, l + 1};\n}\n}\n}\n}\n", "\nclass Solution {\npublic int[] twoSum(int[] numbers, int target) {\nfor (int i = 0, j = numbers.length - 1;;) {\nint x = numbers[i] + numbers[j];\nif (x == target) {\nreturn new int[] {i + 1, j + 1};\n}\nif (x < target) {\n++i;\n} else {\n--j;\n}\n}\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} numbers\n* @param {number} target\n* @return {number[]}\n*/\nvar twoSum = function (numbers, target) {\nconst n = numbers.length;\nfor (let i = 0; ; ++i) {\nconst x = target - numbers[i];\nlet l = i + 1;\nlet r = n - 1;\nwhile (l < r) {\nconst mid = (l + r) >> 1;\nif (numbers[mid] >= x) {\nr = mid;\n} else {\nl = mid + 1;\n}\n}\nif (numbers[l] === x) {\nreturn [i + 1, l + 1];\n}\n}\n};\n", "\n/**\n* @param {number[]} numbers\n* @param {number} target\n* @return {number[]}\n*/\nvar twoSum = function (numbers, target) {\nfor (let i = 0, j = numbers.length - 1; ; ) {\nconst x = numbers[i] + numbers[j];\nif (x === target) {\nreturn [i + 1, j + 1];\n}\nif (x < target) {\n++i;\n} else {\n--j;\n}\n}\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> twoSum(vector<int>& numbers, int target) {\nfor (int i = 0, n = numbers.size();; ++i) {\nint x = target - numbers[i];\nint j = lower_bound(numbers.begin() + i + 1, numbers.end(), x) - numbers.begin();\nif (j < n && numbers[j] == x) {\nreturn {i + 1, j + 1};\n}\n}\n}\n};\n", "\nclass Solution {\npublic:\nvector<int> twoSum(vector<int>& numbers, int target) {\nfor (int i = 0, j = numbers.size() - 1;;) {\nint x = numbers[i] + numbers[j];\nif (x == target) {\nreturn {i + 1, j + 1};\n}\nif (x < target) {\n++i;\n} else {\n--j;\n}\n}\n}\n};\n"]}, {"leetCodeID": "0173", "level": "middle", "question_description": "Implement the BSTIterator class that represents an iterator over the in-order traversal of a binary search tree (BST):\nBSTIterator(TreeNode root) Initializes an object of the BSTIterator class. The root of the BST is given as part of the constructor. The pointer should be initialized to a non-existent number smaller than any element in the BST.\nboolean hasNext() Returns true if there exists a number in the traversal to the right of the pointer, otherwise returns false.\nint next() Moves the pointer to the right, then returns the number at the pointer.\nNotice that by initializing the pointer to a non-existent smallest number, the first call to next() will return the smallest element in the BST.\nYou may assume that next() calls will always be valid. That is, there will be at least a next number in the in-order traversal when next() is called.", "examples": [], "constraints": "\nConstraints:\nThe number of nodes in the tree is in the range [1, 105].\n0 <= Node.val <= 106\nAt most 105 calls will be made to hasNext, and next.\n", "java_context": "    \n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n*/\nvar BSTIterator = function (root) {\n    // your code\n};", "cpp_context": "    \n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass BSTIterator {\nprivate int cur = 0;\nprivate List<Integer> vals = new ArrayList<>();\n\npublic BSTIterator(TreeNode root) {\ninorder(root);\n}\n\npublic int next() {\nreturn vals.get(cur++);\n}\n\npublic boolean hasNext() {\nreturn cur < vals.size();\n}\n\nprivate void inorder(TreeNode root) {\nif (root != null) {\ninorder(root.left);\nvals.add(root.val);\ninorder(root.right);\n}\n}\n}\n\n/**\n* Your BSTIterator object will be instantiated and called as such:\n* BSTIterator obj = new BSTIterator(root);\n* int param_1 = obj.next();\n* boolean param_2 = obj.hasNext();\n*/\n", "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass BSTIterator {\nprivate Deque<TreeNode> stack = new LinkedList<>();\n\npublic BSTIterator(TreeNode root) {\nfor (; root != null; root = root.left) {\nstack.offerLast(root);\n}\n}\n\npublic int next() {\nTreeNode cur = stack.pollLast();\nfor (TreeNode node = cur.right; node != null; node = node.left) {\nstack.offerLast(node);\n}\nreturn cur.val;\n}\n\npublic boolean hasNext() {\nreturn !stack.isEmpty();\n}\n}\n\n/**\n* Your BSTIterator object will be instantiated and called as such:\n* BSTIterator obj = new BSTIterator(root);\n* int param_1 = obj.next();\n* boolean param_2 = obj.hasNext();\n*/\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n*/\nvar BSTIterator = function (root) {\nthis.stack = [];\nfor (; root != null; root = root.left) {\nthis.stack.push(root);\n}\n};\n\n/**\n* @return {number}\n*/\nBSTIterator.prototype.next = function () {\nlet cur = this.stack.pop();\nlet node = cur.right;\nfor (; node != null; node = node.left) {\nthis.stack.push(node);\n}\nreturn cur.val;\n};\n\n/**\n* @return {boolean}\n*/\nBSTIterator.prototype.hasNext = function () {\nreturn this.stack.length > 0;\n};\n\n/**\n* Your BSTIterator object will be instantiated and called as such:\n* var obj = new BSTIterator(root)\n* var param_1 = obj.next()\n* var param_2 = obj.hasNext()\n*/\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass BSTIterator {\npublic:\nvector<int> vals;\nint cur;\nBSTIterator(TreeNode* root) {\ncur = 0;\ninorder(root);\n}\n\nint next() {\nreturn vals[cur++];\n}\n\nbool hasNext() {\nreturn cur < vals.size();\n}\n\nvoid inorder(TreeNode* root) {\nif (root) {\ninorder(root->left);\nvals.push_back(root->val);\ninorder(root->right);\n}\n}\n};\n\n/**\n* Your BSTIterator object will be instantiated and called as such:\n* BSTIterator* obj = new BSTIterator(root);\n* int param_1 = obj->next();\n* bool param_2 = obj->hasNext();\n*/\n", "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass BSTIterator {\npublic:\nstack<TreeNode*> stack;\nBSTIterator(TreeNode* root) {\nfor (; root != nullptr; root = root->left) {\nstack.push(root);\n}\n}\n\nint next() {\nTreeNode* cur = stack.top();\nstack.pop();\nTreeNode* node = cur->right;\nfor (; node != nullptr; node = node->left) {\nstack.push(node);\n}\nreturn cur->val;\n}\n\nbool hasNext() {\nreturn !stack.empty();\n}\n};\n\n/**\n* Your BSTIterator object will be instantiated and called as such:\n* BSTIterator* obj = new BSTIterator(root);\n* int param_1 = obj->next();\n* bool param_2 = obj->hasNext();\n*/\n"]}, {"leetCodeID": "0187", "level": "middle", "question_description": "The DNA sequence is composed of a series of nucleotides abbreviated as &#39;A&#39;, &#39;C&#39;, &#39;G&#39;, and &#39;T&#39;.\nFor example, &quot;ACGAATTCCG&quot; is a DNA sequence.\nWhen studying DNA, it is useful to identify repeated sequences within the DNA.\nGiven a string s that represents a DNA sequence, return all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in any order.", "examples": ["Example 1:Input: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\n", "Example 2:Input: s = \"AAAAAAAAAAAAA\"\nOutput: [\"AAAAAAAAAA\"]\n"], "constraints": "\nConstraints:\n1 <= s.length <= 105\ns[i] is either &#39;A&#39;, &#39;C&#39;, &#39;G&#39;, or &#39;T&#39;.\n", "java_context": "\nclass Solution {\n    public List<String> findRepeatedDnaSequences(String s) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} s\n* @return {string[]}\n*/\nvar findRepeatedDnaSequences = function (s) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<string> findRepeatedDnaSequences(string s) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic List<String> findRepeatedDnaSequences(String s) {\nMap<String, Integer> cnt = new HashMap<>();\nList<String> ans = new ArrayList<>();\nfor (int i = 0; i < s.length() - 10 + 1; ++i) {\nString t = s.substring(i, i + 10);\nif (cnt.merge(t, 1, Integer::sum) == 2) {\nans.add(t);\n}\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} s\n* @return {string[]}\n*/\nvar findRepeatedDnaSequences = function (s) {\nconst cnt = new Map();\nconst ans = [];\nfor (let i = 0; i < s.length - 10 + 1; ++i) {\nconst t = s.slice(i, i + 10);\ncnt.set(t, (cnt.get(t) || 0) + 1);\nif (cnt.get(t) === 2) {\nans.push(t);\n}\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<string> findRepeatedDnaSequences(string s) {\nunordered_map<string, int> cnt;\nvector<string> ans;\nfor (int i = 0, n = s.size() - 10 + 1; i < n; ++i) {\nauto t = s.substr(i, 10);\nif (++cnt[t] == 2) {\nans.emplace_back(t);\n}\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0189", "level": "middle", "question_description": "Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.", "examples": ["Example 1:\nInput: nums = [1,2,3,4,5,6,7], k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\n", "Example 2:\nInput: nums = [-1,-100,3,99], k = 2\nOutput: [3,99,-1,-100]\nExplanation:\nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1\n0 <= k <= 105\n", "java_context": "\nclass Solution {\n    private int[] nums;\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @param {number} k\n* @return {void} Do not return anything, modify nums in-place instead.\n*/\nvar rotate = function (nums, k) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    void rotate(vector<int>& nums, int k) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\nprivate int[] nums;\n\npublic void rotate(int[] nums, int k) {\nthis.nums = nums;\nint n = nums.length;\nk %= n;\nreverse(0, n - 1);\nreverse(0, k - 1);\nreverse(k, n - 1);\n}\n\nprivate void reverse(int i, int j) {\nfor (; i < j; ++i, --j) {\nint t = nums[i];\nnums[i] = nums[j];\nnums[j] = t;\n}\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @param {number} k\n* @return {void} Do not return anything, modify nums in-place instead.\n*/\nvar rotate = function (nums, k) {\nconst n = nums.length;\nk %= n;\nconst reverse = (i, j) => {\nfor (; i < j; ++i, --j) {\n[nums[i], nums[j]] = [nums[j], nums[i]];\n}\n};\nreverse(0, n - 1);\nreverse(0, k - 1);\nreverse(k, n - 1);\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvoid rotate(vector<int>& nums, int k) {\nint n = nums.size();\nk %= n;\nreverse(nums.begin(), nums.end());\nreverse(nums.begin(), nums.begin() + k);\nreverse(nums.begin() + k, nums.end());\n}\n};\n"]}, {"leetCodeID": "0201", "level": "middle", "question_description": "Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.", "examples": ["Example 1:\nInput: left = 5, right = 7\nOutput: 4\n", "Example 2:\nInput: left = 0, right = 0\nOutput: 0\n", "Example 3:\nInput: left = 1, right = 2147483647\nOutput: 0\n"], "constraints": "\nConstraints:\n0 <= left <= right <= 231 - 1\n", "java_context": "\nclass Solution {\n    public int rangeBitwiseAnd(int left, int right) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number} left\n* @param {number} right\n* @return {number}\n*/\nvar rangeBitwiseAnd = function (left, right) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int rangeBitwiseAnd(int left, int right) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int rangeBitwiseAnd(int left, int right) {\nwhile (left < right) {\nright &= (right - 1);\n}\nreturn right;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number} left\n* @param {number} right\n* @return {number}\n*/\nvar rangeBitwiseAnd = function (left, right) {\nwhile (left < right) {\nright &= right - 1;\n}\nreturn right;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint rangeBitwiseAnd(int left, int right) {\nwhile (left < right) {\nright &= (right - 1);\n}\nreturn right;\n}\n};\n"]}, {"leetCodeID": "0204", "level": "middle", "question_description": "Given an integer n, return the number of prime numbers that are strictly less than n.", "examples": ["Example 1:\nInput: n = 10\nOutput: 4\nExplanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.\n", "Example 2:\nInput: n = 0\nOutput: 0\n", "Example 3:\nInput: n = 1\nOutput: 0\n"], "constraints": "\nConstraints:\n0 <= n <= 5 * 106\n", "java_context": "\nclass Solution {\n    public int countPrimes(int n) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number} n\n* @return {number}\n*/\nvar countPrimes = function (n) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int countPrimes(int n) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int countPrimes(int n) {\nboolean[] primes = new boolean[n];\nArrays.fill(primes, true);\nint ans = 0;\nfor (int i = 2; i < n; ++i) {\nif (primes[i]) {\n++ans;\nfor (int j = i + i; j < n; j += i) {\nprimes[j] = false;\n}\n}\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number} n\n* @return {number}\n*/\nvar countPrimes = function (n) {\nlet primes = new Array(n).fill(true);\nlet ans = 0;\nfor (let i = 2; i < n; ++i) {\nif (primes[i]) {\n++ans;\nfor (let j = i + i; j < n; j += i) {\nprimes[j] = false;\n}\n}\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint countPrimes(int n) {\nvector<bool> primes(n, true);\nint ans = 0;\nfor (int i = 2; i < n; ++i) {\nif (primes[i]) {\n++ans;\nfor (int j = i; j < n; j += i) primes[j] = false;\n}\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0208", "level": "middle", "question_description": "A trie (pronounced as &quot;try&quot;) or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\nImplement the Trie class:\nTrie() Initializes the trie object.\nvoid insert(String word) Inserts the string word into the trie.\nboolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.\nboolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise.", "examples": ["Example 1:\nInput\n[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]\n[[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]\nOutput\n[null, null, true, false, true, null, true]\n\nExplanation\nTrie trie = new Trie();\ntrie.insert(&quot;apple&quot;);\ntrie.search(&quot;apple&quot;);   // return True\ntrie.search(&quot;app&quot;);     // return False\ntrie.startsWith(&quot;app&quot;); // return True\ntrie.insert(&quot;app&quot;);\ntrie.search(&quot;app&quot;);     // return True\n"], "constraints": "\nConstraints:\n1 <= word.length, prefix.length <= 2000\nword and prefix consist only of lowercase English letters.\nAt most 3 * 104 calls in total will be made to insert, search, and startsWith.\n", "java_context": "    \n        // your code\n    }\n}", "js_context": "\n/**\n* Initialize your data structure here.\n*/\nvar Trie = function () {\n    // your code\n};", "cpp_context": "    \n        // your code\n    }\n};", "java_solutions": ["\nclass Trie {\nprivate Trie[] children;\nprivate boolean isEnd;\n\npublic Trie() {\nchildren = new Trie[26];\n}\n\npublic void insert(String word) {\nTrie node = this;\nfor (char c : word.toCharArray()) {\nint idx = c - 'a';\nif (node.children[idx] == null) {\nnode.children[idx] = new Trie();\n}\nnode = node.children[idx];\n}\nnode.isEnd = true;\n}\n\npublic boolean search(String word) {\nTrie node = searchPrefix(word);\nreturn node != null && node.isEnd;\n}\n\npublic boolean startsWith(String prefix) {\nTrie node = searchPrefix(prefix);\nreturn node != null;\n}\n\nprivate Trie searchPrefix(String s) {\nTrie node = this;\nfor (char c : s.toCharArray()) {\nint idx = c - 'a';\nif (node.children[idx] == null) {\nreturn null;\n}\nnode = node.children[idx];\n}\nreturn node;\n}\n}\n\n/**\n* Your Trie object will be instantiated and called as such:\n* Trie obj = new Trie();\n* obj.insert(word);\n* boolean param_2 = obj.search(word);\n* boolean param_3 = obj.startsWith(prefix);\n*/\n"], "js_solutions": ["\n/**\n* Initialize your data structure here.\n*/\nvar Trie = function () {\nthis.children = {};\n};\n\n/**\n* Inserts a word into the trie.\n* @param {string} word\n* @return {void}\n*/\nTrie.prototype.insert = function (word) {\nlet node = this.children;\nfor (let char of word) {\nif (!node[char]) {\nnode[char] = {};\n}\nnode = node[char];\n}\nnode.isEnd = true;\n};\n\n/**\n* Returns if the word is in the trie.\n* @param {string} word\n* @return {boolean}\n*/\nTrie.prototype.search = function (word) {\nlet node = this.searchPrefix(word);\nreturn node != undefined && node.isEnd != undefined;\n};\n\nTrie.prototype.searchPrefix = function (prefix) {\nlet node = this.children;\nfor (let char of prefix) {\nif (!node[char]) return false;\nnode = node[char];\n}\nreturn node;\n};\n\n/**\n* Returns if there is any word in the trie that starts with the given prefix.\n* @param {string} prefix\n* @return {boolean}\n*/\nTrie.prototype.startsWith = function (prefix) {\nreturn this.searchPrefix(prefix);\n};\n\n/**\n* Your Trie object will be instantiated and called as such:\n* var obj = new Trie()\n* obj.insert(word)\n* var param_2 = obj.search(word)\n* var param_3 = obj.startsWith(prefix)\n*/\n"], "cpp_solutions": ["\nclass Trie {\nprivate:\nvector<Trie*> children;\nbool isEnd;\n\nTrie* searchPrefix(string s) {\nTrie* node = this;\nfor (char c : s) {\nint idx = c - 'a';\nif (!node->children[idx]) return nullptr;\nnode = node->children[idx];\n}\nreturn node;\n}\n\npublic:\nTrie()\n: children(26)\n, isEnd(false) {}\n\nvoid insert(string word) {\nTrie* node = this;\nfor (char c : word) {\nint idx = c - 'a';\nif (!node->children[idx]) node->children[idx] = new Trie();\nnode = node->children[idx];\n}\nnode->isEnd = true;\n}\n\nbool search(string word) {\nTrie* node = searchPrefix(word);\nreturn node != nullptr && node->isEnd;\n}\n\nbool startsWith(string prefix) {\nTrie* node = searchPrefix(prefix);\nreturn node != nullptr;\n}\n};\n\n/**\n* Your Trie object will be instantiated and called as such:\n* Trie* obj = new Trie();\n* obj->insert(word);\n* bool param_2 = obj->search(word);\n* bool param_3 = obj->startsWith(prefix);\n*/\n"]}, {"leetCodeID": "0236", "level": "middle", "question_description": "Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\nAccording to the definition of LCA on Wikipedia: &ldquo;The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).&rdquo;", "examples": ["Example 1:\n\n\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\nOutput: 3\nExplanation: The LCA of nodes 5 and 1 is 3.\n\n\nExample 2:\n\n\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\nOutput: 5\nExplanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.\n\n\nExample 3:\nInput: root = [1,2], p = 1, q = 2\nOutput: 1\n"], "constraints": "\nConstraints:\nThe number of nodes in the tree is in the range [2, 105].\n-109 <= Node.val <= 109\nAll Node.val are unique.\np != q\np and q will exist in the tree.\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode(int x) { val = x; }\n* }\n*/\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val) {\n*     this.val = val;\n*     this.left = this.right = null;\n* }\n*/\n/**\n* @param {TreeNode} root\n* @param {TreeNode} p\n* @param {TreeNode} q\n* @return {TreeNode}\n*/\nvar lowestCommonAncestor = function (root, p, q) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n* };\n*/\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode(int x) { val = x; }\n* }\n*/\nclass Solution {\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\nif (root == null || root == p || root == q) {\nreturn root;\n}\nvar left = lowestCommonAncestor(root.left, p, q);\nvar right = lowestCommonAncestor(root.right, p, q);\nif (left != null && right != null) {\nreturn root;\n}\nreturn left == null ? right : left;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val) {\n*     this.val = val;\n*     this.left = this.right = null;\n* }\n*/\n/**\n* @param {TreeNode} root\n* @param {TreeNode} p\n* @param {TreeNode} q\n* @return {TreeNode}\n*/\nvar lowestCommonAncestor = function (root, p, q) {\nif (!root || root === p || root === q) {\nreturn root;\n}\nconst left = lowestCommonAncestor(root.left, p, q);\nconst right = lowestCommonAncestor(root.right, p, q);\nreturn left && right ? root : left || right;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n* };\n*/\nclass Solution {\npublic:\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\nif (root == nullptr || root == p || root == q) {\nreturn root;\n}\nauto left = lowestCommonAncestor(root->left, p, q);\nauto right = lowestCommonAncestor(root->right, p, q);\nif (left && right) {\nreturn root;\n}\nreturn left ? left : right;\n}\n};\n"]}, {"leetCodeID": "0237", "level": "middle", "question_description": "There is a singly-linked list head and we want to delete a node node in it.\nYou are given the node to be deleted node. You will not be given access to the first node of head.\nAll the values of the linked list are unique, and it is guaranteed that the given node node is not the last node in the linked list.\nDelete the given node. Note that by deleting the node, we do not mean removing it from memory. We mean:\nThe value of the given node should not exist in the linked list.\nThe number of nodes in the linked list should decrease by one.\nAll the values before node should be in the same order.\nAll the values after node should be in the same order.\nCustom testing:\nFor the input, you should provide the entire linked list head and the node to be given node. node should not be the last node of the list and should be an actual node in the list.\nWe will build the linked list and pass the node to your function.\nThe output will be the entire list after calling your function.", "examples": [], "constraints": "\nConstraints:\nThe number of the nodes in the given list is in the range [2, 1000].\n-1000 <= Node.val <= 1000\nThe value of each node in the list is unique.\nThe node to be deleted is in the list and is not a tail node.\n", "java_context": "\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode(int x) { val = x; }\n* }\n*/\nclass Solution {\n    public void deleteNode(ListNode node) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for singly-linked list.\n* function ListNode(val) {\n*     this.val = val;\n*     this.next = null;\n* }\n*/\n/**\n* @param {ListNode} node\n* @return {void} Do not return anything, modify node in-place instead.\n*/\nvar deleteNode = function (node) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode(int x) : val(x), next(NULL) {}\n* };\n*/\nclass Solution {\npublic:\n    void deleteNode(ListNode* node) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode(int x) { val = x; }\n* }\n*/\nclass Solution {\npublic void deleteNode(ListNode node) {\nnode.val = node.next.val;\nnode.next = node.next.next;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for singly-linked list.\n* function ListNode(val) {\n*     this.val = val;\n*     this.next = null;\n* }\n*/\n/**\n* @param {ListNode} node\n* @return {void} Do not return anything, modify node in-place instead.\n*/\nvar deleteNode = function (node) {\nnode.val = node.next.val;\nnode.next = node.next.next;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode(int x) : val(x), next(NULL) {}\n* };\n*/\nclass Solution {\npublic:\nvoid deleteNode(ListNode* node) {\nnode->val = node->next->val;\nnode->next = node->next->next;\n}\n};\n"]}, {"leetCodeID": "0238", "level": "middle", "question_description": "Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\nYou must write an algorithm that runs in O(n) time and without using the division operation.", "examples": ["Example 1:Input: nums = [1,2,3,4]\nOutput: [24,12,8,6]\n", "Example 2:Input: nums = [-1,1,0,-3,3]\nOutput: [0,0,9,0,0]\n"], "constraints": "\nConstraints:\n2 <= nums.length <= 105\n-30 <= nums[i] <= 30\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\n", "java_context": "\nclass Solution {\n    public int[] productExceptSelf(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number[]}\n*/\nvar productExceptSelf = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int[] productExceptSelf(int[] nums) {\nint n = nums.length;\nint[] ans = new int[n];\nfor (int i = 0, left = 1; i < n; ++i) {\nans[i] = left;\nleft *= nums[i];\n}\nfor (int i = n - 1, right = 1; i >= 0; --i) {\nans[i] *= right;\nright *= nums[i];\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number[]}\n*/\nvar productExceptSelf = function (nums) {\nconst n = nums.length;\nconst ans = new Array(n);\nfor (let i = 0, left = 1; i < n; ++i) {\nans[i] = left;\nleft *= nums[i];\n}\nfor (let i = n - 1, right = 1; i >= 0; --i) {\nans[i] *= right;\nright *= nums[i];\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> productExceptSelf(vector<int>& nums) {\nint n = nums.size();\nvector<int> ans(n);\nfor (int i = 0, left = 1; i < n; ++i) {\nans[i] = left;\nleft *= nums[i];\n}\nfor (int i = n - 1, right = 1; ~i; --i) {\nans[i] *= right;\nright *= nums[i];\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0240", "level": "middle", "question_description": "Write an efficient algorithm that searches for a value target in an m x n integer matrix matrix. This matrix has the following properties:\nIntegers in each row are sorted in ascending from left to right.\nIntegers in each column are sorted in ascending from top to bottom.", "examples": [], "constraints": "\nConstraints:\nm == matrix.length\nn == matrix[i].length\n1 <= n, m <= 300\n-109 <= matrix[i][j] <= 109\nAll the integers in each row are sorted in ascending order.\nAll the integers in each column are sorted in ascending order.\n-109 <= target <= 109\n", "java_context": "\nclass Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[][]} matrix\n* @param {number} target\n* @return {boolean}\n*/\nvar searchMatrix = function (matrix, target) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic boolean searchMatrix(int[][] matrix, int target) {\nfor (var row : matrix) {\nint j = Arrays.binarySearch(row, target);\nif (j >= 0) {\nreturn true;\n}\n}\nreturn false;\n}\n}\n", "\nclass Solution {\npublic boolean searchMatrix(int[][] matrix, int target) {\nint m = matrix.length, n = matrix[0].length;\nint i = m - 1, j = 0;\nwhile (i >= 0 && j < n) {\nif (matrix[i][j] == target) {\nreturn true;\n}\nif (matrix[i][j] > target) {\n--i;\n} else {\n++j;\n}\n}\nreturn false;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[][]} matrix\n* @param {number} target\n* @return {boolean}\n*/\nvar searchMatrix = function (matrix, target) {\nconst n = matrix[0].length;\nfor (const row of matrix) {\nlet left = 0,\nright = n;\nwhile (left < right) {\nconst mid = (left + right) >> 1;\nif (row[mid] >= target) {\nright = mid;\n} else {\nleft = mid + 1;\n}\n}\nif (left != n && row[left] == target) {\nreturn true;\n}\n}\nreturn false;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\nfor (auto& row : matrix) {\nint j = lower_bound(row.begin(), row.end(), target) - row.begin();\nif (j < matrix[0].size() && row[j] == target) {\nreturn true;\n}\n}\nreturn false;\n}\n};\n", "\nclass Solution {\npublic:\nbool searchMatrix(vector<vector<int>>& matrix, int target) {\nint m = matrix.size(), n = matrix[0].size();\nint i = m - 1, j = 0;\nwhile (i >= 0 && j < n) {\nif (matrix[i][j] == target) {\nreturn true;\n}\nif (matrix[i][j] > target) {\n--i;\n} else {\n++j;\n}\n}\nreturn false;\n}\n};\n"]}, {"leetCodeID": "0250", "level": "middle", "question_description": "Given the root of a binary tree, return the number of uni-value subtrees.\nA uni-value subtree means all nodes of the subtree have the same value.", "examples": ["Example 1:\n\n\nInput: root = [5,1,5,5,5,null,5]\nOutput: 4\n\n\nExample 2:\nInput: root = []\nOutput: 0\n", "Example 3:\nInput: root = [5,5,5,5,5,null,5]\nOutput: 6\n"], "constraints": "\nConstraints:\nThe number of the node in the tree will be in the range [0, 1000].\n-1000 <= Node.val <= 1000\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\n    private int ans;\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {number}\n*/\nvar countUnivalSubtrees = function (root) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    int countUnivalSubtrees(TreeNode* root) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\nprivate int ans;\n\npublic int countUnivalSubtrees(TreeNode root) {\ndfs(root);\nreturn ans;\n}\n\nprivate boolean dfs(TreeNode root) {\nif (root == null) {\nreturn true;\n}\nboolean l = dfs(root.left);\nboolean r = dfs(root.right);\nif (!l || !r) {\nreturn false;\n}\nint a = root.left == null ? root.val : root.left.val;\nint b = root.right == null ? root.val : root.right.val;\nif (a == b && b == root.val) {\n++ans;\nreturn true;\n}\nreturn false;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {number}\n*/\nvar countUnivalSubtrees = function (root) {\nlet ans = 0;\nconst dfs = root => {\nif (!root) {\nreturn true;\n}\nconst l = dfs(root.left);\nconst r = dfs(root.right);\nif (!l || !r) {\nreturn false;\n}\nif (root.left && root.left.val !== root.val) {\nreturn false;\n}\nif (root.right && root.right.val !== root.val) {\nreturn false;\n}\n++ans;\nreturn true;\n};\ndfs(root);\nreturn ans;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nint countUnivalSubtrees(TreeNode* root) {\nint ans = 0;\nfunction<bool(TreeNode*)> dfs = [&](TreeNode* root) -> bool {\nif (!root) {\nreturn true;\n}\nbool l = dfs(root->left);\nbool r = dfs(root->right);\nif (!l || !r) {\nreturn false;\n}\nint a = root->left ? root->left->val : root->val;\nint b = root->right ? root->right->val : root->val;\nif (a == b && b == root->val) {\n++ans;\nreturn true;\n}\nreturn false;\n};\ndfs(root);\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0256", "level": "middle", "question_description": "There is a row of n houses, where each house can be painted one of three colors: red, blue, or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.\nThe cost of painting each house with a certain color is represented by an n x 3 cost matrix costs.\nFor example, costs[0][0] is the cost of painting house 0 with the color red; costs[1][2] is the cost of painting house 1 with color green, and so on...\nReturn the minimum cost to paint all houses.", "examples": ["Example 1:\nInput: costs = [[17,2,17],[16,16,5],[14,3,19]]\nOutput: 10\nExplanation: Paint house 0 into blue, paint house 1 into green, paint house 2 into blue.\nMinimum cost: 2 + 5 + 3 = 10.\n", "Example 2:\nInput: costs = [[7,6,2]]\nOutput: 2\n"], "constraints": "\nConstraints:\ncosts.length == n\ncosts[i].length == 3\n1 <= n <= 100\n1 <= costs[i][j] <= 20\n", "java_context": "\nclass Solution {\n    public int minCost(int[][] costs) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[][]} costs\n* @return {number}\n*/\nvar minCost = function (costs) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int minCost(vector<vector<int>>& costs) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int minCost(int[][] costs) {\nint r = 0, g = 0, b = 0;\nfor (int[] cost : costs) {\nint _r = r, _g = g, _b = b;\nr = Math.min(_g, _b) + cost[0];\ng = Math.min(_r, _b) + cost[1];\nb = Math.min(_r, _g) + cost[2];\n}\nreturn Math.min(r, Math.min(g, b));\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[][]} costs\n* @return {number}\n*/\nvar minCost = function (costs) {\nlet [a, b, c] = [0, 0, 0];\nfor (let [ca, cb, cc] of costs) {\n[a, b, c] = [Math.min(b, c) + ca, Math.min(a, c) + cb, Math.min(a, b) + cc];\n}\nreturn Math.min(a, b, c);\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint minCost(vector<vector<int>>& costs) {\nint r = 0, g = 0, b = 0;\nfor (auto& cost : costs) {\nint _r = r, _g = g, _b = b;\nr = min(_g, _b) + cost[0];\ng = min(_r, _b) + cost[1];\nb = min(_r, _g) + cost[2];\n}\nreturn min(r, min(g, b));\n}\n};\n"]}, {"leetCodeID": "0259", "level": "middle", "question_description": "Given an array of n integers nums and an integer target, find the number of index triplets i, j, k with 0 &lt;= i &lt; j &lt; k &lt; n that satisfy the condition nums[i] + nums[j] + nums[k] &lt; target.", "examples": ["Example 1:\nInput: nums = [-2,0,1,3], target = 2\nOutput: 2\nExplanation: Because there are two triplets which sums are less than 2:\n[-2,0,1]\n[-2,0,3]\n", "Example 2:\nInput: nums = [], target = 0\nOutput: 0\n", "Example 3:\nInput: nums = [0], target = 0\nOutput: 0\n"], "constraints": "\nConstraints:\nn == nums.length\n0 <= n <= 3500\n-100 <= nums[i] <= 100\n-100 <= target <= 100\n", "java_context": "\nclass Solution {\n    public int threeSumSmaller(int[] nums, int target) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @param {number} target\n* @return {number}\n*/\nvar threeSumSmaller = function (nums, target) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int threeSumSmaller(vector<int>& nums, int target) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int threeSumSmaller(int[] nums, int target) {\nArrays.sort(nums);\nint ans = 0;\nfor (int i = 0, n = nums.length; i < n; ++i) {\nint j = i + 1;\nint k = n - 1;\nwhile (j < k) {\nint s = nums[i] + nums[j] + nums[k];\nif (s >= target) {\n--k;\n} else {\nans += k - j;\n++j;\n}\n}\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @param {number} target\n* @return {number}\n*/\nvar threeSumSmaller = function (nums, target) {\nnums.sort((a, b) => a - b);\nlet ans = 0;\nfor (let i = 0, n = nums.length; i < n; ++i) {\nlet j = i + 1;\nlet k = n - 1;\nwhile (j < k) {\ns = nums[i] + nums[j] + nums[k];\nif (s >= target) {\n--k;\n} else {\nans += k - j;\n++j;\n}\n}\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint threeSumSmaller(vector<int>& nums, int target) {\nsort(nums.begin(), nums.end());\nint ans = 0;\nfor (int i = 0, n = nums.size(); i < n; ++i) {\nint j = i + 1, k = n - 1;\nwhile (j < k) {\nint s = nums[i] + nums[j] + nums[k];\nif (s >= target)\n--k;\nelse {\nans += k - j;\n++j;\n}\n}\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0260", "level": "middle", "question_description": "Given an integer array nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in any order.\nYou must write an algorithm that runs in linear runtime complexity and uses only constant extra space.", "examples": ["Example 1:\nInput: nums = [1,2,1,3,2,5]\nOutput: [3,5]\nExplanation:  [5, 3] is also a valid answer.\n", "Example 2:\nInput: nums = [-1,0]\nOutput: [-1,0]\n", "Example 3:\nInput: nums = [0,1]\nOutput: [1,0]\n"], "constraints": "\nConstraints:\n2 <= nums.length <= 3 * 104\n-231 <= nums[i] <= 231 - 1\nEach integer in nums will appear twice, only two integers will appear once.\n", "java_context": "\nclass Solution {\n    public int[] singleNumber(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number[]}\n*/\nvar singleNumber = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> singleNumber(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int[] singleNumber(int[] nums) {\nint xs = 0;\nfor (int x : nums) {\nxs ^= x;\n}\nint lb = xs & -xs;\nint a = 0;\nfor (int x : nums) {\nif ((x & lb) != 0) {\na ^= x;\n}\n}\nint b = xs ^ a;\nreturn new int[] {a, b};\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number[]}\n*/\nvar singleNumber = function (nums) {\nconst xs = nums.reduce((a, b) => a ^ b);\nconst lb = xs & -xs;\nlet a = 0;\nfor (const x of nums) {\nif (x & lb) {\na ^= x;\n}\n}\nconst b = xs ^ a;\nreturn [a, b];\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> singleNumber(vector<int>& nums) {\nlong long xs = 0;\nfor (int& x : nums) {\nxs ^= x;\n}\nint lb = xs & -xs;\nint a = 0;\nfor (int& x : nums) {\nif (x & lb) {\na ^= x;\n}\n}\nint b = xs ^ a;\nreturn {a, b};\n}\n};\n"]}, {"leetCodeID": "0261", "level": "middle", "question_description": "You have a graph of n nodes labeled from 0 to n - 1. You are given an integer n and a list of edges where edges[i] = [ai, bi] indicates that there is an undirected edge between nodes ai and bi in the graph.\nReturn true if the edges of the given graph make up a valid tree, and false otherwise.", "examples": [], "constraints": "\nConstraints:\n1 <= n <= 2000\n0 <= edges.length <= 5000\nedges[i].length == 2\n0 <= ai, bi < n\nai != bi\nThere are no self-loops or repeated edges.\n", "java_context": "\nclass Solution {\n    public:\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number} n\n* @param {number[][]} edges\n* @return {boolean}\n*/\nvar validTree = function (n, edges) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> p;\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic:\nbool validTree(int n, vector<vector<int>>& edges) {\nvector<int> p(n);\niota(p.begin(), p.end(), 0);\nfunction<int(int)> find = [&](int x) {\nif (p[x] != x) {\np[x] = find(p[x]);\n}\nreturn p[x];\n};\nfor (auto& e : edges) {\nint pa = find(e[0]), pb = find(e[1]);\nif (pa == pb) {\nreturn false;\n}\np[pa] = pb;\n--n;\n}\nreturn n == 1;\n}\n};\n", "\nclass Solution {\nprivate List<Integer>[] g;\nprivate Set<Integer> vis = new HashSet<>();\n\npublic boolean validTree(int n, int[][] edges) {\nif (edges.length != n - 1) {\nreturn false;\n}\ng = new List[n];\nArrays.setAll(g, k -> new ArrayList<>());\nfor (var e : edges) {\nint a = e[0], b = e[1];\ng[a].add(b);\ng[b].add(a);\n}\ndfs(0);\nreturn vis.size() == n;\n}\n\nprivate void dfs(int i) {\nvis.add(i);\nfor (int j : g[i]) {\nif (!vis.contains(j)) {\ndfs(j);\n}\n}\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number} n\n* @param {number[][]} edges\n* @return {boolean}\n*/\nvar validTree = function (n, edges) {\nconst p = Array.from({ length: n }, (_, i) => i);\nconst find = x => {\nif (p[x] !== x) {\np[x] = find(p[x]);\n}\nreturn p[x];\n};\nfor (const [a, b] of edges) {\nconst pa = find(a);\nconst pb = find(b);\nif (pa === pb) {\nreturn false;\n}\np[pa] = pb;\n--n;\n}\nreturn n === 1;\n};\n", "\n/**\n* @param {number} n\n* @param {number[][]} edges\n* @return {boolean}\n*/\nvar validTree = function (n, edges) {\nif (edges.length !== n - 1) {\nreturn false;\n}\nconst g = Array.from({ length: n }, () => []);\nconst vis = Array.from({ length: n }, () => false);\nfor (const [a, b] of edges) {\ng[a].push(b);\ng[b].push(a);\n}\nconst dfs = i => {\nvis[i] = true;\n--n;\nfor (const j of g[i]) {\nif (!vis[j]) {\ndfs(j);\n}\n}\n};\ndfs(0);\nreturn n === 0;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> p;\n\nbool validTree(int n, vector<vector<int>>& edges) {\np.resize(n);\nfor (int i = 0; i < n; ++i) p[i] = i;\nfor (auto& e : edges) {\nint a = e[0], b = e[1];\nif (find(a) == find(b)) return 0;\np[find(a)] = find(b);\n--n;\n}\nreturn n == 1;\n}\n\nint find(int x) {\nif (p[x] != x) p[x] = find(p[x]);\nreturn p[x];\n}\n};\n", "\nclass Solution {\npublic:\nbool validTree(int n, vector<vector<int>>& edges) {\nif (edges.size() != n - 1) {\nreturn false;\n}\nvector<int> g[n];\nvector<int> vis(n);\nfunction<void(int)> dfs = [&](int i) {\nvis[i] = true;\n--n;\nfor (int j : g[i]) {\nif (!vis[j]) {\ndfs(j);\n}\n}\n};\nfor (auto& e : edges) {\nint a = e[0], b = e[1];\ng[a].push_back(b);\ng[b].push_back(a);\n}\ndfs(0);\nreturn n == 0;\n}\n};\n"]}, {"leetCodeID": "0264", "level": "middle", "question_description": "An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\nGiven an integer n, return the nth ugly number.", "examples": ["Example 1:\nInput: n = 10\nOutput: 12\nExplanation: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers.\n", "Example 2:\nInput: n = 1\nOutput: 1\nExplanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.\n"], "constraints": "\nConstraints:\n1 <= n <= 1690\n", "java_context": "\nclass Solution {\n    public int nthUglyNumber(int n) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number} n\n* @return {number}\n*/\nvar nthUglyNumber = function (n) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int nthUglyNumber(int n) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int nthUglyNumber(int n) {\nSet<Long> vis = new HashSet<>();\nPriorityQueue<Long> q = new PriorityQueue<>();\nint[] f = new int[] {2, 3, 5};\nq.offer(1L);\nvis.add(1L);\nlong ans = 0;\nwhile (n-- > 0) {\nans = q.poll();\nfor (int v : f) {\nlong next = ans * v;\nif (vis.add(next)) {\nq.offer(next);\n}\n}\n}\nreturn (int) ans;\n}\n}\n", "\nclass Solution {\npublic int nthUglyNumber(int n) {\nint[] dp = new int[n];\ndp[0] = 1;\nint p2 = 0, p3 = 0, p5 = 0;\nfor (int i = 1; i < n; ++i) {\nint next2 = dp[p2] * 2, next3 = dp[p3] * 3, next5 = dp[p5] * 5;\ndp[i] = Math.min(next2, Math.min(next3, next5));\nif (dp[i] == next2) ++p2;\nif (dp[i] == next3) ++p3;\nif (dp[i] == next5) ++p5;\n}\nreturn dp[n - 1];\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number} n\n* @return {number}\n*/\nvar nthUglyNumber = function (n) {\nlet dp = [1];\nlet p2 = 0,\np3 = 0,\np5 = 0;\nfor (let i = 1; i < n; ++i) {\nconst next2 = dp[p2] * 2,\nnext3 = dp[p3] * 3,\nnext5 = dp[p5] * 5;\ndp[i] = Math.min(next2, Math.min(next3, next5));\nif (dp[i] == next2) ++p2;\nif (dp[i] == next3) ++p3;\nif (dp[i] == next5) ++p5;\ndp.push(dp[i]);\n}\nreturn dp[n - 1];\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint nthUglyNumber(int n) {\npriority_queue<long, vector<long>, greater<long>> q;\nq.push(1l);\nunordered_set<long> vis{{1l}};\nlong ans = 1;\nvector<int> f = {2, 3, 5};\nwhile (n--) {\nans = q.top();\nq.pop();\nfor (int& v : f) {\nlong nxt = ans * v;\nif (!vis.count(nxt)) {\nvis.insert(nxt);\nq.push(nxt);\n}\n}\n}\nreturn (int) ans;\n}\n};\n", "\nclass Solution {\npublic:\nint nthUglyNumber(int n) {\nvector<int> dp(n);\ndp[0] = 1;\nint p2 = 0, p3 = 0, p5 = 0;\nfor (int i = 1; i < n; ++i) {\nint next2 = dp[p2] * 2, next3 = dp[p3] * 3, next5 = dp[p5] * 5;\ndp[i] = min(next2, min(next3, next5));\nif (dp[i] == next2) ++p2;\nif (dp[i] == next3) ++p3;\nif (dp[i] == next5) ++p5;\n}\nreturn dp[n - 1];\n}\n};\n"]}, {"leetCodeID": "0285", "level": "middle", "question_description": "Given the root of a binary search tree and a node p in it, return the in-order successor of that node in the BST. If the given node has no in-order successor in the tree, return null.\nThe successor of a node p is the node with the smallest key greater than p.val.", "examples": [], "constraints": "\nConstraints:\nThe number of nodes in the tree is in the range [1, 104].\n-105 <= Node.val <= 105\nAll Nodes will have unique values.\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode(int x) { val = x; }\n* }\n*/\nclass Solution {\n    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val) {\n*     this.val = val;\n*     this.left = this.right = null;\n* }\n*/\n/**\n* @param {TreeNode} root\n* @param {TreeNode} p\n* @return {TreeNode}\n*/\nvar inorderSuccessor = function (root, p) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n* };\n*/\nclass Solution {\npublic:\n    TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode(int x) { val = x; }\n* }\n*/\nclass Solution {\npublic TreeNode inorderSuccessor(TreeNode root, TreeNode p) {\nTreeNode ans = null;\nwhile (root != null) {\nif (root.val > p.val) {\nans = root;\nroot = root.left;\n} else {\nroot = root.right;\n}\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val) {\n*     this.val = val;\n*     this.left = this.right = null;\n* }\n*/\n/**\n* @param {TreeNode} root\n* @param {TreeNode} p\n* @return {TreeNode}\n*/\nvar inorderSuccessor = function (root, p) {\nlet ans = null;\nwhile (root) {\nif (root.val > p.val) {\nans = root;\nroot = root.left;\n} else {\nroot = root.right;\n}\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n* };\n*/\nclass Solution {\npublic:\nTreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {\nTreeNode* ans = nullptr;\nwhile (root) {\nif (root->val > p->val) {\nans = root;\nroot = root->left;\n} else {\nroot = root->right;\n}\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0287", "level": "middle", "question_description": "Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.\nThere is only one repeated number in nums, return this repeated number.\nYou must solve the problem without modifying the array nums and uses only constant extra space.", "examples": ["Example 1:\nInput: nums = [1,3,4,2,2]\nOutput: 2\n", "Example 2:\nInput: nums = [3,1,3,4,2]\nOutput: 3\n", "Example 3:\nInput: nums = [3,3,3,3,3]\nOutput: 3"], "constraints": "\nConstraints:\n1 <= n <= 105\nnums.length == n + 1\n1 <= nums[i] <= n\nAll the integers in nums appear only once except for precisely one integer which appears two or more times.\n", "java_context": "\nclass Solution {\n    public int findDuplicate(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar findDuplicate = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int findDuplicate(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int findDuplicate(int[] nums) {\nint l = 0, r = nums.length - 1;\nwhile (l < r) {\nint mid = (l + r) >> 1;\nint cnt = 0;\nfor (int v : nums) {\nif (v <= mid) {\n++cnt;\n}\n}\nif (cnt > mid) {\nr = mid;\n} else {\nl = mid + 1;\n}\n}\nreturn l;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar findDuplicate = function (nums) {\nlet l = 0;\nlet r = nums.length - 1;\nwhile (l < r) {\nconst mid = (l + r) >> 1;\nlet cnt = 0;\nfor (const v of nums) {\nif (v <= mid) {\n++cnt;\n}\n}\nif (cnt > mid) {\nr = mid;\n} else {\nl = mid + 1;\n}\n}\nreturn l;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint findDuplicate(vector<int>& nums) {\nint l = 0, r = nums.size() - 1;\nwhile (l < r) {\nint mid = (l + r) >> 1;\nint cnt = 0;\nfor (int& v : nums) {\ncnt += v <= mid;\n}\nif (cnt > mid) {\nr = mid;\n} else {\nl = mid + 1;\n}\n}\nreturn l;\n}\n};\n"]}, {"leetCodeID": "0304", "level": "middle", "question_description": "Given a 2D matrix matrix, handle multiple queries of the following type:\nCalculate the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).\nImplement the NumMatrix class:\nNumMatrix(int[][] matrix) Initializes the object with the integer matrix matrix.\nint sumRegion(int row1, int col1, int row2, int col2) Returns the sum of the elements of matrix inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).\nYou must design an algorithm where sumRegion works on O(1) time complexity.", "examples": [], "constraints": "\nConstraints:\nm == matrix.length\nn == matrix[i].length\n1 <= m, n <= 200\n-104 <= matrix[i][j] <= 104\n0 <= row1 <= row2 < m\n0 <= col1 <= col2 < n\nAt most 104 calls will be made to sumRegion.\n", "java_context": "    \n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[][]} matrix\n*/\nvar NumMatrix = function (matrix) {\n    // your code\n};", "cpp_context": "    \n        // your code\n    }\n};", "java_solutions": ["\nclass NumMatrix {\nprivate int[][] s;\n\npublic NumMatrix(int[][] matrix) {\nint m = matrix.length, n = matrix[0].length;\ns = new int[m + 1][n + 1];\nfor (int i = 0; i < m; ++i) {\nfor (int j = 0; j < n; ++j) {\ns[i + 1][j + 1] = s[i + 1][j] + s[i][j + 1] - s[i][j] + matrix[i][j];\n}\n}\n}\n\npublic int sumRegion(int row1, int col1, int row2, int col2) {\nreturn s[row2 + 1][col2 + 1] - s[row2 + 1][col1] - s[row1][col2 + 1] + s[row1][col1];\n}\n}\n\n/**\n* Your NumMatrix object will be instantiated and called as such:\n* NumMatrix obj = new NumMatrix(matrix);\n* int param_1 = obj.sumRegion(row1,col1,row2,col2);\n*/\n"], "js_solutions": ["\n/**\n* @param {number[][]} matrix\n*/\nvar NumMatrix = function (matrix) {\nconst m = matrix.length;\nconst n = matrix[0].length;\nthis.s = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));\nfor (let i = 0; i < m; ++i) {\nfor (let j = 0; j < n; ++j) {\nthis.s[i + 1][j + 1] =\nthis.s[i + 1][j] + this.s[i][j + 1] - this.s[i][j] + matrix[i][j];\n}\n}\n};\n\n/**\n* @param {number} row1\n* @param {number} col1\n* @param {number} row2\n* @param {number} col2\n* @return {number}\n*/\nNumMatrix.prototype.sumRegion = function (row1, col1, row2, col2) {\nreturn (\nthis.s[row2 + 1][col2 + 1] -\nthis.s[row2 + 1][col1] -\nthis.s[row1][col2 + 1] +\nthis.s[row1][col1]\n);\n};\n\n/**\n* Your NumMatrix object will be instantiated and called as such:\n* var obj = new NumMatrix(matrix)\n* var param_1 = obj.sumRegion(row1,col1,row2,col2)\n*/\n"], "cpp_solutions": ["\nclass NumMatrix {\npublic:\nvector<vector<int>> s;\n\nNumMatrix(vector<vector<int>>& matrix) {\nint m = matrix.size(), n = matrix[0].size();\ns.resize(m + 1, vector<int>(n + 1));\nfor (int i = 0; i < m; ++i) {\nfor (int j = 0; j < n; ++j) {\ns[i + 1][j + 1] = s[i + 1][j] + s[i][j + 1] - s[i][j] + matrix[i][j];\n}\n}\n}\n\nint sumRegion(int row1, int col1, int row2, int col2) {\nreturn s[row2 + 1][col2 + 1] - s[row2 + 1][col1] - s[row1][col2 + 1] + s[row1][col1];\n}\n};\n\n/**\n* Your NumMatrix object will be instantiated and called as such:\n* NumMatrix* obj = new NumMatrix(matrix);\n* int param_1 = obj->sumRegion(row1,col1,row2,col2);\n*/\n"]}, {"leetCodeID": "0322", "level": "middle", "question_description": "You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\nReturn the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\nYou may assume that you have an infinite number of each kind of coin.", "examples": ["Example 1:\nInput: coins = [1,2,5], amount = 11\nOutput: 3\nExplanation: 11 = 5 + 5 + 1\n", "Example 2:\nInput: coins = [2], amount = 3\nOutput: -1\n", "Example 3:\nInput: coins = [1], amount = 0\nOutput: 0\n"], "constraints": "\nConstraints:\n1 <= coins.length <= 12\n1 <= coins[i] <= 231 - 1\n0 <= amount <= 104\n", "java_context": "\nclass Solution {\n    public int coinChange(int[] coins, int amount) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} coins\n* @param {number} amount\n* @return {number}\n*/\nvar coinChange = function (coins, amount) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int coinChange(int[] coins, int amount) {\nfinal int inf = 1 << 30;\nint m = coins.length;\nint n = amount;\nint[][] f = new int[m + 1][n + 1];\nfor (var g : f) {\nArrays.fill(g, inf);\n}\nf[0][0] = 0;\nfor (int i = 1; i <= m; ++i) {\nfor (int j = 0; j <= n; ++j) {\nf[i][j] = f[i - 1][j];\nif (j >= coins[i - 1]) {\nf[i][j] = Math.min(f[i][j], f[i][j - coins[i - 1]] + 1);\n}\n}\n}\nreturn f[m][n] >= inf ? -1 : f[m][n];\n}\n}\n", "\nclass Solution {\npublic int coinChange(int[] coins, int amount) {\nfinal int inf = 1 << 30;\nint n = amount;\nint[] f = new int[n + 1];\nArrays.fill(f, inf);\nf[0] = 0;\nfor (int x : coins) {\nfor (int j = x; j <= n; ++j) {\nf[j] = Math.min(f[j], f[j - x] + 1);\n}\n}\nreturn f[n] >= inf ? -1 : f[n];\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} coins\n* @param {number} amount\n* @return {number}\n*/\nvar coinChange = function (coins, amount) {\nconst m = coins.length;\nconst n = amount;\nconst f = Array(m + 1)\n.fill(0)\n.map(() => Array(n + 1).fill(1 << 30));\nf[0][0] = 0;\nfor (let i = 1; i <= m; ++i) {\nfor (let j = 0; j <= n; ++j) {\nf[i][j] = f[i - 1][j];\nif (j >= coins[i - 1]) {\nf[i][j] = Math.min(f[i][j], f[i][j - coins[i - 1]] + 1);\n}\n}\n}\nreturn f[m][n] > n ? -1 : f[m][n];\n};\n", "\n/**\n* @param {number[]} coins\n* @param {number} amount\n* @return {number}\n*/\nvar coinChange = function (coins, amount) {\nconst n = amount;\nconst f = Array(n + 1).fill(1 << 30);\nf[0] = 0;\nfor (const x of coins) {\nfor (let j = x; j <= n; ++j) {\nf[j] = Math.min(f[j], f[j - x] + 1);\n}\n}\nreturn f[n] > n ? -1 : f[n];\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint coinChange(vector<int>& coins, int amount) {\nint m = coins.size(), n = amount;\nint f[m + 1][n + 1];\nmemset(f, 0x3f, sizeof(f));\nf[0][0] = 0;\nfor (int i = 1; i <= m; ++i) {\nfor (int j = 0; j <= n; ++j) {\nf[i][j] = f[i - 1][j];\nif (j >= coins[i - 1]) {\nf[i][j] = min(f[i][j], f[i][j - coins[i - 1]] + 1);\n}\n}\n}\nreturn f[m][n] > n ? -1 : f[m][n];\n}\n};\n", "\nclass Solution {\npublic:\nint coinChange(vector<int>& coins, int amount) {\nint n = amount;\nint f[n + 1];\nmemset(f, 0x3f, sizeof(f));\nf[0] = 0;\nfor (int x : coins) {\nfor (int j = x; j <= n; ++j) {\nf[j] = min(f[j], f[j - x] + 1);\n}\n}\nreturn f[n] > n ? -1 : f[n];\n}\n};\n"]}, {"leetCodeID": "0323", "level": "middle", "question_description": "You have a graph of n nodes. You are given an integer n and an array edges where edges[i] = [ai, bi] indicates that there is an edge between ai and bi in the graph.\nReturn the number of connected components in the graph.", "examples": [], "constraints": "\nConstraints:\n1 <= n <= 2000\n1 <= edges.length <= 5000\nedges[i].length == 2\n0 <= ai <= bi < n\nai != bi\nThere are no repeated edges.\n", "java_context": "\nclass Solution {\n    private List<Integer>[] g;\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number} n\n* @param {number[][]} edges\n* @return {number}\n*/\nvar countComponents = function (n, edges) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int countComponents(int n, vector<vector<int>>& edges) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\nprivate List<Integer>[] g;\nprivate boolean[] vis;\n\npublic int countComponents(int n, int[][] edges) {\ng = new List[n];\nvis = new boolean[n];\nArrays.setAll(g, k -> new ArrayList<>());\nfor (var e : edges) {\nint a = e[0], b = e[1];\ng[a].add(b);\ng[b].add(a);\n}\nint ans = 0;\nfor (int i = 0; i < n; ++i) {\nans += dfs(i);\n}\nreturn ans;\n}\n\nprivate int dfs(int i) {\nif (vis[i]) {\nreturn 0;\n}\nvis[i] = true;\nfor (int j : g[i]) {\ndfs(j);\n}\nreturn 1;\n}\n}\n", "\nclass UnionFind {\nprivate final int[] p;\nprivate final int[] size;\n\npublic UnionFind(int n) {\np = new int[n];\nsize = new int[n];\nfor (int i = 0; i < n; ++i) {\np[i] = i;\nsize[i] = 1;\n}\n}\n\npublic int find(int x) {\nif (p[x] != x) {\np[x] = find(p[x]);\n}\nreturn p[x];\n}\n\npublic boolean union(int a, int b) {\nint pa = find(a), pb = find(b);\nif (pa == pb) {\nreturn false;\n}\nif (size[pa] > size[pb]) {\np[pb] = pa;\nsize[pa] += size[pb];\n} else {\np[pa] = pb;\nsize[pb] += size[pa];\n}\nreturn true;\n}\n}\n\nclass Solution {\npublic int countComponents(int n, int[][] edges) {\nUnionFind uf = new UnionFind(n);\nfor (var e : edges) {\nn -= uf.union(e[0], e[1]) ? 1 : 0;\n}\nreturn n;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number} n\n* @param {number[][]} edges\n* @return {number}\n*/\nvar countComponents = function (n, edges) {\nconst g = Array.from({ length: n }, () => []);\nfor (const [a, b] of edges) {\ng[a].push(b);\ng[b].push(a);\n}\nconst vis = Array(n).fill(false);\nconst dfs = i => {\nif (vis[i]) {\nreturn 0;\n}\nvis[i] = true;\nfor (const j of g[i]) {\ndfs(j);\n}\nreturn 1;\n};\nreturn g.reduce((acc, _, i) => acc + dfs(i), 0);\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint countComponents(int n, vector<vector<int>>& edges) {\nvector<int> g[n];\nfor (auto& e : edges) {\nint a = e[0], b = e[1];\ng[a].push_back(b);\ng[b].push_back(a);\n}\nvector<bool> vis(n);\nfunction<int(int)> dfs = [&](int i) {\nif (vis[i]) {\nreturn 0;\n}\nvis[i] = true;\nfor (int j : g[i]) {\ndfs(j);\n}\nreturn 1;\n};\nint ans = 0;\nfor (int i = 0; i < n; ++i) {\nans += dfs(i);\n}\nreturn ans;\n}\n};\n", "\nclass UnionFind {\npublic:\nUnionFind(int n) {\np = vector<int>(n);\nsize = vector<int>(n, 1);\niota(p.begin(), p.end(), 0);\n}\n\nbool unite(int a, int b) {\nint pa = find(a), pb = find(b);\nif (pa == pb) {\nreturn false;\n}\nif (size[pa] > size[pb]) {\np[pb] = pa;\nsize[pa] += size[pb];\n} else {\np[pa] = pb;\nsize[pb] += size[pa];\n}\nreturn true;\n}\n\nint find(int x) {\nif (p[x] != x) {\np[x] = find(p[x]);\n}\nreturn p[x];\n}\n\nprivate:\nvector<int> p, size;\n};\n\nclass Solution {\npublic:\nint countComponents(int n, vector<vector<int>>& edges) {\nUnionFind uf(n);\nfor (auto& e : edges) {\nn -= uf.unite(e[0], e[1]);\n}\nreturn n;\n}\n};\n"]}, {"leetCodeID": "0324", "level": "middle", "question_description": "Given an integer array nums, reorder it such that nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]....\nYou may assume the input array always has a valid answer.", "examples": ["Example 1:\nInput: nums = [1,5,1,1,6,4]\nOutput: [1,6,1,5,1,4]\nExplanation: [1,4,1,5,1,6] is also accepted.\n", "Example 2:\nInput: nums = [1,3,2,2,3,1]\nOutput: [2,3,1,3,1,2]\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 5 * 104\n0 <= nums[i] <= 5000\nIt is guaranteed that there will be an answer for the given input nums.\n", "java_context": "\nclass Solution {\n    public void wiggleSort(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {void} Do not return anything, modify nums in-place instead.\n*/\nvar wiggleSort = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    void wiggleSort(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic void wiggleSort(int[] nums) {\nint[] arr = nums.clone();\nArrays.sort(arr);\nint n = nums.length;\nint i = (n - 1) >> 1, j = n - 1;\nfor (int k = 0; k < n; ++k) {\nif (k % 2 == 0) {\nnums[k] = arr[i--];\n} else {\nnums[k] = arr[j--];\n}\n}\n}\n}\n", "\nclass Solution {\npublic void wiggleSort(int[] nums) {\nint[] bucket = new int[5001];\nfor (int v : nums) {\n++bucket[v];\n}\nint n = nums.length;\nint j = 5000;\nfor (int i = 1; i < n; i += 2) {\nwhile (bucket[j] == 0) {\n--j;\n}\nnums[i] = j;\n--bucket[j];\n}\nfor (int i = 0; i < n; i += 2) {\nwhile (bucket[j] == 0) {\n--j;\n}\nnums[i] = j;\n--bucket[j];\n}\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {void} Do not return anything, modify nums in-place instead.\n*/\nvar wiggleSort = function (nums) {\nlet bucket = new Array(5001).fill(0);\nfor (const v of nums) {\nbucket[v]++;\n}\nconst n = nums.length;\nlet j = 5000;\nfor (let i = 1; i < n; i += 2) {\nwhile (bucket[j] == 0) {\n--j;\n}\nnums[i] = j;\n--bucket[j];\n}\nfor (let i = 0; i < n; i += 2) {\nwhile (bucket[j] == 0) {\n--j;\n}\nnums[i] = j;\n--bucket[j];\n}\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvoid wiggleSort(vector<int>& nums) {\nvector<int> arr = nums;\nsort(arr.begin(), arr.end());\nint n = nums.size();\nint i = (n - 1) >> 1, j = n - 1;\nfor (int k = 0; k < n; ++k) {\nif (k % 2 == 0)\nnums[k] = arr[i--];\nelse\nnums[k] = arr[j--];\n}\n}\n};\n", "\nclass Solution {\npublic:\nvoid wiggleSort(vector<int>& nums) {\nvector<int> bucket(5001);\nfor (int& v : nums) ++bucket[v];\nint n = nums.size();\nint j = 5000;\nfor (int i = 1; i < n; i += 2) {\nwhile (bucket[j] == 0) --j;\nnums[i] = j;\n--bucket[j];\n}\nfor (int i = 0; i < n; i += 2) {\nwhile (bucket[j] == 0) --j;\nnums[i] = j;\n--bucket[j];\n}\n}\n};\n"]}, {"leetCodeID": "0370", "level": "middle", "question_description": "You are given an integer length and an array updates where updates[i] = [startIdxi, endIdxi, inci].\nYou have an array arr of length length with all zeros, and you have some operation to apply on arr. In the ith operation, you should increment all the elements arr[startIdxi], arr[startIdxi + 1], ..., arr[endIdxi] by inci.\nReturn arr after applying all the updates.", "examples": ["Example 1:\n\n\nInput: length = 5, updates = [[1,3,2],[2,4,3],[0,2,-2]]\nOutput: [-2,0,3,5,3]\n\n\nExample 2:\nInput: length = 10, updates = [[2,4,6],[5,6,8],[1,9,-4]]\nOutput: [0,-4,2,2,2,4,4,-4,-4,-4]\n"], "constraints": "\nConstraints:\n1 <= length <= 105\n0 <= updates.length <= 104\n0 <= startIdxi <= endIdxi < length\n-1000 <= inci <= 1000\n", "java_context": "\nclass Solution {\n    public int[] getModifiedArray(int length, int[][] updates) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number} length\n* @param {number[][]} updates\n* @return {number[]}\n*/\nvar getModifiedArray = function (length, updates) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> getModifiedArray(int length, vector<vector<int>>& updates) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int[] getModifiedArray(int length, int[][] updates) {\nint[] d = new int[length];\nfor (var e : updates) {\nint l = e[0], r = e[1], c = e[2];\nd[l] += c;\nif (r + 1 < length) {\nd[r + 1] -= c;\n}\n}\nfor (int i = 1; i < length; ++i) {\nd[i] += d[i - 1];\n}\nreturn d;\n}\n}\n", "\nclass Solution {\npublic int[] getModifiedArray(int length, int[][] updates) {\nBinaryIndexedTree tree = new BinaryIndexedTree(length);\nfor (int[] e : updates) {\nint start = e[0], end = e[1], inc = e[2];\ntree.update(start + 1, inc);\ntree.update(end + 2, -inc);\n}\nint[] ans = new int[length];\nfor (int i = 0; i < length; ++i) {\nans[i] = tree.query(i + 1);\n}\nreturn ans;\n}\n}\n\nclass BinaryIndexedTree {\nprivate int n;\nprivate int[] c;\n\npublic BinaryIndexedTree(int n) {\nthis.n = n;\nc = new int[n + 1];\n}\n\npublic void update(int x, int delta) {\nwhile (x <= n) {\nc[x] += delta;\nx += lowbit(x);\n}\n}\n\npublic int query(int x) {\nint s = 0;\nwhile (x > 0) {\ns += c[x];\nx -= lowbit(x);\n}\nreturn s;\n}\n\npublic static int lowbit(int x) {\nreturn x & -x;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number} length\n* @param {number[][]} updates\n* @return {number[]}\n*/\nvar getModifiedArray = function (length, updates) {\nconst d = new Array(length).fill(0);\nfor (const [l, r, c] of updates) {\nd[l] += c;\nif (r + 1 < length) {\nd[r + 1] -= c;\n}\n}\nfor (let i = 1; i < length; ++i) {\nd[i] += d[i - 1];\n}\nreturn d;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> getModifiedArray(int length, vector<vector<int>>& updates) {\nvector<int> d(length);\nfor (auto& e : updates) {\nint l = e[0], r = e[1], c = e[2];\nd[l] += c;\nif (r + 1 < length) d[r + 1] -= c;\n}\nfor (int i = 1; i < length; ++i) d[i] += d[i - 1];\nreturn d;\n}\n};\n", "\nclass BinaryIndexedTree {\npublic:\nint n;\nvector<int> c;\n\nBinaryIndexedTree(int _n)\n: n(_n)\n, c(_n + 1) {}\n\nvoid update(int x, int delta) {\nwhile (x <= n) {\nc[x] += delta;\nx += lowbit(x);\n}\n}\n\nint query(int x) {\nint s = 0;\nwhile (x > 0) {\ns += c[x];\nx -= lowbit(x);\n}\nreturn s;\n}\n\nint lowbit(int x) {\nreturn x & -x;\n}\n};\n\nclass Solution {\npublic:\nvector<int> getModifiedArray(int length, vector<vector<int>>& updates) {\nBinaryIndexedTree* tree = new BinaryIndexedTree(length);\nfor (auto& e : updates) {\nint start = e[0], end = e[1], inc = e[2];\ntree->update(start + 1, inc);\ntree->update(end + 2, -inc);\n}\nvector<int> ans;\nfor (int i = 0; i < length; ++i) ans.push_back(tree->query(i + 1));\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0377", "level": "middle", "question_description": "Given an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to target.\nThe test cases are generated so that the answer can fit in a 32-bit integer.", "examples": ["Example 1:\nInput: nums = [1,2,3], target = 4\nOutput: 7\nExplanation:\nThe possible combination ways are:\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\nNote that different sequences are counted as different combinations.\n", "Example 2:\nInput: nums = [9], target = 3\nOutput: 0\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 200\n1 <= nums[i] <= 1000\nAll the elements of nums are unique.\n1 <= target <= 1000\n", "java_context": "\nclass Solution {\n    public int combinationSum4(int[] nums, int target) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @param {number} target\n* @return {number}\n*/\nvar combinationSum4 = function (nums, target) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int combinationSum4(vector<int>& nums, int target) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int combinationSum4(int[] nums, int target) {\nint[] f = new int[target + 1];\nf[0] = 1;\nfor (int i = 1; i <= target; ++i) {\nfor (int x : nums) {\nif (i >= x) {\nf[i] += f[i - x];\n}\n}\n}\nreturn f[target];\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @param {number} target\n* @return {number}\n*/\nvar combinationSum4 = function (nums, target) {\nconst f = Array(target + 1).fill(0);\nf[0] = 1;\nfor (let i = 1; i <= target; ++i) {\nfor (const x of nums) {\nif (i >= x) {\nf[i] += f[i - x];\n}\n}\n}\nreturn f[target];\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint combinationSum4(vector<int>& nums, int target) {\nint f[target + 1];\nmemset(f, 0, sizeof(f));\nf[0] = 1;\nfor (int i = 1; i <= target; ++i) {\nfor (int x : nums) {\nif (i >= x && f[i - x] < INT_MAX - f[i]) {\nf[i] += f[i - x];\n}\n}\n}\nreturn f[target];\n}\n};\n"]}, {"leetCodeID": "0384", "level": "middle", "question_description": "Given an integer array nums, design an algorithm to randomly shuffle the array. All permutations of the array should be equally likely as a result of the shuffling.\nImplement the Solution class:\nSolution(int[] nums) Initializes the object with the integer array nums.\nint[] reset() Resets the array to its original configuration and returns it.\nint[] shuffle() Returns a random shuffling of the array.", "examples": ["Example 1:\nInput\n[&quot;Solution&quot;, &quot;shuffle&quot;, &quot;reset&quot;, &quot;shuffle&quot;]\n[[[1, 2, 3]], [], [], []]\nOutput\n[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]\n\nExplanation\nSolution solution = new Solution([1, 2, 3]);\nsolution.shuffle();    // Shuffle the array [1,2,3] and return its result.\n// Any permutation of [1,2,3] must be equally likely to be returned.\n// Example: return [3, 1, 2]\nsolution.reset();      // Resets the array back to its original configuration [1,2,3]. Return [1, 2, 3]\nsolution.shuffle();    // Returns the random shuffling of array [1,2,3]. Example: return [1, 3, 2]\n\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 50\n-106 <= nums[i] <= 106\nAll the elements of nums are unique.\nAt most 104 calls in total will be made to reset and shuffle.\n", "java_context": "\nclass Solution {\n    private int[] nums;\n        // your code\n    }\n}", "js_context": "\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> nums;\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\nprivate int[] nums;\nprivate int[] original;\nprivate Random rand;\n\npublic Solution(int[] nums) {\nthis.nums = nums;\nthis.original = Arrays.copyOf(nums, nums.length);\nthis.rand = new Random();\n}\n\npublic int[] reset() {\nnums = Arrays.copyOf(original, original.length);\nreturn nums;\n}\n\npublic int[] shuffle() {\nfor (int i = 0; i < nums.length; ++i) {\nswap(i, i + rand.nextInt(nums.length - i));\n}\nreturn nums;\n}\n\nprivate void swap(int i, int j) {\nint t = nums[i];\nnums[i] = nums[j];\nnums[j] = t;\n}\n}\n\n/**\n* Your Solution object will be instantiated and called as such:\n* Solution obj = new Solution(nums);\n* int[] param_1 = obj.reset();\n* int[] param_2 = obj.shuffle();\n*/\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n*/\nconst Solution = function (nums) {\nthis.nums = nums || [];\n};\n\n/**\n* Resets the array to its original configuration and return it.\n* @return {number[]}\n*/\nSolution.prototype.reset = function () {\nreturn this.nums;\n};\n\n/**\n* Returns a random shuffling of the array.\n* @return {number[]}\n*/\nSolution.prototype.shuffle = function () {\nlet a = this.nums.slice();\nfor (let i = 0; i < a.length; i++) {\nlet rand = Math.floor(Math.random() * (a.length - i)) + i;\nlet tmp = a[i];\na[i] = a[rand];\na[rand] = tmp;\n}\nreturn a;\n};\n\n/**\n* Your Solution object will be instantiated and called as such:\n* var obj = Object.create(Solution).createNew(nums)\n* var param_1 = obj.reset()\n* var param_2 = obj.shuffle()\n*/\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> nums;\nvector<int> original;\n\nSolution(vector<int>& nums) {\nthis->nums = nums;\nthis->original.resize(nums.size());\ncopy(nums.begin(), nums.end(), original.begin());\n}\n\nvector<int> reset() {\ncopy(original.begin(), original.end(), nums.begin());\nreturn nums;\n}\n\nvector<int> shuffle() {\nfor (int i = 0; i < nums.size(); ++i) {\nint j = i + rand() % (nums.size() - i);\nswap(nums[i], nums[j]);\n}\nreturn nums;\n}\n};\n\n/**\n* Your Solution object will be instantiated and called as such:\n* Solution* obj = new Solution(nums);\n* vector<int> param_1 = obj->reset();\n* vector<int> param_2 = obj->shuffle();\n*/\n"]}, {"leetCodeID": "0386", "level": "middle", "question_description": "Given an integer n, return all the numbers in the range [1, n] sorted in lexicographical order.\nYou must write an algorithm that runs in O(n) time and uses O(1) extra space.", "examples": ["Example 1:Input: n = 13\nOutput: [1,10,11,12,13,2,3,4,5,6,7,8,9]\n", "Example 2:Input: n = 2\nOutput: [1,2]\n"], "constraints": "\nConstraints:\n1 <= n <= 5 * 104\n", "java_context": "\nclass Solution {\n    public List<Integer> lexicalOrder(int n) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number} n\n* @return {number[]}\n*/\nvar lexicalOrder = function (n) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> lexicalOrder(int n) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic List<Integer> lexicalOrder(int n) {\nList<Integer> ans = new ArrayList<>();\nfor (int i = 1; i < 10; ++i) {\ndfs(i, n, ans);\n}\nreturn ans;\n}\n\nprivate void dfs(int u, int n, List<Integer> ans) {\nif (u > n) {\nreturn;\n}\nans.add(u);\nfor (int i = 0; i < 10; ++i) {\ndfs(u * 10 + i, n, ans);\n}\n}\n}\n", "\nclass Solution {\npublic List<Integer> lexicalOrder(int n) {\nList<Integer> ans = new ArrayList<>();\nint v = 1;\nfor (int i = 0; i < n; ++i) {\nans.add(v);\nif (v * 10 <= n) {\nv *= 10;\n} else {\nwhile (v % 10 == 9 || v + 1 > n) {\nv /= 10;\n}\n++v;\n}\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number} n\n* @return {number[]}\n*/\nvar lexicalOrder = function (n) {\nlet ans = [];\nfunction dfs(u) {\nif (u > n) {\nreturn;\n}\nans.push(u);\nfor (let i = 0; i < 10; ++i) {\ndfs(u * 10 + i);\n}\n}\nfor (let i = 1; i < 10; ++i) {\ndfs(i);\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> lexicalOrder(int n) {\nvector<int> ans;\nfor (int i = 1; i < 10; ++i) dfs(i, n, ans);\nreturn ans;\n}\n\nvoid dfs(int u, int n, vector<int>& ans) {\nif (u > n) return;\nans.push_back(u);\nfor (int i = 0; i < 10; ++i) dfs(u * 10 + i, n, ans);\n}\n};\n", "\nclass Solution {\npublic:\nvector<int> lexicalOrder(int n) {\nvector<int> ans;\nint v = 1;\nfor (int i = 0; i < n; ++i) {\nans.push_back(v);\nif (v * 10 <= n)\nv *= 10;\nelse {\nwhile (v % 10 == 9 || v + 1 > n) v /= 10;\n++v;\n}\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0400", "level": "middle", "question_description": "Given an integer n, return the nth digit of the infinite integer sequence [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...].", "examples": ["Example 1:\nInput: n = 3\nOutput: 3\n", "Example 2:\nInput: n = 11\nOutput: 0\nExplanation: The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.\n"], "constraints": "\nConstraints:\n1 <= n <= 231 - 1\n", "java_context": "\nclass Solution {\n    public int findNthDigit(int n) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number} n\n* @return {number}\n*/\nvar findNthDigit = function (n) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int findNthDigit(int n) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int findNthDigit(int n) {\nint k = 1, cnt = 9;\nwhile ((long) k * cnt < n) {\nn -= k * cnt;\n++k;\ncnt *= 10;\n}\nint num = (int) Math.pow(10, k - 1) + (n - 1) / k;\nint idx = (n - 1) % k;\nreturn String.valueOf(num).charAt(idx) - '0';\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number} n\n* @return {number}\n*/\nvar findNthDigit = function (n) {\nlet k = 1,\ncnt = 9;\nwhile (k * cnt < n) {\nn -= k * cnt;\n++k;\ncnt *= 10;\n}\nconst num = Math.pow(10, k - 1) + (n - 1) / k;\nconst idx = (n - 1) % k;\nreturn num.toString()[idx];\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint findNthDigit(int n) {\nint k = 1, cnt = 9;\nwhile (1ll * k * cnt < n) {\nn -= k * cnt;\n++k;\ncnt *= 10;\n}\nint num = pow(10, k - 1) + (n - 1) / k;\nint idx = (n - 1) % k;\nreturn to_string(num)[idx] - '0';\n}\n};\n"]}, {"leetCodeID": "0416", "level": "middle", "question_description": "Given an integer array nums, return true if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or false otherwise.", "examples": ["Example 1:\nInput: nums = [1,5,11,5]\nOutput: true\nExplanation: The array can be partitioned as [1, 5, 5] and [11].\n", "Example 2:\nInput: nums = [1,2,3,5]\nOutput: false\nExplanation: The array cannot be partitioned into equal sum subsets.\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 200\n1 <= nums[i] <= 100\n", "java_context": "\nclass Solution {\n    public boolean canPartition(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {boolean}\n*/\nvar canPartition = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    bool canPartition(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic boolean canPartition(int[] nums) {\n// int s = Arrays.stream(nums).sum();\nint s = 0;\nfor (int x : nums) {\ns += x;\n}\nif (s % 2 == 1) {\nreturn false;\n}\nint n = nums.length;\nint m = s >> 1;\nboolean[][] f = new boolean[n + 1][m + 1];\nf[0][0] = true;\nfor (int i = 1; i <= n; ++i) {\nint x = nums[i - 1];\nfor (int j = 0; j <= m; ++j) {\nf[i][j] = f[i - 1][j] || (j >= x && f[i - 1][j - x]);\n}\n}\nreturn f[n][m];\n}\n}\n", "\nclass Solution {\npublic boolean canPartition(int[] nums) {\n// int s = Arrays.stream(nums).sum();\nint s = 0;\nfor (int x : nums) {\ns += x;\n}\nif (s % 2 == 1) {\nreturn false;\n}\nint m = s >> 1;\nboolean[] f = new boolean[m + 1];\nf[0] = true;\nfor (int x : nums) {\nfor (int j = m; j >= x; --j) {\nf[j] |= f[j - x];\n}\n}\nreturn f[m];\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {boolean}\n*/\nvar canPartition = function (nums) {\nconst s = nums.reduce((a, b) => a + b, 0);\nif (s % 2 === 1) {\nreturn false;\n}\nconst n = nums.length;\nconst m = s >> 1;\nconst f = Array(n + 1)\n.fill(0)\n.map(() => Array(m + 1).fill(false));\nf[0][0] = true;\nfor (let i = 1; i <= n; ++i) {\nconst x = nums[i - 1];\nfor (let j = 0; j <= m; ++j) {\nf[i][j] = f[i - 1][j] || (j >= x && f[i - 1][j - x]);\n}\n}\nreturn f[n][m];\n};\n", "\n/**\n* @param {number[]} nums\n* @return {boolean}\n*/\nvar canPartition = function (nums) {\nconst s = nums.reduce((a, b) => a + b, 0);\nif (s % 2 === 1) {\nreturn false;\n}\nconst m = s >> 1;\nconst f = Array(m + 1).fill(false);\nf[0] = true;\nfor (const x of nums) {\nfor (let j = m; j >= x; --j) {\nf[j] = f[j] || f[j - x];\n}\n}\nreturn f[m];\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nbool canPartition(vector<int>& nums) {\nint s = accumulate(nums.begin(), nums.end(), 0);\nif (s % 2 == 1) {\nreturn false;\n}\nint n = nums.size();\nint m = s >> 1;\nbool f[n + 1][m + 1];\nmemset(f, false, sizeof(f));\nf[0][0] = true;\nfor (int i = 1; i <= n; ++i) {\nint x = nums[i - 1];\nfor (int j = 0; j <= m; ++j) {\nf[i][j] = f[i - 1][j] || (j >= x && f[i - 1][j - x]);\n}\n}\nreturn f[n][m];\n}\n};\n", "\nclass Solution {\npublic:\nbool canPartition(vector<int>& nums) {\nint s = accumulate(nums.begin(), nums.end(), 0);\nif (s % 2 == 1) {\nreturn false;\n}\nint m = s >> 1;\nbool f[m + 1];\nmemset(f, false, sizeof(f));\nf[0] = true;\nfor (int& x : nums) {\nfor (int j = m; j >= x; --j) {\nf[j] |= f[j - x];\n}\n}\nreturn f[m];\n}\n};\n"]}, {"leetCodeID": "0426", "level": "middle", "question_description": "Convert a Binary Search Tree to a sorted Circular Doubly-Linked List in place.\nYou can think of the left and right pointers as synonymous to the predecessor and successor pointers in a doubly-linked list. For a circular doubly linked list, the predecessor of the first element is the last element, and the successor of the last element is the first element.\nWe want to do the transformation in place. After the transformation, the left pointer of the tree node should point to its predecessor, and the right pointer should point to its successor. You should return the pointer to the smallest element of the linked list.", "examples": ["Example 1:\n\n\n\n\nInput: root = [4,2,5,1,3]\n\n\nOutput: [1,2,3,4,5]\n\nExplanation: The figure below shows the transformed BST. The solid line indicates the successor relationship, while the dashed line means the predecessor relationship.\n\n\n\nExample 2:\nInput: root = [2,1,3]\nOutput: [1,2,3]\n"], "constraints": "\nConstraints:\nThe number of nodes in the tree is in the range [0, 2000].\n-1000 <= Node.val <= 1000\nAll the values of the tree are unique.\n", "java_context": "\n/*\n// Definition for a Node.\nclass Node {\npublic int val;\npublic Node left;\npublic Node right;\n\npublic Node() {}\n\npublic Node(int _val) {\nval = _val;\n}\n\npublic Node(int _val,Node _left,Node _right) {\nval = _val;\nleft = _left;\nright = _right;\n}\n};\n*/\n\nclass Solution {\n    private Node prev;\n        // your code\n    }\n}", "js_context": "\n/**\n* // Definition for a Node.\n* function Node(val, left, right) {\n*      this.val = val;\n*      this.left = left;\n*      this.right = right;\n*  };\n*/\n\n/**\n* @param {Node} root\n* @return {Node}\n*/\nvar treeToDoublyList = function (root) {\n    // your code\n};", "cpp_context": "\n/*\n// Definition for a Node.\nclass Node {\npublic:\nint val;\nNode* left;\nNode* right;\n\nNode() {}\n\nNode(int _val) {\nval = _val;\nleft = NULL;\nright = NULL;\n}\n\nNode(int _val, Node* _left, Node* _right) {\nval = _val;\nleft = _left;\nright = _right;\n}\n};\n*/\n\nclass Solution {\npublic:\n    Node* prev;\n        // your code\n    }\n};", "java_solutions": ["\n/*\n// Definition for a Node.\nclass Node {\npublic int val;\npublic Node left;\npublic Node right;\n\npublic Node() {}\n\npublic Node(int _val) {\nval = _val;\n}\n\npublic Node(int _val,Node _left,Node _right) {\nval = _val;\nleft = _left;\nright = _right;\n}\n};\n*/\n\nclass Solution {\nprivate Node prev;\nprivate Node head;\n\npublic Node treeToDoublyList(Node root) {\nif (root == null) {\nreturn null;\n}\nprev = null;\nhead = null;\ndfs(root);\nprev.right = head;\nhead.left = prev;\nreturn head;\n}\n\nprivate void dfs(Node root) {\nif (root == null) {\nreturn;\n}\ndfs(root.left);\nif (prev != null) {\nprev.right = root;\nroot.left = prev;\n} else {\nhead = root;\n}\nprev = root;\ndfs(root.right);\n}\n}\n"], "js_solutions": ["\n/**\n* // Definition for a Node.\n* function Node(val, left, right) {\n*      this.val = val;\n*      this.left = left;\n*      this.right = right;\n*  };\n*/\n\n/**\n* @param {Node} root\n* @return {Node}\n*/\nvar treeToDoublyList = function (root) {\nif (!root) return root;\nlet prev = null;\nlet head = null;\n\nfunction dfs(root) {\nif (!root) return;\ndfs(root.left);\nif (prev) {\nprev.right = root;\nroot.left = prev;\n} else {\nhead = root;\n}\nprev = root;\ndfs(root.right);\n}\ndfs(root);\nprev.right = head;\nhead.left = prev;\nreturn head;\n};\n"], "cpp_solutions": ["\n/*\n// Definition for a Node.\nclass Node {\npublic:\nint val;\nNode* left;\nNode* right;\n\nNode() {}\n\nNode(int _val) {\nval = _val;\nleft = NULL;\nright = NULL;\n}\n\nNode(int _val, Node* _left, Node* _right) {\nval = _val;\nleft = _left;\nright = _right;\n}\n};\n*/\n\nclass Solution {\npublic:\nNode* prev;\nNode* head;\n\nNode* treeToDoublyList(Node* root) {\nif (!root) return nullptr;\nprev = nullptr;\nhead = nullptr;\ndfs(root);\nprev->right = head;\nhead->left = prev;\nreturn head;\n}\n\nvoid dfs(Node* root) {\nif (!root) return;\ndfs(root->left);\nif (prev) {\nprev->right = root;\nroot->left = prev;\n} else\nhead = root;\nprev = root;\ndfs(root->right);\n}\n};\n"]}, {"leetCodeID": "0494", "level": "middle", "question_description": "You are given an integer array nums and an integer target.\nYou want to build an expression out of nums by adding one of the symbols &#39;+&#39; and &#39;-&#39; before each integer in nums and then concatenate all the integers.\nFor example, if nums = [2, 1], you can add a &#39;+&#39; before 2 and a &#39;-&#39; before 1 and concatenate them to build the expression &quot;+2-1&quot;.\nReturn the number of different expressions that you can build, which evaluates to target.", "examples": ["Example 1:\nInput: nums = [1,1,1,1,1], target = 3\nOutput: 5\nExplanation: There are 5 ways to assign symbols to make the sum of nums be target 3.\n-1 + 1 + 1 + 1 + 1 = 3\n+1 - 1 + 1 + 1 + 1 = 3\n+1 + 1 - 1 + 1 + 1 = 3\n+1 + 1 + 1 - 1 + 1 = 3\n+1 + 1 + 1 + 1 - 1 = 3\n", "Example 2:\nInput: nums = [1], target = 1\nOutput: 1\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 20\n0 <= nums[i] <= 1000\n0 <= sum(nums[i]) <= 1000\n-1000 <= target <= 1000\n", "java_context": "\nclass Solution {\n    public int findTargetSumWays(int[] nums, int target) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @param {number} target\n* @return {number}\n*/\nvar findTargetSumWays = function (nums, target) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int target) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int findTargetSumWays(int[] nums, int target) {\nint s = 0;\nfor (int v : nums) {\ns += v;\n}\nif (s < target || (s - target) % 2 != 0) {\nreturn 0;\n}\nint m = nums.length;\nint n = (s - target) / 2;\nint[][] dp = new int[m + 1][n + 1];\ndp[0][0] = 1;\nfor (int i = 1; i <= m; ++i) {\nfor (int j = 0; j <= n; ++j) {\ndp[i][j] = dp[i - 1][j];\nif (nums[i - 1] <= j) {\ndp[i][j] += dp[i - 1][j - nums[i - 1]];\n}\n}\n}\nreturn dp[m][n];\n}\n}\n", "\nclass Solution {\npublic int findTargetSumWays(int[] nums, int target) {\nint s = 0;\nfor (int v : nums) {\ns += v;\n}\nif (s < target || (s - target) % 2 != 0) {\nreturn 0;\n}\nint n = (s - target) / 2;\nint[] dp = new int[n + 1];\ndp[0] = 1;\nfor (int v : nums) {\nfor (int j = n; j >= v; --j) {\ndp[j] += dp[j - v];\n}\n}\nreturn dp[n];\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @param {number} target\n* @return {number}\n*/\nvar findTargetSumWays = function (nums, target) {\nlet s = 0;\nfor (let v of nums) {\ns += v;\n}\nif (s < target || (s - target) % 2 != 0) {\nreturn 0;\n}\nconst m = nums.length;\nconst n = (s - target) / 2;\nlet dp = new Array(n + 1).fill(0);\ndp[0] = 1;\nfor (let i = 1; i <= m; ++i) {\nfor (let j = n; j >= nums[i - 1]; --j) {\ndp[j] += dp[j - nums[i - 1]];\n}\n}\nreturn dp[n];\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint findTargetSumWays(vector<int>& nums, int target) {\nint s = accumulate(nums.begin(), nums.end(), 0);\nif (s < target || (s - target) % 2 != 0) return 0;\nint m = nums.size(), n = (s - target) / 2;\nvector<vector<int>> dp(m + 1, vector<int>(n + 1));\ndp[0][0] = 1;\nfor (int i = 1; i <= m; ++i) {\nfor (int j = 0; j <= n; ++j) {\ndp[i][j] += dp[i - 1][j];\nif (nums[i - 1] <= j) dp[i][j] += dp[i - 1][j - nums[i - 1]];\n}\n}\nreturn dp[m][n];\n}\n};\n", "\nclass Solution {\npublic:\nint findTargetSumWays(vector<int>& nums, int target) {\nint s = accumulate(nums.begin(), nums.end(), 0);\nif (s < target || (s - target) % 2 != 0) return 0;\nint n = (s - target) / 2;\nvector<int> dp(n + 1);\ndp[0] = 1;\nfor (int& v : nums)\nfor (int j = n; j >= v; --j)\ndp[j] += dp[j - v];\nreturn dp[n];\n}\n};\n"]}, {"leetCodeID": "0503", "level": "middle", "question_description": "Given a circular integer array nums (i.e., the next element of nums[nums.length - 1] is nums[0]), return the next greater number for every element in nums.\nThe next greater number of a number x is the first greater number to its traversing-order next in the array, which means you could search circularly to find its next greater number. If it doesn&#39;t exist, return -1 for this number.", "examples": ["Example 1:\nInput: nums = [1,2,1]\nOutput: [2,-1,2]\nExplanation: The first 1&#39;s next greater number is 2;\nThe number 2 can&#39;t find next greater number.\nThe second 1&#39;s next greater number needs to search circularly, which is also 2.\n", "Example 2:\nInput: nums = [1,2,3,4,3]\nOutput: [2,3,4,-1,4]\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 104\n-109 <= nums[i] <= 109\n", "java_context": "\nclass Solution {\n    public int[] nextGreaterElements(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number[]}\n*/\nvar nextGreaterElements = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> nextGreaterElements(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int[] nextGreaterElements(int[] nums) {\nint n = nums.length;\nint[] ans = new int[n];\nArrays.fill(ans, -1);\nDeque<Integer> stk = new ArrayDeque<>();\nfor (int i = 0; i < (n << 1); ++i) {\nwhile (!stk.isEmpty() && nums[stk.peek()] < nums[i % n]) {\nans[stk.pop()] = nums[i % n];\n}\nstk.push(i % n);\n}\nreturn ans;\n}\n}\n", "\nclass Solution {\npublic int[] nextGreaterElements(int[] nums) {\nint n = nums.length;\nint[] ans = new int[n];\nArrays.fill(ans, -1);\nDeque<Integer> stk = new ArrayDeque<>();\nfor (int i = n * 2 - 1; i >= 0; --i) {\nint j = i % n;\nwhile (!stk.isEmpty() && stk.peek() <= nums[j]) {\nstk.pop();\n}\nif (!stk.isEmpty()) {\nans[j] = stk.peek();\n}\nstk.push(nums[j]);\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number[]}\n*/\nvar nextGreaterElements = function (nums) {\nconst n = nums.length;\nlet stk = [];\nlet ans = new Array(n).fill(-1);\nfor (let i = 0; i < n << 1; i++) {\nconst j = i % n;\nwhile (stk.length && nums[stk[stk.length - 1]] < nums[j]) {\nans[stk.pop()] = nums[j];\n}\nstk.push(j);\n}\nreturn ans;\n};\n", "\n/**\n* @param {number[]} nums\n* @return {number[]}\n*/\nvar nextGreaterElements = function (nums) {\nconst n = nums.length;\nlet stk = [];\nlet ans = new Array(n).fill(-1);\nfor (let i = n * 2 - 1; ~i; --i) {\nconst j = i % n;\nwhile (stk.length && stk[stk.length - 1] <= nums[j]) {\nstk.pop();\n}\nif (stk.length) {\nans[j] = stk[stk.length - 1];\n}\nstk.push(nums[j]);\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> nextGreaterElements(vector<int>& nums) {\nint n = nums.size();\nvector<int> ans(n, -1);\nstack<int> stk;\nfor (int i = 0; i < (n << 1); ++i) {\nwhile (!stk.empty() && nums[stk.top()] < nums[i % n]) {\nans[stk.top()] = nums[i % n];\nstk.pop();\n}\nstk.push(i % n);\n}\nreturn ans;\n}\n};\n", "\nclass Solution {\npublic:\nvector<int> nextGreaterElements(vector<int>& nums) {\nint n = nums.size();\nvector<int> ans(n, -1);\nstack<int> stk;\nfor (int i = n * 2 - 1; ~i; --i) {\nint j = i % n;\nwhile (!stk.empty() && stk.top() <= nums[j]) stk.pop();\nif (!stk.empty()) ans[j] = stk.top();\nstk.push(nums[j]);\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0510", "level": "middle", "question_description": "Given a node in a binary search tree, return the in-order successor of that node in the BST. If that node has no in-order successor, return null.\nThe successor of a node is the node with the smallest key greater than node.val.\nYou will have direct access to the node but not to the root of the tree. Each node will have a reference to its parent node. Below is the definition for Node:\nclass Node {\npublic int val;\npublic Node left;\npublic Node right;\npublic Node parent;\n}", "examples": [], "constraints": "\nConstraints:\nThe number of nodes in the tree is in the range [1, 104].\n-105 <= Node.val <= 105\nAll Nodes will have unique values.\n", "java_context": "\n/*\n// Definition for a Node.\nclass Node {\npublic int val;\npublic Node left;\npublic Node right;\npublic Node parent;\n};\n*/\n\nclass Solution {\n    public Node inorderSuccessor(Node node) {\n        // your code\n    }\n}", "js_context": "\n/**\n* // Definition for a Node.\n* function Node(val) {\n*    this.val = val;\n*    this.left = null;\n*    this.right = null;\n*    this.parent = null;\n* };\n*/\n\n/**\n* @param {Node} node\n* @return {Node}\n*/\nvar inorderSuccessor = function (node) {\n    // your code\n};", "cpp_context": "\n/*\n// Definition for a Node.\nclass Node {\npublic:\nint val;\nNode* left;\nNode* right;\nNode* parent;\n};\n*/\n\nclass Solution {\npublic:\n    Node* inorderSuccessor(Node* node) {\n        // your code\n    }\n};", "java_solutions": ["\n/*\n// Definition for a Node.\nclass Node {\npublic int val;\npublic Node left;\npublic Node right;\npublic Node parent;\n};\n*/\n\nclass Solution {\npublic Node inorderSuccessor(Node node) {\nif (node.right != null) {\nnode = node.right;\nwhile (node.left != null) {\nnode = node.left;\n}\nreturn node;\n}\nwhile (node.parent != null && node.parent.right == node) {\nnode = node.parent;\n}\nreturn node.parent;\n}\n}\n"], "js_solutions": ["\n/**\n* // Definition for a Node.\n* function Node(val) {\n*    this.val = val;\n*    this.left = null;\n*    this.right = null;\n*    this.parent = null;\n* };\n*/\n\n/**\n* @param {Node} node\n* @return {Node}\n*/\nvar inorderSuccessor = function (node) {\nif (node.right) {\nnode = node.right;\nwhile (node.left) {\nnode = node.left;\n}\nreturn node;\n}\nwhile (node.parent && node === node.parent.right) {\nnode = node.parent;\n}\nreturn node.parent;\n};\n"], "cpp_solutions": ["\n/*\n// Definition for a Node.\nclass Node {\npublic:\nint val;\nNode* left;\nNode* right;\nNode* parent;\n};\n*/\n\nclass Solution {\npublic:\nNode* inorderSuccessor(Node* node) {\nif (node->right) {\nnode = node->right;\nwhile (node->left) {\nnode = node->left;\n}\nreturn node;\n}\nwhile (node->parent && node->parent->right == node) {\nnode = node->parent;\n}\nreturn node->parent;\n}\n};\n"]}, {"leetCodeID": "0525", "level": "middle", "question_description": "Given a binary array nums, return the maximum length of a contiguous subarray with an equal number of 0 and 1.", "examples": ["Example 1:\nInput: nums = [0,1]\nOutput: 2\nExplanation: [0, 1] is the longest contiguous subarray with an equal number of 0 and 1.\n", "Example 2:\nInput: nums = [0,1,0]\nOutput: 2\nExplanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1.\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 105\nnums[i] is either 0 or 1.\n", "java_context": "\nclass Solution {\n    public int findMaxLength(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar findMaxLength = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int findMaxLength(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int findMaxLength(int[] nums) {\nMap<Integer, Integer> mp = new HashMap<>();\nmp.put(0, -1);\nint s = 0, ans = 0;\nfor (int i = 0; i < nums.length; ++i) {\ns += nums[i] == 1 ? 1 : -1;\nif (mp.containsKey(s)) {\nans = Math.max(ans, i - mp.get(s));\n} else {\nmp.put(s, i);\n}\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar findMaxLength = function (nums) {\nconst mp = new Map();\nmp.set(0, -1);\nlet s = 0;\nlet ans = 0;\nfor (let i = 0; i < nums.length; ++i) {\ns += nums[i] == 0 ? -1 : 1;\nif (mp.has(s)) ans = Math.max(ans, i - mp.get(s));\nelse mp.set(s, i);\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint findMaxLength(vector<int>& nums) {\nunordered_map<int, int> mp;\nint s = 0, ans = 0;\nmp[0] = -1;\nfor (int i = 0; i < nums.size(); ++i) {\ns += nums[i] == 1 ? 1 : -1;\nif (mp.count(s))\nans = max(ans, i - mp[s]);\nelse\nmp[s] = i;\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0528", "level": "middle", "question_description": "You are given a 0-indexed array of positive integers w where w[i] describes the weight of the ith index.\nYou need to implement the function pickIndex(), which randomly picks an index in the range [0, w.length - 1] (inclusive) and returns it. The probability of picking an index i is w[i] / sum(w).\nFor example, if w = [1, 3], the probability of picking index 0 is 1 / (1 + 3) = 0.25 (i.e., 25%), and the probability of picking index 1 is 3 / (1 + 3) = 0.75 (i.e., 75%).", "examples": ["Example 1:\nInput\n[&quot;Solution&quot;,&quot;pickIndex&quot;]\n[[[1]],[]]\nOutput\n[null,0]\n\nExplanation\nSolution solution = new Solution([1]);\nsolution.pickIndex(); // return 0. The only option is to return 0 since there is only one element in w.\n", "Example 2:\nInput\n[&quot;Solution&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;,&quot;pickIndex&quot;]\n[[[1,3]],[],[],[],[],[]]\nOutput\n[null,1,1,1,1,0]\n\nExplanation\nSolution solution = new Solution([1, 3]);\nsolution.pickIndex(); // return 1. It is returning the second element (index = 1) that has a probability of 3/4.\nsolution.pickIndex(); // return 1\nsolution.pickIndex(); // return 1\nsolution.pickIndex(); // return 1\nsolution.pickIndex(); // return 0. It is returning the first element (index = 0) that has a probability of 1/4.\n\nSince this is a randomization problem, multiple answers are allowed.\nAll of the following outputs can be considered correct:\n[null,1,1,1,1,0]\n[null,1,1,1,1,1]\n[null,1,1,1,0,0]\n[null,1,1,1,0,1]\n[null,1,0,1,0,0]\n......\nand so on.\n"], "constraints": "\nConstraints:\n1 <= w.length <= 104\n1 <= w[i] <= 105\npickIndex will be called at most 104 times.\n", "java_context": "\nclass Solution {\n    private int[] s;\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} w\n*/\nvar Solution = function (w) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> s;\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\nprivate int[] s;\nprivate Random random = new Random();\n\npublic Solution(int[] w) {\nint n = w.length;\ns = new int[n + 1];\nfor (int i = 0; i < n; ++i) {\ns[i + 1] = s[i] + w[i];\n}\n}\n\npublic int pickIndex() {\nint x = 1 + random.nextInt(s[s.length - 1]);\nint left = 1, right = s.length - 1;\nwhile (left < right) {\nint mid = (left + right) >> 1;\nif (s[mid] >= x) {\nright = mid;\n} else {\nleft = mid + 1;\n}\n}\nreturn left - 1;\n}\n}\n\n/**\n* Your Solution object will be instantiated and called as such:\n* Solution obj = new Solution(w);\n* int param_1 = obj.pickIndex();\n*/\n"], "js_solutions": ["\n/**\n* @param {number[]} w\n*/\nvar Solution = function (w) {\nconst n = w.length;\nthis.s = new Array(n + 1).fill(0);\nfor (let i = 0; i < n; ++i) {\nthis.s[i + 1] = this.s[i] + w[i];\n}\n};\n\n/**\n* @return {number}\n*/\nSolution.prototype.pickIndex = function () {\nconst n = this.s.length;\nconst x = 1 + Math.floor(Math.random() * this.s[n - 1]);\nlet left = 1,\nright = n - 1;\nwhile (left < right) {\nconst mid = (left + right) >> 1;\nif (this.s[mid] >= x) {\nright = mid;\n} else {\nleft = mid + 1;\n}\n}\nreturn left - 1;\n};\n\n/**\n* Your Solution object will be instantiated and called as such:\n* var obj = new Solution(w)\n* var param_1 = obj.pickIndex()\n*/\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> s;\n\nSolution(vector<int>& w) {\nint n = w.size();\ns.resize(n + 1);\nfor (int i = 0; i < n; ++i) s[i + 1] = s[i] + w[i];\n}\n\nint pickIndex() {\nint n = s.size();\nint x = 1 + rand() % s[n - 1];\nint left = 1, right = n - 1;\nwhile (left < right) {\nint mid = left + right >> 1;\nif (s[mid] >= x)\nright = mid;\nelse\nleft = mid + 1;\n}\nreturn left - 1;\n}\n};\n\n/**\n* Your Solution object will be instantiated and called as such:\n* Solution* obj = new Solution(w);\n* int param_1 = obj->pickIndex();\n*/\n"]}, {"leetCodeID": "0538", "level": "middle", "question_description": "Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.\nAs a reminder, a binary search tree is a tree that satisfies these constraints:\nThe left subtree of a node contains only nodes with keys less than the node&#39;s key.\nThe right subtree of a node contains only nodes with keys greater than the node&#39;s key.\nBoth the left and right subtrees must also be binary search trees.", "examples": ["Example 1:\n\n\nInput: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]\nOutput: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]\n\n\nExample 2:\nInput: root = [0,null,1]\nOutput: [1,null,1]\n"], "constraints": "\nConstraints:\nThe number of nodes in the tree is in the range [0, 104].\n-104 <= Node.val <= 104\nAll the values in the tree are unique.\nroot is guaranteed to be a valid binary search tree.\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\n    private int s;\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {TreeNode}\n*/\nvar convertBST = function (root) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    int s = 0;\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\nprivate int s;\n\npublic TreeNode convertBST(TreeNode root) {\ndfs(root);\nreturn root;\n}\n\nprivate void dfs(TreeNode root) {\nif (root == null) {\nreturn;\n}\ndfs(root.right);\ns += root.val;\nroot.val = s;\ndfs(root.left);\n}\n}\n", "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\npublic TreeNode convertBST(TreeNode root) {\nint s = 0;\nTreeNode node = root;\nwhile (root != null) {\nif (root.right == null) {\ns += root.val;\nroot.val = s;\nroot = root.left;\n} else {\nTreeNode next = root.right;\nwhile (next.left != null && next.left != root) {\nnext = next.left;\n}\nif (next.left == null) {\nnext.left = root;\nroot = root.right;\n} else {\ns += root.val;\nroot.val = s;\nnext.left = null;\nroot = root.left;\n}\n}\n}\nreturn node;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {TreeNode}\n*/\nvar convertBST = function (root) {\nlet s = 0;\nfunction dfs(root) {\nif (!root) {\nreturn;\n}\ndfs(root.right);\ns += root.val;\nroot.val = s;\ndfs(root.left);\n}\ndfs(root);\nreturn root;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nint s = 0;\n\nTreeNode* convertBST(TreeNode* root) {\ndfs(root);\nreturn root;\n}\n\nvoid dfs(TreeNode* root) {\nif (!root) return;\ndfs(root->right);\ns += root->val;\nroot->val = s;\ndfs(root->left);\n}\n};\n", "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nTreeNode* convertBST(TreeNode* root) {\nint s = 0;\nTreeNode* node = root;\nwhile (root) {\nif (root->right == nullptr) {\ns += root->val;\nroot->val = s;\nroot = root->left;\n} else {\nTreeNode* next = root->right;\nwhile (next->left && next->left != root) {\nnext = next->left;\n}\nif (next->left == nullptr) {\nnext->left = root;\nroot = root->right;\n} else {\ns += root->val;\nroot->val = s;\nnext->left = nullptr;\nroot = root->left;\n}\n}\n}\nreturn node;\n}\n};\n"]}, {"leetCodeID": "0647", "level": "middle", "question_description": "Given a string s, return the number of palindromic substrings in it.\nA string is a palindrome when it reads the same backward as forward.\nA substring is a contiguous sequence of characters within the string.", "examples": ["Example 1:\nInput: s = &quot;abc&quot;\nOutput: 3\nExplanation: Three palindromic strings: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;.\n", "Example 2:\nInput: s = &quot;aaa&quot;\nOutput: 6\nExplanation: Six palindromic strings: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;.\n"], "constraints": "\nConstraints:\n1 <= s.length <= 1000\ns consists of lowercase English letters.\n", "java_context": "\nclass Solution {\n    public int countSubstrings(String s) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} s\n* @return {number}\n*/\nvar countSubstrings = function (s) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int countSubstrings(string s) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int countSubstrings(String s) {\nint ans = 0;\nint n = s.length();\nfor (int k = 0; k < n * 2 - 1; ++k) {\nint i = k / 2, j = (k + 1) / 2;\nwhile (i >= 0 && j < n && s.charAt(i) == s.charAt(j)) {\n++ans;\n--i;\n++j;\n}\n}\nreturn ans;\n}\n}\n", "\nclass Solution {\npublic int countSubstrings(String s) {\nStringBuilder sb = new StringBuilder(\"^#\");\nfor (char ch : s.toCharArray()) {\nsb.append(ch).append('#');\n}\nString t = sb.append('$').toString();\nint n = t.length();\nint[] p = new int[n];\nint pos = 0, maxRight = 0;\nint ans = 0;\nfor (int i = 1; i < n - 1; i++) {\np[i] = maxRight > i ? Math.min(maxRight - i, p[2 * pos - i]) : 1;\nwhile (t.charAt(i - p[i]) == t.charAt(i + p[i])) {\np[i]++;\n}\nif (i + p[i] > maxRight) {\nmaxRight = i + p[i];\npos = i;\n}\nans += p[i] / 2;\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} s\n* @return {number}\n*/\nvar countSubstrings = function (s) {\nlet ans = 0;\nconst n = s.length;\nfor (let k = 0; k < n * 2 - 1; ++k) {\nlet i = k >> 1;\nlet j = (k + 1) >> 1;\nwhile (~i && j < n && s[i] == s[j]) {\n++ans;\n--i;\n++j;\n}\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint countSubstrings(string s) {\nint ans = 0;\nint n = s.size();\nfor (int k = 0; k < n * 2 - 1; ++k) {\nint i = k / 2, j = (k + 1) / 2;\nwhile (~i && j < n && s[i] == s[j]) {\n++ans;\n--i;\n++j;\n}\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0669", "level": "middle", "question_description": "Given the root of a binary search tree and the lowest and highest boundaries as low and high, trim the tree so that all its elements lies in [low, high]. Trimming the tree should not change the relative structure of the elements that will remain in the tree (i.e., any node&#39;s descendant should remain a descendant). It can be proven that there is a unique answer.\nReturn the root of the trimmed binary search tree. Note that the root may change depending on the given bounds.", "examples": [], "constraints": "\nConstraints:\nThe number of nodes in the tree is in the range [1, 104].\n0 <= Node.val <= 104\nThe value of each node in the tree is unique.\nroot is guaranteed to be a valid binary search tree.\n0 <= low <= high <= 104\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\n    public TreeNode trimBST(TreeNode root, int low, int high) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @param {number} low\n* @param {number} high\n* @return {TreeNode}\n*/\nvar trimBST = function (root, low, high) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    TreeNode* trimBST(TreeNode* root, int low, int high) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\npublic TreeNode trimBST(TreeNode root, int low, int high) {\nif (root == null) {\nreturn root;\n}\nif (root.val > high) {\nreturn trimBST(root.left, low, high);\n}\nif (root.val < low) {\nreturn trimBST(root.right, low, high);\n}\nroot.left = trimBST(root.left, low, high);\nroot.right = trimBST(root.right, low, high);\nreturn root;\n}\n}\n", "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\npublic TreeNode trimBST(TreeNode root, int low, int high) {\nwhile (root != null && (root.val < low || root.val > high)) {\nroot = root.val < low ? root.right : root.left;\n}\nif (root == null) {\nreturn null;\n}\nTreeNode node = root;\nwhile (node.left != null) {\nif (node.left.val < low) {\nnode.left = node.left.right;\n} else {\nnode = node.left;\n}\n}\nnode = root;\nwhile (node.right != null) {\nif (node.right.val > high) {\nnode.right = node.right.left;\n} else {\nnode = node.right;\n}\n}\nreturn root;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @param {number} low\n* @param {number} high\n* @return {TreeNode}\n*/\nvar trimBST = function (root, low, high) {\nfunction dfs(root) {\nif (!root) {\nreturn root;\n}\nif (root.val < low) {\nreturn dfs(root.right);\n}\nif (root.val > high) {\nreturn dfs(root.left);\n}\nroot.left = dfs(root.left);\nroot.right = dfs(root.right);\nreturn root;\n}\nreturn dfs(root);\n};\n", "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @param {number} low\n* @param {number} high\n* @return {TreeNode}\n*/\nvar trimBST = function (root, low, high) {\nwhile (root && (root.val < low || root.val > high)) {\nroot = root.val < low ? root.right : root.left;\n}\nif (!root) {\nreturn root;\n}\nlet node = root;\nwhile (node.left) {\nif (node.left.val < low) {\nnode.left = node.left.right;\n} else {\nnode = node.left;\n}\n}\nnode = root;\nwhile (node.right) {\nif (node.right.val > high) {\nnode.right = node.right.left;\n} else {\nnode = node.right;\n}\n}\nreturn root;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nTreeNode* trimBST(TreeNode* root, int low, int high) {\nif (!root) return root;\nif (root->val > high) return trimBST(root->left, low, high);\nif (root->val < low) return trimBST(root->right, low, high);\nroot->left = trimBST(root->left, low, high);\nroot->right = trimBST(root->right, low, high);\nreturn root;\n}\n};\n", "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nTreeNode* trimBST(TreeNode* root, int low, int high) {\nwhile (root && (root->val < low || root->val > high)) {\nroot = root->val < low ? root->right : root->left;\n}\nif (!root) {\nreturn root;\n}\nTreeNode* node = root;\nwhile (node->left) {\nif (node->left->val < low) {\nnode->left = node->left->right;\n} else {\nnode = node->left;\n}\n}\nnode = root;\nwhile (node->right) {\nif (node->right->val > high) {\nnode->right = node->right->left;\n} else {\nnode = node->right;\n}\n}\nreturn root;\n}\n};\n"]}, {"leetCodeID": "0684", "level": "middle", "question_description": "In this problem, a tree is an undirected graph that is connected and has no cycles.\nYou are given a graph that started as a tree with n nodes labeled from 1 to n, with one additional edge added. The added edge has two different vertices chosen from 1 to n, and was not an edge that already existed. The graph is represented as an array edges of length n where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the graph.\nReturn an edge that can be removed so that the resulting graph is a tree of n nodes. If there are multiple answers, return the answer that occurs last in the input.", "examples": [], "constraints": "\nConstraints:\nn == edges.length\n3 <= n <= 1000\nedges[i].length == 2\n1 <= ai < bi <= edges.length\nai != bi\nThere are no repeated edges.\nThe given graph is connected.\n", "java_context": "\nclass Solution {\n    private int[] p;\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[][]} edges\n* @return {number[]}\n*/\nvar findRedundantConnection = function (edges) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> p;\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\nprivate int[] p;\n\npublic int[] findRedundantConnection(int[][] edges) {\np = new int[1010];\nfor (int i = 0; i < p.length; ++i) {\np[i] = i;\n}\nfor (int[] e : edges) {\nint a = e[0], b = e[1];\nif (find(a) == find(b)) {\nreturn e;\n}\np[find(a)] = find(b);\n}\nreturn null;\n}\n\nprivate int find(int x) {\nif (p[x] != x) {\np[x] = find(p[x]);\n}\nreturn p[x];\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[][]} edges\n* @return {number[]}\n*/\nvar findRedundantConnection = function (edges) {\nlet p = Array.from({ length: 1010 }, (_, i) => i);\nfunction find(x) {\nif (p[x] != x) {\np[x] = find(p[x]);\n}\nreturn p[x];\n}\nfor (let [a, b] of edges) {\nif (find(a) == find(b)) {\nreturn [a, b];\n}\np[find(a)] = find(b);\n}\nreturn [];\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> p;\n\nvector<int> findRedundantConnection(vector<vector<int>>& edges) {\np.resize(1010);\nfor (int i = 0; i < p.size(); ++i) p[i] = i;\nfor (auto& e : edges) {\nint a = e[0], b = e[1];\nif (find(a) == find(b)) return e;\np[find(a)] = find(b);\n}\nreturn {};\n}\n\nint find(int x) {\nif (p[x] != x) p[x] = find(p[x]);\nreturn p[x];\n}\n};\n"]}, {"leetCodeID": "0687", "level": "middle", "question_description": "Given the root of a binary tree, return the length of the longest path, where each node in the path has the same value. This path may or may not pass through the root.\nThe length of the path between two nodes is represented by the number of edges between them.", "examples": [], "constraints": "\nConstraints:\nThe number of nodes in the tree is in the range [0, 104].\n-1000 <= Node.val <= 1000\nThe depth of the tree will not exceed 1000.\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\n    private int ans;\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {number}\n*/\nvar longestUnivaluePath = function (root) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    int ans;\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\nprivate int ans;\n\npublic int longestUnivaluePath(TreeNode root) {\nans = 0;\ndfs(root);\nreturn ans;\n}\n\nprivate int dfs(TreeNode root) {\nif (root == null) {\nreturn 0;\n}\nint left = dfs(root.left);\nint right = dfs(root.right);\nleft = root.left != null && root.left.val == root.val ? left + 1 : 0;\nright = root.right != null && root.right.val == root.val ? right + 1 : 0;\nans = Math.max(ans, left + right);\nreturn Math.max(left, right);\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {number}\n*/\nvar longestUnivaluePath = function (root) {\nlet ans = 0;\nlet dfs = function (root) {\nif (!root) {\nreturn 0;\n}\nlet left = dfs(root.left),\nright = dfs(root.right);\nleft = root.left?.val == root.val ? left + 1 : 0;\nright = root.right?.val == root.val ? right + 1 : 0;\nans = Math.max(ans, left + right);\nreturn Math.max(left, right);\n};\ndfs(root);\nreturn ans;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nint ans;\n\nint longestUnivaluePath(TreeNode* root) {\nans = 0;\ndfs(root);\nreturn ans;\n}\n\nint dfs(TreeNode* root) {\nif (!root) return 0;\nint left = dfs(root->left), right = dfs(root->right);\nleft = root->left && root->left->val == root->val ? left + 1 : 0;\nright = root->right && root->right->val == root->val ? right + 1 : 0;\nans = max(ans, left + right);\nreturn max(left, right);\n}\n};\n"]}, {"leetCodeID": "0712", "level": "middle", "question_description": "Given two strings s1 and s2, return the lowest ASCII sum of deleted characters to make two strings equal.", "examples": ["Example 1:\nInput: s1 = &quot;sea&quot;, s2 = &quot;eat&quot;\nOutput: 231\nExplanation: Deleting &quot;s&quot; from &quot;sea&quot; adds the ASCII value of &quot;s&quot; (115) to the sum.\nDeleting &quot;t&quot; from &quot;eat&quot; adds 116 to the sum.\nAt the end, both strings are equal, and 115 + 116 = 231 is the minimum sum possible to achieve this.\n", "Example 2:\nInput: s1 = &quot;delete&quot;, s2 = &quot;leet&quot;\nOutput: 403\nExplanation: Deleting &quot;dee&quot; from &quot;delete&quot; to turn the string into &quot;let&quot;,\nadds 100[d] + 101[e] + 101[e] to the sum.\nDeleting &quot;e&quot; from &quot;leet&quot; adds 101[e] to the sum.\nAt the end, both strings are equal to &quot;let&quot;, and the answer is 100+101+101+101 = 403.\nIf instead we turned both strings into &quot;lee&quot; or &quot;eet&quot;, we would get answers of 433 or 417, which are higher.\n"], "constraints": "\nConstraints:\n1 <= s1.length, s2.length <= 1000\ns1 and s2 consist of lowercase English letters.\n", "java_context": "\nclass Solution {\n    public int minimumDeleteSum(String s1, String s2) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} s1\n* @param {string} s2\n* @return {number}\n*/\nvar minimumDeleteSum = function (s1, s2) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int minimumDeleteSum(string s1, string s2) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int minimumDeleteSum(String s1, String s2) {\nint m = s1.length(), n = s2.length();\nint[][] f = new int[m + 1][n + 1];\nfor (int i = 1; i <= m; ++i) {\nf[i][0] = f[i - 1][0] + s1.charAt(i - 1);\n}\nfor (int j = 1; j <= n; ++j) {\nf[0][j] = f[0][j - 1] + s2.charAt(j - 1);\n}\nfor (int i = 1; i <= m; ++i) {\nfor (int j = 1; j <= n; ++j) {\nif (s1.charAt(i - 1) == s2.charAt(j - 1)) {\nf[i][j] = f[i - 1][j - 1];\n} else {\nf[i][j]\n= Math.min(f[i - 1][j] + s1.charAt(i - 1), f[i][j - 1] + s2.charAt(j - 1));\n}\n}\n}\nreturn f[m][n];\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} s1\n* @param {string} s2\n* @return {number}\n*/\nvar minimumDeleteSum = function (s1, s2) {\nconst m = s1.length;\nconst n = s2.length;\nconst f = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));\nfor (let i = 1; i <= m; ++i) {\nf[i][0] = f[i - 1][0] + s1[i - 1].charCodeAt(0);\n}\nfor (let j = 1; j <= n; ++j) {\nf[0][j] = f[0][j - 1] + s2[j - 1].charCodeAt(0);\n}\nfor (let i = 1; i <= m; ++i) {\nfor (let j = 1; j <= n; ++j) {\nif (s1[i - 1] === s2[j - 1]) {\nf[i][j] = f[i - 1][j - 1];\n} else {\nf[i][j] = Math.min(\nf[i - 1][j] + s1[i - 1].charCodeAt(0),\nf[i][j - 1] + s2[j - 1].charCodeAt(0),\n);\n}\n}\n}\nreturn f[m][n];\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint minimumDeleteSum(string s1, string s2) {\nint m = s1.size(), n = s2.size();\nint f[m + 1][n + 1];\nmemset(f, 0, sizeof f);\nfor (int i = 1; i <= m; ++i) {\nf[i][0] = f[i - 1][0] + s1[i - 1];\n}\nfor (int j = 1; j <= n; ++j) {\nf[0][j] = f[0][j - 1] + s2[j - 1];\n}\nfor (int i = 1; i <= m; ++i) {\nfor (int j = 1; j <= n; ++j) {\nif (s1[i - 1] == s2[j - 1]) {\nf[i][j] = f[i - 1][j - 1];\n} else {\nf[i][j] = min(f[i - 1][j] + s1[i - 1], f[i][j - 1] + s2[j - 1]);\n}\n}\n}\nreturn f[m][n];\n}\n};\n"]}, {"leetCodeID": "0713", "level": "middle", "question_description": "Given an array of integers nums and an integer k, return the number of contiguous subarrays where the product of all the elements in the subarray is strictly less than k.", "examples": ["Example 1:\nInput: nums = [10,5,2,6], k = 100\nOutput: 8\nExplanation: The 8 subarrays that have product less than 100 are:\n[10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6]\nNote that [10, 5, 2] is not included as the product of 100 is not strictly less than k.\n", "Example 2:\nInput: nums = [1,2,3], k = 0\nOutput: 0\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 3 * 104\n1 <= nums[i] <= 1000\n0 <= k <= 106\n", "java_context": "\nclass Solution {\n    public int numSubarrayProductLessThanK(int[] nums, int k) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @param {number} k\n* @return {number}\n*/\nvar numSubarrayProductLessThanK = function (nums, k) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int numSubarrayProductLessThanK(vector<int>& nums, int k) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int numSubarrayProductLessThanK(int[] nums, int k) {\nint ans = 0;\nfor (int i = 0, j = 0, s = 1; i < nums.length; ++i) {\ns *= nums[i];\nwhile (j <= i && s >= k) {\ns /= nums[j++];\n}\nans += i - j + 1;\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @param {number} k\n* @return {number}\n*/\nvar numSubarrayProductLessThanK = function (nums, k) {\nconst n = nums.length;\nlet ans = 0;\nlet s = 1;\nfor (let i = 0, j = 0; i < n; ++i) {\ns *= nums[i];\nwhile (j <= i && s >= k) {\ns = Math.floor(s / nums[j++]);\n}\nans += i - j + 1;\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint numSubarrayProductLessThanK(vector<int>& nums, int k) {\nint ans = 0;\nfor (int i = 0, j = 0, s = 1; i < nums.size(); ++i) {\ns *= nums[i];\nwhile (j <= i && s >= k) s /= nums[j++];\nans += i - j + 1;\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0718", "level": "middle", "question_description": "Given two integer arrays nums1 and nums2, return the maximum length of a subarray that appears in both arrays.", "examples": ["Example 1:\nInput: nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]\nOutput: 3\nExplanation: The repeated subarray with maximum length is [3,2,1].\n", "Example 2:\nInput: nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]\nOutput: 5\nExplanation: The repeated subarray with maximum length is [0,0,0,0,0].\n"], "constraints": "\nConstraints:\n1 <= nums1.length, nums2.length <= 1000\n0 <= nums1[i], nums2[i] <= 100\n", "java_context": "\nclass Solution {\n    public int findLength(int[] nums1, int[] nums2) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums1\n* @param {number[]} nums2\n* @return {number}\n*/\nvar findLength = function (nums1, nums2) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int findLength(vector<int>& nums1, vector<int>& nums2) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int findLength(int[] nums1, int[] nums2) {\nint m = nums1.length;\nint n = nums2.length;\nint[][] f = new int[m + 1][n + 1];\nint ans = 0;\nfor (int i = 1; i <= m; ++i) {\nfor (int j = 1; j <= n; ++j) {\nif (nums1[i - 1] == nums2[j - 1]) {\nf[i][j] = f[i - 1][j - 1] + 1;\nans = Math.max(ans, f[i][j]);\n}\n}\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums1\n* @param {number[]} nums2\n* @return {number}\n*/\nvar findLength = function (nums1, nums2) {\nconst m = nums1.length;\nconst n = nums2.length;\nconst f = Array.from({ length: m + 1 }, _ => new Array(n + 1).fill(0));\nlet ans = 0;\nfor (let i = 1; i <= m; ++i) {\nfor (let j = 1; j <= n; ++j) {\nif (nums1[i - 1] == nums2[j - 1]) {\nf[i][j] = f[i - 1][j - 1] + 1;\nans = Math.max(ans, f[i][j]);\n}\n}\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint findLength(vector<int>& nums1, vector<int>& nums2) {\nint m = nums1.size(), n = nums2.size();\nvector<vector<int>> f(m + 1, vector<int>(n + 1));\nint ans = 0;\nfor (int i = 1; i <= m; ++i) {\nfor (int j = 1; j <= n; ++j) {\nif (nums1[i - 1] == nums2[j - 1]) {\nf[i][j] = f[i - 1][j - 1] + 1;\nans = max(ans, f[i][j]);\n}\n}\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0739", "level": "middle", "question_description": "Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.", "examples": ["Example 1:Input: temperatures = [73,74,75,71,69,72,76,73]\nOutput: [1,1,4,2,1,1,0,0]\n", "Example 2:Input: temperatures = [30,40,50,60]\nOutput: [1,1,1,0]\n", "Example 3:Input: temperatures = [30,60,90]\nOutput: [1,1,0]\n"], "constraints": "\nConstraints:\n1 <=&nbsp;temperatures.length <= 105\n30 <=&nbsp;temperatures[i] <= 100\n", "java_context": "\nclass Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} temperatures\n* @return {number[]}\n*/\nvar dailyTemperatures = function (temperatures) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> dailyTemperatures(vector<int>& temperatures) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int[] dailyTemperatures(int[] temperatures) {\nint n = temperatures.length;\nint[] ans = new int[n];\nDeque<Integer> stk = new ArrayDeque<>();\nfor (int i = 0; i < n; ++i) {\nwhile (!stk.isEmpty() && temperatures[stk.peek()] < temperatures[i]) {\nint j = stk.pop();\nans[j] = i - j;\n}\nstk.push(i);\n}\nreturn ans;\n}\n}\n", "\nclass Solution {\npublic int[] dailyTemperatures(int[] temperatures) {\nint n = temperatures.length;\nDeque<Integer> stk = new ArrayDeque<>();\nint[] ans = new int[n];\nfor (int i = n - 1; i >= 0; --i) {\nwhile (!stk.isEmpty() && temperatures[stk.peek()] <= temperatures[i]) {\nstk.pop();\n}\nif (!stk.isEmpty()) {\nans[i] = stk.peek() - i;\n}\nstk.push(i);\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} temperatures\n* @return {number[]}\n*/\nvar dailyTemperatures = function (temperatures) {\nconst n = temperatures.length;\nconst ans = new Array(n).fill(0);\nconst stk = [];\nfor (let i = n - 1; i >= 0; --i) {\nwhile (stk.length && temperatures[stk[stk.length - 1]] <= temperatures[i]) {\nstk.pop();\n}\nif (stk.length) {\nans[i] = stk[stk.length - 1] - i;\n}\nstk.push(i);\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> dailyTemperatures(vector<int>& temperatures) {\nint n = temperatures.size();\nvector<int> ans(n);\nstack<int> stk;\nfor (int i = 0; i < n; ++i) {\nwhile (!stk.empty() && temperatures[stk.top()] < temperatures[i]) {\nans[stk.top()] = i - stk.top();\nstk.pop();\n}\nstk.push(i);\n}\nreturn ans;\n}\n};\n", "\nclass Solution {\npublic:\nvector<int> dailyTemperatures(vector<int>& temperatures) {\nint n = temperatures.size();\nvector<int> ans(n);\nstack<int> stk;\nfor (int i = n - 1; ~i; --i) {\nwhile (!stk.empty() && temperatures[stk.top()] <= temperatures[i]) stk.pop();\nif (!stk.empty()) ans[i] = stk.top() - i;\nstk.push(i);\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0754", "level": "middle", "question_description": "You are standing at position 0 on an infinite number line. There is a destination at position target.\nYou can make some number of moves numMoves so that:\nOn each move, you can either go left or right.\nDuring the ith move (starting from i == 1 to i == numMoves), you take i steps in the chosen direction.\nGiven the integer target, return the minimum number of moves required (i.e., the minimum numMoves) to reach the destination.", "examples": ["Example 1:\nInput: target = 2\nOutput: 3\nExplanation:\nOn the 1st move, we step from 0 to 1 (1 step).\nOn the 2nd move, we step from 1 to -1 (2 steps).\nOn the 3rd move, we step from -1 to 2 (3 steps).\n", "Example 2:\nInput: target = 3\nOutput: 2\nExplanation:\nOn the 1st move, we step from 0 to 1 (1 step).\nOn the 2nd move, we step from 1 to 3 (2 steps).\n"], "constraints": "\nConstraints:\n-109 <= target <= 109\ntarget != 0\n", "java_context": "\nclass Solution {\n    public int reachNumber(int target) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number} target\n* @return {number}\n*/\nvar reachNumber = function (target) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int reachNumber(int target) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int reachNumber(int target) {\ntarget = Math.abs(target);\nint s = 0, k = 0;\nwhile (true) {\nif (s >= target && (s - target) % 2 == 0) {\nreturn k;\n}\n++k;\ns += k;\n}\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number} target\n* @return {number}\n*/\nvar reachNumber = function (target) {\ntarget = Math.abs(target);\nlet [s, k] = [0, 0];\nwhile (1) {\nif (s >= target && (s - target) % 2 == 0) {\nreturn k;\n}\n++k;\ns += k;\n}\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint reachNumber(int target) {\ntarget = abs(target);\nint s = 0, k = 0;\nwhile (1) {\nif (s >= target && (s - target) % 2 == 0) return k;\n++k;\ns += k;\n}\n}\n};\n"]}, {"leetCodeID": "0763", "level": "middle", "question_description": "You are given a string s. We want to partition the string into as many parts as possible so that each letter appears in at most one part.\nNote that the partition is done so that after concatenating all the parts in order, the resultant string should be s.\nReturn a list of integers representing the size of these parts.", "examples": ["Example 1:\nInput: s = &quot;ababcbacadefegdehijhklij&quot;\nOutput: [9,7,8]\nExplanation:\nThe partition is &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;.\nThis is a partition so that each letter appears in at most one part.\nA partition like &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; is incorrect, because it splits s into less parts.\n", "Example 2:\nInput: s = &quot;eccbbbbdec&quot;\nOutput: [10]\n"], "constraints": "\nConstraints:\n1 <= s.length <= 500\ns consists of lowercase English letters.\n", "java_context": "\nclass Solution {\n    public List<Integer> partitionLabels(String s) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} s\n* @return {number[]}\n*/\nvar partitionLabels = function (s) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> partitionLabels(string s) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic List<Integer> partitionLabels(String s) {\nint[] last = new int[26];\nint n = s.length();\nfor (int i = 0; i < n; ++i) {\nlast[s.charAt(i) - 'a'] = i;\n}\nList<Integer> ans = new ArrayList<>();\nint mx = 0, j = 0;\nfor (int i = 0; i < n; ++i) {\nmx = Math.max(mx, last[s.charAt(i) - 'a']);\nif (mx == i) {\nans.add(i - j + 1);\nj = i + 1;\n}\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} s\n* @return {number[]}\n*/\nvar partitionLabels = function (s) {\nconst last = new Array(26).fill(0);\nconst idx = c => c.charCodeAt() - 'a'.charCodeAt();\nconst n = s.length;\nfor (let i = 0; i < n; ++i) {\nlast[idx(s[i])] = i;\n}\nconst ans = [];\nfor (let i = 0, j = 0, mx = 0; i < n; ++i) {\nmx = Math.max(mx, last[idx(s[i])]);\nif (mx === i) {\nans.push(i - j + 1);\nj = i + 1;\n}\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> partitionLabels(string s) {\nint last[26] = {0};\nint n = s.size();\nfor (int i = 0; i < n; ++i) {\nlast[s[i] - 'a'] = i;\n}\nvector<int> ans;\nint mx = 0, j = 0;\nfor (int i = 0; i < n; ++i) {\nmx = max(mx, last[s[i] - 'a']);\nif (mx == i) {\nans.push_back(i - j + 1);\nj = i + 1;\n}\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0776", "level": "middle", "question_description": "Given the root of a binary search tree (BST) and an integer target, split the tree into two subtrees where one subtree has nodes that are all smaller or equal to the target value, while the other subtree has all nodes that are greater than the target value. It Is not necessarily the case that the tree contains a node with the value target.\nAdditionally, most of the structure of the original tree should remain. Formally, for any child c with parent p in the original tree, if they are both in the same subtree after the split, then node c should still have the parent p.\nReturn an array of the two roots of the two subtrees.", "examples": ["Example 1:\n\n\nInput: root = [4,2,6,1,3,5,7], target = 2\nOutput: [[2,1],[4,3,6,null,null,5,7]]\n\n\nExample 2:\nInput: root = [1], target = 1\nOutput: [[1],[]]\n"], "constraints": "\nConstraints:\nThe number of nodes in the tree is in the range [1, 50].\n0 <= Node.val, target <= 1000\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\n    private int t;\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @param {number} target\n* @return {TreeNode[]}\n*/\nvar splitBST = function (root, target) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    int t;\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\nprivate int t;\n\npublic TreeNode[] splitBST(TreeNode root, int target) {\nt = target;\nreturn dfs(root);\n}\n\nprivate TreeNode[] dfs(TreeNode root) {\nif (root == null) {\nreturn new TreeNode[] {null, null};\n}\nif (root.val <= t) {\nTreeNode[] ans = dfs(root.right);\nroot.right = ans[0];\nans[0] = root;\nreturn ans;\n} else {\nTreeNode[] ans = dfs(root.left);\nroot.left = ans[1];\nans[1] = root;\nreturn ans;\n}\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @param {number} target\n* @return {TreeNode[]}\n*/\nvar splitBST = function (root, target) {\nlet ans = [null, null];\nif (!root) {\nreturn ans;\n}\nif (root.val <= target) {\nans = splitBST(root.right, target);\nroot.right = ans[0];\nans[0] = root;\n} else {\nans = splitBST(root.left, target);\nroot.left = ans[1];\nans[1] = root;\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nint t;\n\nvector<TreeNode*> splitBST(TreeNode* root, int target) {\nt = target;\nreturn dfs(root);\n}\n\nvector<TreeNode*> dfs(TreeNode* root) {\nif (!root) return {nullptr, nullptr};\nif (root->val <= t) {\nauto ans = dfs(root->right);\nroot->right = ans[0];\nans[0] = root;\nreturn ans;\n} else {\nauto ans = dfs(root->left);\nroot->left = ans[1];\nans[1] = root;\nreturn ans;\n}\n}\n};\n"]}, {"leetCodeID": "0794", "level": "middle", "question_description": "Given a Tic-Tac-Toe board as a string array board, return true if and only if it is possible to reach this board position during the course of a valid tic-tac-toe game.\nThe board is a 3 x 3 array that consists of characters &#39; &#39;, &#39;X&#39;, and &#39;O&#39;. The &#39; &#39; character represents an empty square.\nHere are the rules of Tic-Tac-Toe:\nPlayers take turns placing characters into empty squares &#39; &#39;.\nThe first player always places &#39;X&#39; characters, while the second player always places &#39;O&#39; characters.\n&#39;X&#39; and &#39;O&#39; characters are always placed into empty squares, never filled ones.\nThe game ends when there are three of the same (non-empty) character filling any row, column, or diagonal.\nThe game also ends if all squares are non-empty.\nNo more moves can be played if the game is over.", "examples": [], "constraints": "\nConstraints:\nboard.length == 3\nboard[i].length == 3\nboard[i][j] is either &#39;X&#39;, &#39;O&#39;, or &#39; &#39;.\n", "java_context": "\nclass Solution {\n    private String[] board;\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string[]} board\n* @return {boolean}\n*/\nvar validTicTacToe = function (board) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    bool validTicTacToe(vector<string>& board) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\nprivate String[] board;\n\npublic boolean validTicTacToe(String[] board) {\nthis.board = board;\nint x = count('X'), o = count('O');\nif (x != o && x - 1 != o) {\nreturn false;\n}\nif (win('X') && x - 1 != o) {\nreturn false;\n}\nreturn !(win('O') && x != o);\n}\n\nprivate boolean win(char x) {\nfor (int i = 0; i < 3; ++i) {\nif (board[i].charAt(0) == x && board[i].charAt(1) == x && board[i].charAt(2) == x) {\nreturn true;\n}\nif (board[0].charAt(i) == x && board[1].charAt(i) == x && board[2].charAt(i) == x) {\nreturn true;\n}\n}\nif (board[0].charAt(0) == x && board[1].charAt(1) == x && board[2].charAt(2) == x) {\nreturn true;\n}\nreturn board[0].charAt(2) == x && board[1].charAt(1) == x && board[2].charAt(0) == x;\n}\n\nprivate int count(char x) {\nint cnt = 0;\nfor (var row : board) {\nfor (var c : row.toCharArray()) {\nif (c == x) {\n++cnt;\n}\n}\n}\nreturn cnt;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string[]} board\n* @return {boolean}\n*/\nvar validTicTacToe = function (board) {\nfunction count(x) {\nlet cnt = 0;\nfor (const row of board) {\nfor (const c of row) {\ncnt += c == x;\n}\n}\nreturn cnt;\n}\nfunction win(x) {\nfor (let i = 0; i < 3; ++i) {\nif (board[i][0] == x && board[i][1] == x && board[i][2] == x) {\nreturn true;\n}\nif (board[0][i] == x && board[1][i] == x && board[2][i] == x) {\nreturn true;\n}\n}\nif (board[0][0] == x && board[1][1] == x && board[2][2] == x) {\nreturn true;\n}\nreturn board[0][2] == x && board[1][1] == x && board[2][0] == x;\n}\nconst [x, o] = [count('X'), count('O')];\nif (x != o && x - 1 != o) {\nreturn false;\n}\nif (win('X') && x - 1 != o) {\nreturn false;\n}\nreturn !(win('O') && x != o);\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nbool validTicTacToe(vector<string>& board) {\nauto count = [&](char x) {\nint ans = 0;\nfor (auto& row : board)\nfor (auto& c : row) ans += c == x;\nreturn ans;\n};\nauto win = [&](char x) {\nfor (int i = 0; i < 3; ++i) {\nif (board[i][0] == x && board[i][1] == x && board[i][2] == x) return true;\nif (board[0][i] == x && board[1][i] == x && board[2][i] == x) return true;\n}\nif (board[0][0] == x && board[1][1] == x && board[2][2] == x) return true;\nreturn board[0][2] == x && board[1][1] == x && board[2][0] == x;\n};\nint x = count('X'), o = count('O');\nif (x != o && x - 1 != o) return false;\nif (win('X') && x - 1 != o) return false;\nreturn !(win('O') && x != o);\n}\n};\n"]}, {"leetCodeID": "0797", "level": "middle", "question_description": "Given a directed acyclic graph (DAG) of n nodes labeled from 0 to n - 1, find all possible paths from node 0 to node n - 1 and return them in any order.\nThe graph is given as follows: graph[i] is a list of all nodes you can visit from node i (i.e., there is a directed edge from node i to node graph[i][j]).", "examples": [], "constraints": "\nConstraints:\nn == graph.length\n2 <= n <= 15\n0 <= graph[i][j] < n\ngraph[i][j] != i (i.e., there will be no self-loops).\nAll the elements of graph[i] are unique.\nThe input graph is guaranteed to be a DAG.\n", "java_context": "\nclass Solution {\n    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[][]} graph\n* @return {number[][]}\n*/\nvar allPathsSourceTarget = function (graph) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<vector<int>> graph;\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic List<List<Integer>> allPathsSourceTarget(int[][] graph) {\nint n = graph.length;\nQueue<List<Integer>> queue = new ArrayDeque<>();\nqueue.offer(Arrays.asList(0));\nList<List<Integer>> ans = new ArrayList<>();\nwhile (!queue.isEmpty()) {\nList<Integer> path = queue.poll();\nint u = path.get(path.size() - 1);\nif (u == n - 1) {\nans.add(path);\ncontinue;\n}\nfor (int v : graph[u]) {\nList<Integer> next = new ArrayList<>(path);\nnext.add(v);\nqueue.offer(next);\n}\n}\nreturn ans;\n}\n}\n", "\nclass Solution {\nprivate List<List<Integer>> ans;\nprivate int[][] graph;\n\npublic List<List<Integer>> allPathsSourceTarget(int[][] graph) {\nans = new ArrayList<>();\nthis.graph = graph;\nList<Integer> t = new ArrayList<>();\nt.add(0);\ndfs(t);\nreturn ans;\n}\n\nprivate void dfs(List<Integer> t) {\nint cur = t.get(t.size() - 1);\nif (cur == graph.length - 1) {\nans.add(new ArrayList<>(t));\nreturn;\n}\nfor (int v : graph[cur]) {\nt.add(v);\ndfs(t);\nt.remove(t.size() - 1);\n}\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[][]} graph\n* @return {number[][]}\n*/\nvar allPathsSourceTarget = function (graph) {\nconst ans = [];\nconst t = [0];\n\nconst dfs = t => {\nconst cur = t[t.length - 1];\nif (cur == graph.length - 1) {\nans.push([...t]);\nreturn;\n}\nfor (const v of graph[cur]) {\nt.push(v);\ndfs(t);\nt.pop();\n}\n};\n\ndfs(t);\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<vector<int>> graph;\nvector<vector<int>> ans;\n\nvector<vector<int>> allPathsSourceTarget(vector<vector<int>>& graph) {\nthis->graph = graph;\nvector<int> path;\npath.push_back(0);\ndfs(0, path);\nreturn ans;\n}\n\nvoid dfs(int i, vector<int> path) {\nif (i == graph.size() - 1) {\nans.push_back(path);\nreturn;\n}\nfor (int j : graph[i]) {\npath.push_back(j);\ndfs(j, path);\npath.pop_back();\n}\n}\n};\n"]}, {"leetCodeID": "0802", "level": "middle", "question_description": "There is a directed graph of n nodes with each node labeled from 0 to n - 1. The graph is represented by a 0-indexed 2D integer array graph where graph[i] is an integer array of nodes adjacent to node i, meaning there is an edge from node i to each node in graph[i].\nA node is a terminal node if there are no outgoing edges. A node is a safe node if every possible path starting from that node leads to a terminal node (or another safe node).\nReturn an array containing all the safe nodes of the graph. The answer should be sorted in ascending order.", "examples": ["Example 1:\n\n\nInput: graph = [[1,2],[2,3],[5],[0],[5],[],[]]\nOutput: [2,4,5,6]\nExplanation: The given graph is shown above.\nNodes 5 and 6 are terminal nodes as there are no outgoing edges from either of them.\nEvery path starting at nodes 2, 4, 5, and 6 all lead to either node 5 or 6.\n\nExample 2:\nInput: graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]\nOutput: [4]\nExplanation:\nOnly node 4 is a terminal node, and every path starting at node 4 leads to node 4.\n"], "constraints": "\nConstraints:\nn == graph.length\n1 <= n <= 104\n0 <= graph[i].length <= n\n0 <= graph[i][j] <= n - 1\ngraph[i] is sorted in a strictly increasing order.\nThe graph may contain self-loops.\nThe number of edges in the graph will be in the range [1, 4 * 104].\n", "java_context": "\nclass Solution {\n    public List<Integer> eventualSafeNodes(int[][] graph) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[][]} graph\n* @return {number[]}\n*/\nvar eventualSafeNodes = function (graph) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> eventualSafeNodes(vector<vector<int>>& graph) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic List<Integer> eventualSafeNodes(int[][] graph) {\nint n = graph.length;\nint[] indeg = new int[n];\nList<Integer>[] rg = new List[n];\nArrays.setAll(rg, k -> new ArrayList<>());\nDeque<Integer> q = new ArrayDeque<>();\nfor (int i = 0; i < n; ++i) {\nfor (int j : graph[i]) {\nrg[j].add(i);\n}\nindeg[i] = graph[i].length;\nif (indeg[i] == 0) {\nq.offer(i);\n}\n}\nwhile (!q.isEmpty()) {\nint i = q.pollFirst();\nfor (int j : rg[i]) {\nif (--indeg[j] == 0) {\nq.offer(j);\n}\n}\n}\nList<Integer> ans = new ArrayList<>();\nfor (int i = 0; i < n; ++i) {\nif (indeg[i] == 0) {\nans.add(i);\n}\n}\nreturn ans;\n}\n}\n", "\nclass Solution {\nprivate int[] color;\nprivate int[][] g;\n\npublic List<Integer> eventualSafeNodes(int[][] graph) {\nint n = graph.length;\ncolor = new int[n];\ng = graph;\nList<Integer> ans = new ArrayList<>();\nfor (int i = 0; i < n; ++i) {\nif (dfs(i)) {\nans.add(i);\n}\n}\nreturn ans;\n}\n\nprivate boolean dfs(int i) {\nif (color[i] > 0) {\nreturn color[i] == 2;\n}\ncolor[i] = 1;\nfor (int j : g[i]) {\nif (!dfs(j)) {\nreturn false;\n}\n}\ncolor[i] = 2;\nreturn true;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[][]} graph\n* @return {number[]}\n*/\nvar eventualSafeNodes = function (graph) {\nconst n = graph.length;\nconst rg = new Array(n).fill(0).map(() => new Array());\nconst indeg = new Array(n).fill(0);\nconst q = [];\nfor (let i = 0; i < n; ++i) {\nfor (let j of graph[i]) {\nrg[j].push(i);\n}\nindeg[i] = graph[i].length;\nif (indeg[i] == 0) {\nq.push(i);\n}\n}\nwhile (q.length) {\nconst i = q.shift();\nfor (let j of rg[i]) {\nif (--indeg[j] == 0) {\nq.push(j);\n}\n}\n}\nlet ans = [];\nfor (let i = 0; i < n; ++i) {\nif (indeg[i] == 0) {\nans.push(i);\n}\n}\nreturn ans;\n};\n", "\n/**\n* @param {number[][]} graph\n* @return {number[]}\n*/\nvar eventualSafeNodes = function (graph) {\nconst n = graph.length;\nconst color = new Array(n).fill(0);\nfunction dfs(i) {\nif (color[i]) {\nreturn color[i] == 2;\n}\ncolor[i] = 1;\nfor (const j of graph[i]) {\nif (!dfs(j)) {\nreturn false;\n}\n}\ncolor[i] = 2;\nreturn true;\n}\nlet ans = [];\nfor (let i = 0; i < n; ++i) {\nif (dfs(i)) {\nans.push(i);\n}\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> eventualSafeNodes(vector<vector<int>>& graph) {\nint n = graph.size();\nvector<int> indeg(n);\nvector<vector<int>> rg(n);\nqueue<int> q;\nfor (int i = 0; i < n; ++i) {\nfor (int j : graph[i]) rg[j].push_back(i);\nindeg[i] = graph[i].size();\nif (indeg[i] == 0) q.push(i);\n}\nwhile (!q.empty()) {\nint i = q.front();\nq.pop();\nfor (int j : rg[i])\nif (--indeg[j] == 0) q.push(j);\n}\nvector<int> ans;\nfor (int i = 0; i < n; ++i)\nif (indeg[i] == 0) ans.push_back(i);\nreturn ans;\n}\n};\n", "\nclass Solution {\npublic:\nvector<int> color;\n\nvector<int> eventualSafeNodes(vector<vector<int>>& graph) {\nint n = graph.size();\ncolor.assign(n, 0);\nvector<int> ans;\nfor (int i = 0; i < n; ++i)\nif (dfs(i, graph)) ans.push_back(i);\nreturn ans;\n}\n\nbool dfs(int i, vector<vector<int>>& g) {\nif (color[i]) return color[i] == 2;\ncolor[i] = 1;\nfor (int j : g[i])\nif (!dfs(j, g)) return false;\ncolor[i] = 2;\nreturn true;\n}\n};\n"]}, {"leetCodeID": "0814", "level": "middle", "question_description": "Given the root of a binary tree, return the same tree where every subtree (of the given tree) not containing a 1 has been removed.\nA subtree of a node node is node plus every node that is a descendant of node.", "examples": [], "constraints": "\nConstraints:\nThe number of nodes in the tree is in the range [1, 200].\nNode.val is either 0 or 1.\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\n    public TreeNode pruneTree(TreeNode root) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {TreeNode}\n*/\nvar pruneTree = function (root) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    TreeNode* pruneTree(TreeNode* root) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\npublic TreeNode pruneTree(TreeNode root) {\nif (root == null) {\nreturn null;\n}\nroot.left = pruneTree(root.left);\nroot.right = pruneTree(root.right);\nif (root.val == 0 && root.left == null && root.right == null) {\nreturn null;\n}\nreturn root;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {TreeNode}\n*/\nvar pruneTree = function (root) {\nif (!root) return null;\nroot.left = pruneTree(root.left);\nroot.right = pruneTree(root.right);\nif (root.val == 0 && !root.left && !root.right) {\nreturn null;\n}\nreturn root;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nTreeNode* pruneTree(TreeNode* root) {\nif (!root) return nullptr;\nroot->left = pruneTree(root->left);\nroot->right = pruneTree(root->right);\nif (!root->val && !root->left && !root->right) return nullptr;\nreturn root;\n}\n};\n"]}, {"leetCodeID": "0817", "level": "middle", "question_description": "You are given the head of a linked list containing unique integer values and an integer array nums that is a subset of the linked list values.\nReturn the number of connected components in nums where two values are connected if they appear consecutively in the linked list.", "examples": [], "constraints": "\nConstraints:\nThe number of nodes in the linked list is n.\n1 <= n <= 104\n0 <= Node.val < n\nAll the values Node.val are unique.\n1 <= nums.length <= n\n0 <= nums[i] < n\nAll the values of nums are unique.\n", "java_context": "\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode() {}\n*     ListNode(int val) { this.val = val; }\n*     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n* }\n*/\nclass Solution {\n    public int numComponents(ListNode head, int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for singly-linked list.\n* function ListNode(val, next) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.next = (next===undefined ? null : next)\n* }\n*/\n/**\n* @param {ListNode} head\n* @param {number[]} nums\n* @return {number}\n*/\nvar numComponents = function (head, nums) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\nclass Solution {\npublic:\n    int numComponents(ListNode* head, vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode() {}\n*     ListNode(int val) { this.val = val; }\n*     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n* }\n*/\nclass Solution {\npublic int numComponents(ListNode head, int[] nums) {\nint ans = 0;\nSet<Integer> s = new HashSet<>();\nfor (int v : nums) {\ns.add(v);\n}\nwhile (head != null) {\nwhile (head != null && !s.contains(head.val)) {\nhead = head.next;\n}\nans += head != null ? 1 : 0;\nwhile (head != null && s.contains(head.val)) {\nhead = head.next;\n}\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for singly-linked list.\n* function ListNode(val, next) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.next = (next===undefined ? null : next)\n* }\n*/\n/**\n* @param {ListNode} head\n* @param {number[]} nums\n* @return {number}\n*/\nvar numComponents = function (head, nums) {\nconst s = new Set(nums);\nlet ans = 0;\nwhile (head) {\nwhile (head && !s.has(head.val)) {\nhead = head.next;\n}\nans += head != null;\nwhile (head && s.has(head.val)) {\nhead = head.next;\n}\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\nclass Solution {\npublic:\nint numComponents(ListNode* head, vector<int>& nums) {\nunordered_set<int> s(nums.begin(), nums.end());\nint ans = 0;\nwhile (head) {\nwhile (head && !s.count(head->val)) head = head->next;\nans += head != nullptr;\nwhile (head && s.count(head->val)) head = head->next;\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0852", "level": "middle", "question_description": "An array arr is a mountain if the following properties hold:\narr.length &gt;= 3\nThere exists some i with 0 &lt; i &lt; arr.length - 1 such that:\narr[0] &lt; arr[1] &lt; ... &lt; arr[i - 1] &lt; arr[i] \narr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1]\nGiven a mountain array arr, return the index i such that arr[0] &lt; arr[1] &lt; ... &lt; arr[i - 1] &lt; arr[i] &gt; arr[i + 1] &gt; ... &gt; arr[arr.length - 1].\nYou must solve it in O(log(arr.length)) time complexity.", "examples": ["Example 1:\nInput: arr = [0,1,0]\nOutput: 1\n", "Example 2:\nInput: arr = [0,2,1,0]\nOutput: 1\n", "Example 3:\nInput: arr = [0,10,5,2]\nOutput: 1\n"], "constraints": "\nConstraints:\n3 <= arr.length <= 105\n0 <= arr[i] <= 106\narr is guaranteed to be a mountain array.\n", "java_context": "\nclass Solution {\n    public int peakIndexInMountainArray(int[] arr) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} arr\n* @return {number}\n*/\nvar peakIndexInMountainArray = function (arr) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int peakIndexInMountainArray(vector<int>& arr) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int peakIndexInMountainArray(int[] arr) {\nint left = 1, right = arr.length - 2;\nwhile (left < right) {\nint mid = (left + right) >> 1;\nif (arr[mid] > arr[mid + 1]) {\nright = mid;\n} else {\nleft = mid + 1;\n}\n}\nreturn left;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} arr\n* @return {number}\n*/\nvar peakIndexInMountainArray = function (arr) {\nlet left = 1;\nlet right = arr.length - 2;\nwhile (left < right) {\nconst mid = (left + right) >> 1;\nif (arr[mid] < arr[mid + 1]) {\nleft = mid + 1;\n} else {\nright = mid;\n}\n}\nreturn left;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint peakIndexInMountainArray(vector<int>& arr) {\nint left = 1, right = arr.size() - 2;\nwhile (left < right) {\nint mid = (left + right) >> 1;\nif (arr[mid] > arr[mid + 1])\nright = mid;\nelse\nleft = mid + 1;\n}\nreturn left;\n}\n};\n"]}, {"leetCodeID": "0873", "level": "middle", "question_description": "A sequence x1, x2, ..., xn is Fibonacci-like if:\nn &gt;= 3\nxi + xi+1 == xi+2 for all i + 2 &lt;= n\nGiven a strictly increasing array arr of positive integers forming a sequence, return the length of the longest Fibonacci-like subsequence of arr. If one does not exist, return 0.\nA subsequence is derived from another sequence arr by deleting any number of elements (including none) from arr, without changing the order of the remaining elements. For example, [3, 5, 8] is a subsequence of [3, 4, 5, 6, 7, 8].", "examples": ["Example 1:\nInput: arr = [1,2,3,4,5,6,7,8]\nOutput: 5\nExplanation: The longest subsequence that is fibonacci-like: [1,2,3,5,8].", "Example 2:\nInput: arr = [1,3,7,11,12,14,18]\nOutput: 3\nExplanation: The longest subsequence that is fibonacci-like: [1,11,12], [3,11,14] or [7,11,18]."], "constraints": "\nConstraints:\n3 <= arr.length <= 1000\n1 <= arr[i] < arr[i + 1] <= 109\n", "java_context": "\nclass Solution {\n    public int lenLongestFibSubseq(int[] arr) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} arr\n* @return {number}\n*/\nvar lenLongestFibSubseq = function (arr) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int lenLongestFibSubseq(vector<int>& arr) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int lenLongestFibSubseq(int[] arr) {\nint n = arr.length;\nMap<Integer, Integer> mp = new HashMap<>();\nfor (int i = 0; i < n; ++i) {\nmp.put(arr[i], i);\n}\nint[][] dp = new int[n][n];\nfor (int i = 0; i < n; ++i) {\nfor (int j = 0; j < i; ++j) {\ndp[j][i] = 2;\n}\n}\nint ans = 0;\nfor (int i = 0; i < n; ++i) {\nfor (int j = 0; j < i; ++j) {\nint d = arr[i] - arr[j];\nif (mp.containsKey(d)) {\nint k = mp.get(d);\nif (k < j) {\ndp[j][i] = Math.max(dp[j][i], dp[k][j] + 1);\nans = Math.max(ans, dp[j][i]);\n}\n}\n}\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} arr\n* @return {number}\n*/\nvar lenLongestFibSubseq = function (arr) {\nconst mp = new Map();\nconst n = arr.length;\nconst dp = new Array(n).fill(0).map(() => new Array(n).fill(0));\nfor (let i = 0; i < n; ++i) {\nmp.set(arr[i], i);\nfor (let j = 0; j < i; ++j) {\ndp[j][i] = 2;\n}\n}\nlet ans = 0;\nfor (let i = 0; i < n; ++i) {\nfor (let j = 0; j < i; ++j) {\nconst d = arr[i] - arr[j];\nif (mp.has(d)) {\nconst k = mp.get(d);\nif (k < j) {\ndp[j][i] = Math.max(dp[j][i], dp[k][j] + 1);\nans = Math.max(ans, dp[j][i]);\n}\n}\n}\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint lenLongestFibSubseq(vector<int>& arr) {\nunordered_map<int, int> mp;\nint n = arr.size();\nfor (int i = 0; i < n; ++i) mp[arr[i]] = i;\nvector<vector<int>> dp(n, vector<int>(n));\nfor (int i = 0; i < n; ++i)\nfor (int j = 0; j < i; ++j)\ndp[j][i] = 2;\nint ans = 0;\nfor (int i = 0; i < n; ++i) {\nfor (int j = 0; j < i; ++j) {\nint d = arr[i] - arr[j];\nif (mp.count(d)) {\nint k = mp[d];\nif (k < j) {\ndp[j][i] = max(dp[j][i], dp[k][j] + 1);\nans = max(ans, dp[j][i]);\n}\n}\n}\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0912", "level": "middle", "question_description": "Given an array of integers nums, sort the array in ascending order and return it.\nYou must solve the problem without using any built-in functions in O(nlog(n)) time complexity and with the smallest space complexity possible.", "examples": ["Example 1:\nInput: nums = [5,2,3,1]\nOutput: [1,2,3,5]\nExplanation: After sorting the array, the positions of some numbers are not changed (for example, 2 and 3), while the positions of other numbers are changed (for example, 1 and 5).\n", "Example 2:\nInput: nums = [5,1,1,2,0,0]\nOutput: [0,0,1,1,2,5]\nExplanation: Note that the values of nums are not necessairly unique.\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 5 * 104\n-5 * 104 <= nums[i] <= 5 * 104\n", "java_context": "\nclass Solution {\n    private int[] nums;\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number[]}\n*/\nvar sortArray = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> sortArray(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\nprivate int[] nums;\n\npublic int[] sortArray(int[] nums) {\nthis.nums = nums;\nquikcSort(0, nums.length - 1);\nreturn nums;\n}\n\nprivate void quikcSort(int l, int r) {\nif (l >= r) {\nreturn;\n}\nint x = nums[(l + r) >> 1];\nint i = l - 1, j = r + 1;\nwhile (i < j) {\nwhile (nums[++i] < x) {\n}\nwhile (nums[--j] > x) {\n}\nif (i < j) {\nint t = nums[i];\nnums[i] = nums[j];\nnums[j] = t;\n}\n}\nquikcSort(l, j);\nquikcSort(j + 1, r);\n}\n}\n", "\nclass Solution {\nprivate int[] nums;\n\npublic int[] sortArray(int[] nums) {\nthis.nums = nums;\nquickSort(0, nums.length - 1);\nreturn nums;\n}\n\nprivate void quickSort(int l, int r) {\nif (l >= r) {\nreturn;\n}\nint i = l - 1, j = r + 1, k = l;\nint x = nums[(l + r) >> 1];\nwhile (k < j) {\nif (nums[k] < x) {\nswap(++i, k++);\n} else if (nums[k] > x) {\nswap(--j, k);\n} else {\n++k;\n}\n}\nquickSort(l, i);\nquickSort(j, r);\n}\n\nprivate void swap(int i, int j) {\nint t = nums[i];\nnums[i] = nums[j];\nnums[j] = t;\n}\n}\n", "\nclass Solution {\nprivate int[] nums;\n\npublic int[] sortArray(int[] nums) {\nthis.nums = nums;\nmergeSort(0, nums.length - 1);\nreturn nums;\n}\n\nprivate void mergeSort(int l, int r) {\nif (l >= r) {\nreturn;\n}\nint mid = (l + r) >> 1;\nmergeSort(l, mid);\nmergeSort(mid + 1, r);\nint i = l, j = mid + 1, k = 0;\nint[] tmp = new int[r - l + 1];\nwhile (i <= mid && j <= r) {\nif (nums[i] <= nums[j]) {\ntmp[k++] = nums[i++];\n} else {\ntmp[k++] = nums[j++];\n}\n}\nwhile (i <= mid) {\ntmp[k++] = nums[i++];\n}\nwhile (j <= r) {\ntmp[k++] = nums[j++];\n}\nfor (i = l; i <= r; ++i) {\nnums[i] = tmp[i - l];\n}\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number[]}\n*/\nvar sortArray = function (nums) {\nfunction quickSort(l, r) {\nif (l >= r) {\nreturn;\n}\nlet i = l - 1;\nlet j = r + 1;\nconst x = nums[(l + r) >> 1];\nwhile (i < j) {\nwhile (nums[++i] < x);\nwhile (nums[--j] > x);\nif (i < j) {\n[nums[i], nums[j]] = [nums[j], nums[i]];\n}\n}\nquickSort(l, j);\nquickSort(j + 1, r);\n}\nconst n = nums.length;\nquickSort(0, n - 1);\nreturn nums;\n};\n", "\n/**\n* @param {number[]} nums\n* @return {number[]}\n*/\nvar sortArray = function (nums) {\nfunction mergetSort(l, r) {\nif (l >= r) {\nreturn;\n}\nconst mid = (l + r) >> 1;\nmergetSort(l, mid);\nmergetSort(mid + 1, r);\nlet [i, j, k] = [l, mid + 1, 0];\nwhile (i <= mid && j <= r) {\nif (nums[i] <= nums[j]) {\ntmp[k++] = nums[i++];\n} else {\ntmp[k++] = nums[j++];\n}\n}\nwhile (i <= mid) {\ntmp[k++] = nums[i++];\n}\nwhile (j <= r) {\ntmp[k++] = nums[j++];\n}\nfor (i = l, j = 0; i <= r; ++i, ++j) {\nnums[i] = tmp[j];\n}\n}\nconst n = nums.length;\nlet tmp = new Array(n).fill(0);\nmergetSort(0, n - 1);\nreturn nums;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> sortArray(vector<int>& nums) {\nfunction<void(int, int)> quick_sort = [&](int l, int r) {\nif (l >= r) {\nreturn;\n}\nint i = l - 1, j = r + 1;\nint x = nums[(l + r) >> 1];\nwhile (i < j) {\nwhile (nums[++i] < x) {\n}\nwhile (nums[--j] > x) {\n}\nif (i < j) {\nswap(nums[i], nums[j]);\n}\n}\nquick_sort(l, j);\nquick_sort(j + 1, r);\n};\nquick_sort(0, nums.size() - 1);\nreturn nums;\n}\n};\n", "\nclass Solution {\npublic:\nvector<int> sortArray(vector<int>& nums) {\nfunction<void(int, int)> merge_sort = [&](int l, int r) {\nif (l >= r) {\nreturn;\n}\nint mid = (l + r) >> 1;\nmerge_sort(l, mid);\nmerge_sort(mid + 1, r);\nint i = l, j = mid + 1, k = 0;\nint tmp[r - l + 1];\nwhile (i <= mid && j <= r) {\nif (nums[i] <= nums[j]) {\ntmp[k++] = nums[i++];\n} else {\ntmp[k++] = nums[j++];\n}\n}\nwhile (i <= mid) {\ntmp[k++] = nums[i++];\n}\nwhile (j <= r) {\ntmp[k++] = nums[j++];\n}\nfor (i = l; i <= r; ++i) {\nnums[i] = tmp[i - l];\n}\n};\nmerge_sort(0, nums.size() - 1);\nreturn nums;\n}\n};\n"]}, {"leetCodeID": "0919", "level": "middle", "question_description": "A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible.\nDesign an algorithm to insert a new node to a complete binary tree keeping it complete after the insertion.\nImplement the CBTInserter class:\nCBTInserter(TreeNode root) Initializes the data structure with the root of the complete binary tree.\nint insert(int v) Inserts a TreeNode into the tree with value Node.val == val so that the tree remains complete, and returns the value of the parent of the inserted TreeNode.\nTreeNode get_root() Returns the root node of the tree.", "examples": [], "constraints": "\nConstraints:\nThe number of nodes in the tree will be in the range [1, 1000].\n0 <= Node.val <= 5000\nroot is a complete binary tree.\n0 <= val <= 5000\nAt most 104 calls will be made to insert and get_root.\n", "java_context": "    \n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n*/\nvar CBTInserter = function (root) {\n    // your code\n};", "cpp_context": "    \n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass CBTInserter {\nprivate List<TreeNode> tree = new ArrayList<>();\n\npublic CBTInserter(TreeNode root) {\nDeque<TreeNode> q = new ArrayDeque<>();\nq.offer(root);\nwhile (!q.isEmpty()) {\nfor (int i = q.size(); i > 0; --i) {\nTreeNode node = q.poll();\ntree.add(node);\nif (node.left != null) {\nq.offer(node.left);\n}\nif (node.right != null) {\nq.offer(node.right);\n}\n}\n}\n}\n\npublic int insert(int val) {\nTreeNode p = tree.get((tree.size() - 1) / 2);\nTreeNode node = new TreeNode(val);\ntree.add(node);\nif (p.left == null) {\np.left = node;\n} else {\np.right = node;\n}\nreturn p.val;\n}\n\npublic TreeNode get_root() {\nreturn tree.get(0);\n}\n}\n\n/**\n* Your CBTInserter object will be instantiated and called as such:\n* CBTInserter obj = new CBTInserter(root);\n* int param_1 = obj.insert(val);\n* TreeNode param_2 = obj.get_root();\n*/\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n*/\nvar CBTInserter = function (root) {\nthis.tree = [];\nif (root === null) {\nreturn;\n}\nconst q = [root];\nwhile (q.length) {\nconst t = [];\nfor (const node of q) {\nthis.tree.push(node);\nnode.left !== null && t.push(node.left);\nnode.right !== null && t.push(node.right);\n}\nq.splice(0, q.length, ...t);\n}\n};\n\n/**\n* @param {number} val\n* @return {number}\n*/\nCBTInserter.prototype.insert = function (val) {\nconst p = this.tree[(this.tree.length - 1) >> 1];\nconst node = new TreeNode(val);\nthis.tree.push(node);\nif (p.left === null) {\np.left = node;\n} else {\np.right = node;\n}\nreturn p.val;\n};\n\n/**\n* @return {TreeNode}\n*/\nCBTInserter.prototype.get_root = function () {\nreturn this.tree[0];\n};\n\n/**\n* Your CBTInserter object will be instantiated and called as such:\n* var obj = new CBTInserter(root)\n* var param_1 = obj.insert(val)\n* var param_2 = obj.get_root()\n*/\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass CBTInserter {\npublic:\nCBTInserter(TreeNode* root) {\nqueue<TreeNode*> q{{root}};\nwhile (q.size()) {\nfor (int i = q.size(); i; --i) {\nauto node = q.front();\nq.pop();\ntree.push_back(node);\nif (node->left) {\nq.push(node->left);\n}\nif (node->right) {\nq.push(node->right);\n}\n}\n}\n}\n\nint insert(int val) {\nauto p = tree[(tree.size() - 1) / 2];\nauto node = new TreeNode(val);\ntree.push_back(node);\nif (!p->left) {\np->left = node;\n} else {\np->right = node;\n}\nreturn p->val;\n}\n\nTreeNode* get_root() {\nreturn tree[0];\n}\n\nprivate:\nvector<TreeNode*> tree;\n};\n\n/**\n* Your CBTInserter object will be instantiated and called as such:\n* CBTInserter* obj = new CBTInserter(root);\n* int param_1 = obj->insert(val);\n* TreeNode* param_2 = obj->get_root();\n*/\n"]}, {"leetCodeID": "0926", "level": "middle", "question_description": "A binary string is monotone increasing if it consists of some number of 0&#39;s (possibly none), followed by some number of 1&#39;s (also possibly none).\nYou are given a binary string s. You can flip s[i] changing it from 0 to 1 or from 1 to 0.\nReturn the minimum number of flips to make s monotone increasing.", "examples": ["Example 1:\nInput: s = &quot;00110&quot;\nOutput: 1\nExplanation: We flip the last digit to get 00111.\n", "Example 2:\nInput: s = &quot;010110&quot;\nOutput: 2\nExplanation: We flip to get 011111, or alternatively 000111.\n", "Example 3:\nInput: s = &quot;00011000&quot;\nOutput: 2\nExplanation: We flip to get 00000000.\n"], "constraints": "\nConstraints:\n1 <= s.length <= 105\ns[i] is either &#39;0&#39; or &#39;1&#39;.\n", "java_context": "\nclass Solution {\n    public int minFlipsMonoIncr(String s) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} s\n* @return {number}\n*/\nvar minFlipsMonoIncr = function (s) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int minFlipsMonoIncr(string s) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int minFlipsMonoIncr(String s) {\nint n = s.length();\nint tot = 0;\nfor (int i = 0; i < n; ++i) {\nif (s.charAt(i) == '0') {\n++tot;\n}\n}\nint ans = tot, cur = 0;\nfor (int i = 1; i <= n; ++i) {\nif (s.charAt(i - 1) == '0') {\n++cur;\n}\nans = Math.min(ans, i - cur + tot - cur);\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} s\n* @return {number}\n*/\nvar minFlipsMonoIncr = function (s) {\nlet tot = 0;\nfor (const c of s) {\ntot += c === '0' ? 1 : 0;\n}\nlet [ans, cur] = [tot, 0];\nfor (let i = 1; i <= s.length; ++i) {\ncur += s[i - 1] === '0' ? 1 : 0;\nans = Math.min(ans, i - cur + tot - cur);\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint minFlipsMonoIncr(string s) {\nint tot = count(s.begin(), s.end(), '0');\nint ans = tot, cur = 0;\nfor (int i = 1; i <= s.size(); ++i) {\ncur += s[i - 1] == '0';\nans = min(ans, i - cur + tot - cur);\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0930", "level": "middle", "question_description": "Given a binary array nums and an integer goal, return the number of non-empty subarrays with a sum goal.\nA subarray is a contiguous part of the array.", "examples": ["Example 1:\n\nInput: nums = [1,0,1,0,1], goal = 2\n\nOutput: 4\n\nExplanation: The 4 subarrays are bolded and underlined below:\n\n[1,0,1,0,1]\n\n[1,0,1,0,1]\n\n[1,0,1,0,1]\n\n[1,0,1,0,1]\n\n", "Example 2:\n\nInput: nums = [0,0,0,0,0], goal = 0\n\nOutput: 15\n\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 3 * 104\nnums[i] is either 0 or 1.\n0 <= goal <= nums.length\n", "java_context": "\nclass Solution {\n    public int numSubarraysWithSum(int[] nums, int goal) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @param {number} goal\n* @return {number}\n*/\nvar numSubarraysWithSum = function (nums, goal) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int numSubarraysWithSum(vector<int>& nums, int goal) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int numSubarraysWithSum(int[] nums, int goal) {\nint[] cnt = new int[nums.length + 1];\ncnt[0] = 1;\nint ans = 0, s = 0;\nfor (int v : nums) {\ns += v;\nif (s - goal >= 0) {\nans += cnt[s - goal];\n}\n++cnt[s];\n}\nreturn ans;\n}\n}\n", "\nclass Solution {\npublic int numSubarraysWithSum(int[] nums, int goal) {\nint i1 = 0, i2 = 0, s1 = 0, s2 = 0, j = 0, ans = 0;\nint n = nums.length;\nwhile (j < n) {\ns1 += nums[j];\ns2 += nums[j];\nwhile (i1 <= j && s1 > goal) {\ns1 -= nums[i1++];\n}\nwhile (i2 <= j && s2 >= goal) {\ns2 -= nums[i2++];\n}\nans += i2 - i1;\n++j;\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @param {number} goal\n* @return {number}\n*/\nvar numSubarraysWithSum = function (nums, goal) {\nconst cnt = new Array(nums.length + 1).fill(0);\ncnt[0] = 1;\nlet ans = 0;\nlet s = 0;\nfor (const v of nums) {\ns += v;\nif (s >= goal) {\nans += cnt[s - goal];\n}\n++cnt[s];\n}\nreturn ans;\n};\n", "\n/**\n* @param {number[]} nums\n* @param {number} goal\n* @return {number}\n*/\nvar numSubarraysWithSum = function (nums, goal) {\nlet i1 = 0,\ni2 = 0,\ns1 = 0,\ns2 = 0,\nj = 0,\nans = 0;\nconst n = nums.length;\nwhile (j < n) {\ns1 += nums[j];\ns2 += nums[j];\nwhile (i1 <= j && s1 > goal) s1 -= nums[i1++];\nwhile (i2 <= j && s2 >= goal) s2 -= nums[i2++];\nans += i2 - i1;\n++j;\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint numSubarraysWithSum(vector<int>& nums, int goal) {\nint cnt[nums.size() + 1];\nmemset(cnt, 0, sizeof cnt);\ncnt[0] = 1;\nint ans = 0, s = 0;\nfor (int& v : nums) {\ns += v;\nif (s - goal >= 0) {\nans += cnt[s - goal];\n}\n++cnt[s];\n}\nreturn ans;\n}\n};\n", "\nclass Solution {\npublic:\nint numSubarraysWithSum(vector<int>& nums, int goal) {\nint i1 = 0, i2 = 0, s1 = 0, s2 = 0, j = 0, ans = 0;\nint n = nums.size();\nwhile (j < n) {\ns1 += nums[j];\ns2 += nums[j];\nwhile (i1 <= j && s1 > goal) s1 -= nums[i1++];\nwhile (i2 <= j && s2 >= goal) s2 -= nums[i2++];\nans += i2 - i1;\n++j;\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0946", "level": "middle", "question_description": "Given two integer arrays pushed and popped each with distinct values, return true if this could have been the result of a sequence of push and pop operations on an initially empty stack, or false otherwise.", "examples": ["Example 1:\nInput: pushed = [1,2,3,4,5], popped = [4,5,3,2,1]\nOutput: true\nExplanation: We might do the following sequence:\npush(1), push(2), push(3), push(4),\npop() -&gt; 4,\npush(5),\npop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1\n", "Example 2:\nInput: pushed = [1,2,3,4,5], popped = [4,3,5,1,2]\nOutput: false\nExplanation: 1 cannot be popped before 2.\n"], "constraints": "\nConstraints:\n1 <= pushed.length <= 1000\n0 <= pushed[i] <= 1000\nAll the elements of pushed are unique.\npopped.length == pushed.length\npopped is a permutation of pushed.\n", "java_context": "\nclass Solution {\n    public boolean validateStackSequences(int[] pushed, int[] popped) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} pushed\n* @param {number[]} popped\n* @return {boolean}\n*/\nvar validateStackSequences = function (pushed, popped) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic boolean validateStackSequences(int[] pushed, int[] popped) {\nDeque<Integer> stk = new ArrayDeque<>();\nint j = 0;\nfor (int v : pushed) {\nstk.push(v);\nwhile (!stk.isEmpty() && stk.peek() == popped[j]) {\nstk.pop();\n++j;\n}\n}\nreturn j == pushed.length;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} pushed\n* @param {number[]} popped\n* @return {boolean}\n*/\nvar validateStackSequences = function (pushed, popped) {\nlet stk = [];\nlet j = 0;\nfor (const v of pushed) {\nstk.push(v);\nwhile (stk.length && stk[stk.length - 1] == popped[j]) {\nstk.pop();\n++j;\n}\n}\nreturn j == pushed.length;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nbool validateStackSequences(vector<int>& pushed, vector<int>& popped) {\nstack<int> stk;\nint j = 0;\nfor (int v : pushed) {\nstk.push(v);\nwhile (!stk.empty() && stk.top() == popped[j]) {\nstk.pop();\n++j;\n}\n}\nreturn j == pushed.size();\n}\n};\n"]}, {"leetCodeID": "0970", "level": "middle", "question_description": "Given three integers x, y, and bound, return a list of all the powerful integers that have a value less than or equal to bound.\nAn integer is powerful if it can be represented as xi + yj for some integers i &gt;= 0 and j &gt;= 0.\nYou may return the answer in any order. In your answer, each value should occur at most once.", "examples": ["Example 1:\nInput: x = 2, y = 3, bound = 10\nOutput: [2,3,4,5,7,9,10]\nExplanation:\n2 = 20 + 30\n3 = 21 + 30\n4 = 20 + 31\n5 = 21 + 31\n7 = 22 + 31\n9 = 23 + 30\n10 = 20 + 32\n", "Example 2:\nInput: x = 3, y = 5, bound = 15\nOutput: [2,4,6,8,10,14]\n"], "constraints": "\nConstraints:\n1 <= x, y <= 100\n0 <= bound <= 106\n", "java_context": "\nclass Solution {\n    public List<Integer> powerfulIntegers(int x, int y, int bound) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number} x\n* @param {number} y\n* @param {number} bound\n* @return {number[]}\n*/\nvar powerfulIntegers = function (x, y, bound) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> powerfulIntegers(int x, int y, int bound) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic List<Integer> powerfulIntegers(int x, int y, int bound) {\nSet<Integer> ans = new HashSet<>();\nfor (int a = 1; a <= bound; a *= x) {\nfor (int b = 1; a + b <= bound; b *= y) {\nans.add(a + b);\nif (y == 1) {\nbreak;\n}\n}\nif (x == 1) {\nbreak;\n}\n}\nreturn new ArrayList<>(ans);\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number} x\n* @param {number} y\n* @param {number} bound\n* @return {number[]}\n*/\nvar powerfulIntegers = function (x, y, bound) {\nconst ans = new Set();\nfor (let a = 1; a <= bound; a *= x) {\nfor (let b = 1; a + b <= bound; b *= y) {\nans.add(a + b);\nif (y === 1) {\nbreak;\n}\n}\nif (x === 1) {\nbreak;\n}\n}\nreturn [...ans];\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> powerfulIntegers(int x, int y, int bound) {\nunordered_set<int> ans;\nfor (int a = 1; a <= bound; a *= x) {\nfor (int b = 1; a + b <= bound; b *= y) {\nans.insert(a + b);\nif (y == 1) {\nbreak;\n}\n}\nif (x == 1) {\nbreak;\n}\n}\nreturn vector<int>(ans.begin(), ans.end());\n}\n};\n"]}, {"leetCodeID": "0985", "level": "middle", "question_description": "You are given an integer array nums and an array queries where queries[i] = [vali, indexi].\nFor each query i, first, apply nums[indexi] = nums[indexi] + vali, then print the sum of the even values of nums.\nReturn an integer array answer where answer[i] is the answer to the ith query.", "examples": ["Example 1:\nInput: nums = [1,2,3,4], queries = [[1,0],[-3,1],[-4,0],[2,3]]\nOutput: [8,6,2,4]\nExplanation: At the beginning, the array is [1,2,3,4].\nAfter adding 1 to nums[0], the array is [2,2,3,4], and the sum of even values is 2 + 2 + 4 = 8.\nAfter adding -3 to nums[1], the array is [2,-1,3,4], and the sum of even values is 2 + 4 = 6.\nAfter adding -4 to nums[0], the array is [-2,-1,3,4], and the sum of even values is -2 + 4 = 2.\nAfter adding 2 to nums[3], the array is [-2,-1,3,6], and the sum of even values is -2 + 6 = 4.\n", "Example 2:\nInput: nums = [1], queries = [[4,0]]\nOutput: [0]\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 104\n-104 <= nums[i] <= 104\n1 <= queries.length <= 104\n-104 <= vali <= 104\n0 <= indexi < nums.length\n", "java_context": "\nclass Solution {\n    public int[] sumEvenAfterQueries(int[] nums, int[][] queries) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @param {number[][]} queries\n* @return {number[]}\n*/\nvar sumEvenAfterQueries = function (nums, queries) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> sumEvenAfterQueries(vector<int>& nums, vector<vector<int>>& queries) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int[] sumEvenAfterQueries(int[] nums, int[][] queries) {\nint s = 0;\nfor (int x : nums) {\nif (x % 2 == 0) {\ns += x;\n}\n}\nint m = queries.length;\nint[] ans = new int[m];\nint k = 0;\nfor (var q : queries) {\nint v = q[0], i = q[1];\nif (nums[i] % 2 == 0) {\ns -= nums[i];\n}\nnums[i] += v;\nif (nums[i] % 2 == 0) {\ns += nums[i];\n}\nans[k++] = s;\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @param {number[][]} queries\n* @return {number[]}\n*/\nvar sumEvenAfterQueries = function (nums, queries) {\nlet s = 0;\nfor (const x of nums) {\nif (x % 2 === 0) {\ns += x;\n}\n}\nconst ans = [];\nfor (const [v, i] of queries) {\nif (nums[i] % 2 === 0) {\ns -= nums[i];\n}\nnums[i] += v;\nif (nums[i] % 2 === 0) {\ns += nums[i];\n}\nans.push(s);\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> sumEvenAfterQueries(vector<int>& nums, vector<vector<int>>& queries) {\nint s = 0;\nfor (int x : nums) {\nif (x % 2 == 0) {\ns += x;\n}\n}\nvector<int> ans;\nfor (auto& q : queries) {\nint v = q[0], i = q[1];\nif (nums[i] % 2 == 0) {\ns -= nums[i];\n}\nnums[i] += v;\nif (nums[i] % 2 == 0) {\ns += nums[i];\n}\nans.push_back(s);\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1019", "level": "middle", "question_description": "You are given the head of a linked list with n nodes.\nFor each node in the list, find the value of the next greater node. That is, for each node, find the value of the first node that is next to it and has a strictly larger value than it.\nReturn an integer array answer where answer[i] is the value of the next greater node of the ith node (1-indexed). If the ith node does not have a next greater node, set answer[i] = 0.", "examples": [], "constraints": "\nConstraints:\nThe number of nodes in the list is n.\n1 <= n <= 104\n1 <= Node.val <= 109\n", "java_context": "\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode() {}\n*     ListNode(int val) { this.val = val; }\n*     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n* }\n*/\nclass Solution {\n    public int[] nextLargerNodes(ListNode head) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for singly-linked list.\n* function ListNode(val, next) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.next = (next===undefined ? null : next)\n* }\n*/\n/**\n* @param {ListNode} head\n* @return {number[]}\n*/\nvar nextLargerNodes = function (head) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\nclass Solution {\npublic:\n    vector<int> nextLargerNodes(ListNode* head) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode() {}\n*     ListNode(int val) { this.val = val; }\n*     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n* }\n*/\nclass Solution {\npublic int[] nextLargerNodes(ListNode head) {\nList<Integer> nums = new ArrayList<>();\nfor (; head != null; head = head.next) {\nnums.add(head.val);\n}\nDeque<Integer> stk = new ArrayDeque<>();\nint n = nums.size();\nint[] ans = new int[n];\nfor (int i = n - 1; i >= 0; --i) {\nwhile (!stk.isEmpty() && stk.peek() <= nums.get(i)) {\nstk.pop();\n}\nif (!stk.isEmpty()) {\nans[i] = stk.peek();\n}\nstk.push(nums.get(i));\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for singly-linked list.\n* function ListNode(val, next) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.next = (next===undefined ? null : next)\n* }\n*/\n/**\n* @param {ListNode} head\n* @return {number[]}\n*/\nvar nextLargerNodes = function (head) {\nconst nums = [];\nwhile (head) {\nnums.push(head.val);\nhead = head.next;\n}\nconst stk = [];\nconst n = nums.length;\nconst ans = new Array(n).fill(0);\nfor (let i = n - 1; i >= 0; --i) {\nwhile (stk.length && stk[stk.length - 1] <= nums[i]) {\nstk.pop();\n}\nans[i] = stk.length ? stk[stk.length - 1] : 0;\nstk.push(nums[i]);\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\nclass Solution {\npublic:\nvector<int> nextLargerNodes(ListNode* head) {\nvector<int> nums;\nfor (; head; head = head->next) {\nnums.push_back(head->val);\n}\nstack<int> stk;\nint n = nums.size();\nvector<int> ans(n);\nfor (int i = n - 1; ~i; --i) {\nwhile (!stk.empty() && stk.top() <= nums[i]) {\nstk.pop();\n}\nif (!stk.empty()) {\nans[i] = stk.top();\n}\nstk.push(nums[i]);\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1026", "level": "middle", "question_description": "Given the root of a binary tree, find the maximum value v for which there exist different nodes a and b where v = |a.val - b.val| and a is an ancestor of b.\nA node a is an ancestor of b if either: any child of a is equal to b or any child of a is an ancestor of b.", "examples": [], "constraints": "\nConstraints:\nThe number of nodes in the tree is in the range [2, 5000].\n0 <= Node.val <= 105\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\n    private int ans;\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {number}\n*/\nvar maxAncestorDiff = function (root) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    int maxAncestorDiff(TreeNode* root) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\nprivate int ans;\n\npublic int maxAncestorDiff(TreeNode root) {\ndfs(root, root.val, root.val);\nreturn ans;\n}\n\nprivate void dfs(TreeNode root, int mi, int mx) {\nif (root == null) {\nreturn;\n}\nint x = Math.max(Math.abs(mi - root.val), Math.abs(mx - root.val));\nans = Math.max(ans, x);\nmi = Math.min(mi, root.val);\nmx = Math.max(mx, root.val);\ndfs(root.left, mi, mx);\ndfs(root.right, mi, mx);\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {number}\n*/\nvar maxAncestorDiff = function (root) {\nlet ans = 0;\nconst dfs = (root, mi, mx) => {\nif (!root) {\nreturn;\n}\nans = Math.max(ans, Math.abs(mi - root.val), Math.abs(mx - root.val));\nmi = Math.min(mi, root.val);\nmx = Math.max(mx, root.val);\ndfs(root.left, mi, mx);\ndfs(root.right, mi, mx);\n};\ndfs(root, root.val, root.val);\nreturn ans;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nint maxAncestorDiff(TreeNode* root) {\nint ans = 0;\nfunction<void(TreeNode*, int, int)> dfs = [&](TreeNode* root, int mi, int mx) {\nif (!root) {\nreturn;\n}\nans = max({ans, abs(mi - root->val), abs(mx - root->val)});\nmi = min(mi, root->val);\nmx = max(mx, root->val);\ndfs(root->left, mi, mx);\ndfs(root->right, mi, mx);\n};\ndfs(root, root->val, root->val);\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1038", "level": "middle", "question_description": "Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus the sum of all keys greater than the original key in BST.\nAs a reminder, a binary search tree is a tree that satisfies these constraints:\nThe left subtree of a node contains only nodes with keys less than the node&#39;s key.\nThe right subtree of a node contains only nodes with keys greater than the node&#39;s key.\nBoth the left and right subtrees must also be binary search trees.", "examples": ["Example 1:\n\n\nInput: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]\nOutput: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]\n\n\nExample 2:\nInput: root = [0,null,1]\nOutput: [1,null,1]\n"], "constraints": "\nConstraints:\nThe number of nodes in the tree is in the range [1, 100].\n0 <= Node.val <= 100\nAll the values in the tree are unique.\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\n    private int s;\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {TreeNode}\n*/\nvar bstToGst = function (root) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    int s = 0;\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\nprivate int s;\n\npublic TreeNode bstToGst(TreeNode root) {\ndfs(root);\nreturn root;\n}\n\nprivate void dfs(TreeNode root) {\nif (root == null) {\nreturn;\n}\ndfs(root.right);\ns += root.val;\nroot.val = s;\ndfs(root.left);\n}\n}\n", "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\npublic TreeNode bstToGst(TreeNode root) {\nint s = 0;\nTreeNode node = root;\nwhile (root != null) {\nif (root.right == null) {\ns += root.val;\nroot.val = s;\nroot = root.left;\n} else {\nTreeNode next = root.right;\nwhile (next.left != null && next.left != root) {\nnext = next.left;\n}\nif (next.left == null) {\nnext.left = root;\nroot = root.right;\n} else {\ns += root.val;\nroot.val = s;\nnext.left = null;\nroot = root.left;\n}\n}\n}\nreturn node;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {TreeNode}\n*/\nvar bstToGst = function (root) {\nlet s = 0;\nfunction dfs(root) {\nif (!root) {\nreturn;\n}\ndfs(root.right);\ns += root.val;\nroot.val = s;\ndfs(root.left);\n}\ndfs(root);\nreturn root;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nint s = 0;\n\nTreeNode* bstToGst(TreeNode* root) {\ndfs(root);\nreturn root;\n}\n\nvoid dfs(TreeNode* root) {\nif (!root) return;\ndfs(root->right);\ns += root->val;\nroot->val = s;\ndfs(root->left);\n}\n};\n", "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nTreeNode* bstToGst(TreeNode* root) {\nint s = 0;\nTreeNode* node = root;\nwhile (root) {\nif (root->right == nullptr) {\ns += root->val;\nroot->val = s;\nroot = root->left;\n} else {\nTreeNode* next = root->right;\nwhile (next->left && next->left != root) {\nnext = next->left;\n}\nif (next->left == nullptr) {\nnext->left = root;\nroot = root->right;\n} else {\ns += root->val;\nroot->val = s;\nnext->left = nullptr;\nroot = root->left;\n}\n}\n}\nreturn node;\n}\n};\n"]}, {"leetCodeID": "1049", "level": "middle", "question_description": "You are given an array of integers stones where stones[i] is the weight of the ith stone.\nWe are playing a game with the stones. On each turn, we choose any two stones and smash them together. Suppose the stones have weights x and y with x &lt;= y. The result of this smash is:\nIf x == y, both stones are destroyed, and\nIf x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.\nAt the end of the game, there is at most one stone left.\nReturn the smallest possible weight of the left stone. If there are no stones left, return 0.", "examples": ["Example 1:\nInput: stones = [2,7,4,1,8,1]\nOutput: 1\nExplanation:\nWe can combine 2 and 4 to get 2, so the array converts to [2,7,1,8,1] then,\nwe can combine 7 and 8 to get 1, so the array converts to [2,1,1,1] then,\nwe can combine 2 and 1 to get 1, so the array converts to [1,1,1] then,\nwe can combine 1 and 1 to get 0, so the array converts to [1], then that&#39;s the optimal value.\n", "Example 2:\nInput: stones = [31,26,33,21,40]\nOutput: 5\n"], "constraints": "\nConstraints:\n1 <= stones.length <= 30\n1 <= stones[i] <= 100\n", "java_context": "\nclass Solution {\n    public int lastStoneWeightII(int[] stones) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} stones\n* @return {number}\n*/\nvar lastStoneWeightII = function (stones) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int lastStoneWeightII(vector<int>& stones) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int lastStoneWeightII(int[] stones) {\nint s = 0;\nfor (int v : stones) {\ns += v;\n}\nint m = stones.length;\nint n = s >> 1;\nint[][] dp = new int[m + 1][n + 1];\nfor (int i = 1; i <= m; ++i) {\nfor (int j = 0; j <= n; ++j) {\ndp[i][j] = dp[i - 1][j];\nif (stones[i - 1] <= j) {\ndp[i][j] = Math.max(dp[i][j], dp[i - 1][j - stones[i - 1]] + stones[i - 1]);\n}\n}\n}\nreturn s - dp[m][n] * 2;\n}\n}\n", "\nclass Solution {\npublic int lastStoneWeightII(int[] stones) {\nint s = 0;\nfor (int v : stones) {\ns += v;\n}\nint m = stones.length;\nint n = s >> 1;\nint[] dp = new int[n + 1];\nfor (int v : stones) {\nfor (int j = n; j >= v; --j) {\ndp[j] = Math.max(dp[j], dp[j - v] + v);\n}\n}\nreturn s - dp[n] * 2;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} stones\n* @return {number}\n*/\nvar lastStoneWeightII = function (stones) {\nlet s = 0;\nfor (let v of stones) {\ns += v;\n}\nconst n = s >> 1;\nlet dp = new Array(n + 1).fill(0);\nfor (let v of stones) {\nfor (let j = n; j >= v; --j) {\ndp[j] = Math.max(dp[j], dp[j - v] + v);\n}\n}\nreturn s - dp[n] * 2;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint lastStoneWeightII(vector<int>& stones) {\nint s = accumulate(stones.begin(), stones.end(), 0);\nint m = stones.size(), n = s >> 1;\nvector<vector<int>> dp(m + 1, vector<int>(n + 1));\nfor (int i = 1; i <= m; ++i) {\nfor (int j = 0; j <= n; ++j) {\ndp[i][j] = dp[i - 1][j];\nif (stones[i - 1] <= j) dp[i][j] = max(dp[i][j], dp[i - 1][j - stones[i - 1]] + stones[i - 1]);\n}\n}\nreturn s - dp[m][n] * 2;\n}\n};\n", "\nclass Solution {\npublic:\nint lastStoneWeightII(vector<int>& stones) {\nint s = accumulate(stones.begin(), stones.end(), 0);\nint n = s >> 1;\nvector<int> dp(n + 1);\nfor (int& v : stones)\nfor (int j = n; j >= v; --j)\ndp[j] = max(dp[j], dp[j - v] + v);\nreturn s - dp[n] * 2;\n}\n};\n"]}, {"leetCodeID": "1080", "level": "middle", "question_description": "Given the root of a binary tree and an integer limit, delete all insufficient nodes in the tree simultaneously, and return the root of the resulting binary tree.\nA node is insufficient if every root to leaf path intersecting this node has a sum strictly less than limit.\nA leaf is a node with no children.", "examples": [], "constraints": "\nConstraints:\nThe number of nodes in the tree is in the range [1, 5000].\n-105 <= Node.val <= 105\n-109 <= limit <= 109\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\n    public TreeNode sufficientSubset(TreeNode root, int limit) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @param {number} limit\n* @return {TreeNode}\n*/\nvar sufficientSubset = function (root, limit) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    TreeNode* sufficientSubset(TreeNode* root, int limit) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\npublic TreeNode sufficientSubset(TreeNode root, int limit) {\nif (root == null) {\nreturn null;\n}\nlimit -= root.val;\nif (root.left == null && root.right == null) {\nreturn limit > 0 ? null : root;\n}\nroot.left = sufficientSubset(root.left, limit);\nroot.right = sufficientSubset(root.right, limit);\nreturn root.left == null && root.right == null ? null : root;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @param {number} limit\n* @return {TreeNode}\n*/\nvar sufficientSubset = function (root, limit) {\nif (root === null) {\nreturn null;\n}\nlimit -= root.val;\nif (root.left === null && root.right === null) {\nreturn limit > 0 ? null : root;\n}\nroot.left = sufficientSubset(root.left, limit);\nroot.right = sufficientSubset(root.right, limit);\nreturn root.left === null && root.right === null ? null : root;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nTreeNode* sufficientSubset(TreeNode* root, int limit) {\nif (!root) {\nreturn nullptr;\n}\nlimit -= root->val;\nif (!root->left && !root->right) {\nreturn limit > 0 ? nullptr : root;\n}\nroot->left = sufficientSubset(root->left, limit);\nroot->right = sufficientSubset(root->right, limit);\nreturn !root->left && !root->right ? nullptr : root;\n}\n};\n"]}, {"leetCodeID": "1094", "level": "middle", "question_description": "There is a car with capacity empty seats. The vehicle only drives east (i.e., it cannot turn around and drive west).\nYou are given the integer capacity and an array trips where trips[i] = [numPassengersi, fromi, toi] indicates that the ith trip has numPassengersi passengers and the locations to pick them up and drop them off are fromi and toi respectively. The locations are given as the number of kilometers due east from the car&#39;s initial location.\nReturn true if it is possible to pick up and drop off all passengers for all the given trips, or false otherwise.", "examples": ["Example 1:\nInput: trips = [[2,1,5],[3,3,7]], capacity = 4\nOutput: false\n", "Example 2:\nInput: trips = [[2,1,5],[3,3,7]], capacity = 5\nOutput: true\n"], "constraints": "\nConstraints:\n1 <= trips.length <= 1000\ntrips[i].length == 3\n1 <= numPassengersi <= 100\n0 <= fromi < toi <= 1000\n1 <= capacity <= 105\n", "java_context": "\nclass Solution {\n    public boolean carPooling(int[][] trips, int capacity) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[][]} trips\n* @param {number} capacity\n* @return {boolean}\n*/\nvar carPooling = function (trips, capacity) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    bool carPooling(vector<vector<int>>& trips, int capacity) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic boolean carPooling(int[][] trips, int capacity) {\nint[] d = new int[1001];\nfor (var trip : trips) {\nint x = trip[0], f = trip[1], t = trip[2];\nd[f] += x;\nd[t] -= x;\n}\nint s = 0;\nfor (int x : d) {\ns += x;\nif (s > capacity) {\nreturn false;\n}\n}\nreturn true;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[][]} trips\n* @param {number} capacity\n* @return {boolean}\n*/\nvar carPooling = function (trips, capacity) {\nconst mx = Math.max(...trips.map(([, , t]) => t));\nconst d = Array(mx + 1).fill(0);\nfor (const [x, f, t] of trips) {\nd[f] += x;\nd[t] -= x;\n}\nlet s = 0;\nfor (const x of d) {\ns += x;\nif (s > capacity) {\nreturn false;\n}\n}\nreturn true;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nbool carPooling(vector<vector<int>>& trips, int capacity) {\nint d[1001]{};\nfor (auto& trip : trips) {\nint x = trip[0], f = trip[1], t = trip[2];\nd[f] += x;\nd[t] -= x;\n}\nint s = 0;\nfor (int x : d) {\ns += x;\nif (s > capacity) {\nreturn false;\n}\n}\nreturn true;\n}\n};\n"]}, {"leetCodeID": "1109", "level": "middle", "question_description": "There are n flights that are labeled from 1 to n.\nYou are given an array of flight bookings bookings, where bookings[i] = [firsti, lasti, seatsi] represents a booking for flights firsti through lasti (inclusive) with seatsi seats reserved for each flight in the range.\nReturn an array answer of length n, where answer[i] is the total number of seats reserved for flight i.", "examples": ["Example 1:\nInput: bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5\nOutput: [10,55,45,25,25]\nExplanation:\nFlight labels:        1   2   3   4   5\nBooking 1 reserved:  10  10\nBooking 2 reserved:      20  20\nBooking 3 reserved:      25  25  25  25\nTotal seats:         10  55  45  25  25\nHence, answer = [10,55,45,25,25]\n", "Example 2:\nInput: bookings = [[1,2,10],[2,2,15]], n = 2\nOutput: [10,25]\nExplanation:\nFlight labels:        1   2\nBooking 1 reserved:  10  10\nBooking 2 reserved:      15\nTotal seats:         10  25\nHence, answer = [10,25]\n\n"], "constraints": "\nConstraints:\n1 <= n <= 2 * 104\n1 <= bookings.length <= 2 * 104\nbookings[i].length == 3\n1 <= firsti <= lasti <= n\n1 <= seatsi <= 104\n", "java_context": "\nclass Solution {\n    public int[] corpFlightBookings(int[][] bookings, int n) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[][]} bookings\n* @param {number} n\n* @return {number[]}\n*/\nvar corpFlightBookings = function (bookings, n) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> corpFlightBookings(vector<vector<int>>& bookings, int n) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int[] corpFlightBookings(int[][] bookings, int n) {\nint[] ans = new int[n];\nfor (var e : bookings) {\nint first = e[0], last = e[1], seats = e[2];\nans[first - 1] += seats;\nif (last < n) {\nans[last] -= seats;\n}\n}\nfor (int i = 1; i < n; ++i) {\nans[i] += ans[i - 1];\n}\nreturn ans;\n}\n}\n", "\nclass Solution {\npublic int[] corpFlightBookings(int[][] bookings, int n) {\nBinaryIndexedTree tree = new BinaryIndexedTree(n);\nfor (var e : bookings) {\nint first = e[0], last = e[1], seats = e[2];\ntree.update(first, seats);\ntree.update(last + 1, -seats);\n}\nint[] ans = new int[n];\nfor (int i = 0; i < n; ++i) {\nans[i] = tree.query(i + 1);\n}\nreturn ans;\n}\n}\n\nclass BinaryIndexedTree {\nprivate int n;\nprivate int[] c;\n\npublic BinaryIndexedTree(int n) {\nthis.n = n;\nc = new int[n + 1];\n}\n\npublic void update(int x, int delta) {\nwhile (x <= n) {\nc[x] += delta;\nx += x & -x;\n}\n}\n\npublic int query(int x) {\nint s = 0;\nwhile (x > 0) {\ns += c[x];\nx -= x & -x;\n}\nreturn s;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[][]} bookings\n* @param {number} n\n* @return {number[]}\n*/\nvar corpFlightBookings = function (bookings, n) {\nconst ans = new Array(n).fill(0);\nfor (const [first, last, seats] of bookings) {\nans[first - 1] += seats;\nif (last < n) {\nans[last] -= seats;\n}\n}\nfor (let i = 1; i < n; ++i) {\nans[i] += ans[i - 1];\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> corpFlightBookings(vector<vector<int>>& bookings, int n) {\nvector<int> ans(n);\nfor (auto& e : bookings) {\nint first = e[0], last = e[1], seats = e[2];\nans[first - 1] += seats;\nif (last < n) {\nans[last] -= seats;\n}\n}\nfor (int i = 1; i < n; ++i) {\nans[i] += ans[i - 1];\n}\nreturn ans;\n}\n};\n", "\nclass BinaryIndexedTree {\npublic:\nBinaryIndexedTree(int _n)\n: n(_n)\n, c(_n + 1) {}\n\nvoid update(int x, int delta) {\nwhile (x <= n) {\nc[x] += delta;\nx += x & -x;\n}\n}\n\nint query(int x) {\nint s = 0;\nwhile (x) {\ns += c[x];\nx -= x & -x;\n}\nreturn s;\n}\n\nprivate:\nint n;\nvector<int> c;\n};\n\nclass Solution {\npublic:\nvector<int> corpFlightBookings(vector<vector<int>>& bookings, int n) {\nBinaryIndexedTree* tree = new BinaryIndexedTree(n);\nfor (auto& e : bookings) {\nint first = e[0], last = e[1], seats = e[2];\ntree->update(first, seats);\ntree->update(last + 1, -seats);\n}\nvector<int> ans(n);\nfor (int i = 0; i < n; ++i) {\nans[i] = tree->query(i + 1);\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1143", "level": "middle", "question_description": "Given two strings text1 and text2, return the length of their longest common subsequence. If there is no common subsequence, return 0.\nA subsequence of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\nFor example, &quot;ace&quot; is a subsequence of &quot;abcde&quot;.\nA common subsequence of two strings is a subsequence that is common to both strings.", "examples": ["Example 1:\nInput: text1 = &quot;abcde&quot;, text2 = &quot;ace&quot;\nOutput: 3\nExplanation: The longest common subsequence is &quot;ace&quot; and its length is 3.\n", "Example 2:\nInput: text1 = &quot;abc&quot;, text2 = &quot;abc&quot;\nOutput: 3\nExplanation: The longest common subsequence is &quot;abc&quot; and its length is 3.\n", "Example 3:\nInput: text1 = &quot;abc&quot;, text2 = &quot;def&quot;\nOutput: 0\nExplanation: There is no such common subsequence, so the result is 0.\n"], "constraints": "\nConstraints:\n1 <= text1.length, text2.length <= 1000\ntext1 and text2 consist of only lowercase English characters.\n", "java_context": "\nclass Solution {\n    public int longestCommonSubsequence(String text1, String text2) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} text1\n* @param {string} text2\n* @return {number}\n*/\nvar longestCommonSubsequence = function (text1, text2) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int longestCommonSubsequence(String text1, String text2) {\nint m = text1.length(), n = text2.length();\nint[][] f = new int[m + 1][n + 1];\nfor (int i = 1; i <= m; ++i) {\nfor (int j = 1; j <= n; ++j) {\nif (text1.charAt(i - 1) == text2.charAt(j - 1)) {\nf[i][j] = f[i - 1][j - 1] + 1;\n} else {\nf[i][j] = Math.max(f[i - 1][j], f[i][j - 1]);\n}\n}\n}\nreturn f[m][n];\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} text1\n* @param {string} text2\n* @return {number}\n*/\nvar longestCommonSubsequence = function (text1, text2) {\nconst m = text1.length;\nconst n = text2.length;\nconst f = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));\nfor (let i = 1; i <= m; ++i) {\nfor (let j = 1; j <= n; ++j) {\nif (text1[i - 1] == text2[j - 1]) {\nf[i][j] = f[i - 1][j - 1] + 1;\n} else {\nf[i][j] = Math.max(f[i - 1][j], f[i][j - 1]);\n}\n}\n}\nreturn f[m][n];\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint longestCommonSubsequence(string text1, string text2) {\nint m = text1.size(), n = text2.size();\nint f[m + 1][n + 1];\nmemset(f, 0, sizeof f);\nfor (int i = 1; i <= m; ++i) {\nfor (int j = 1; j <= n; ++j) {\nif (text1[i - 1] == text2[j - 1]) {\nf[i][j] = f[i - 1][j - 1] + 1;\n} else {\nf[i][j] = max(f[i - 1][j], f[i][j - 1]);\n}\n}\n}\nreturn f[m][n];\n}\n};\n"]}, {"leetCodeID": "1145", "level": "middle", "question_description": "Two players play a turn based game on a binary tree. We are given the root of this binary tree, and the number of nodes n in the tree. n is odd, and each node has a distinct value from 1 to n.\nInitially, the first player names a value x with 1 &lt;= x &lt;= n, and the second player names a value y with 1 &lt;= y &lt;= n and y != x. The first player colors the node with value x red, and the second player colors the node with value y blue.\nThen, the players take turns starting with the first player. In each turn, that player chooses a node of their color (red if player 1, blue if player 2) and colors an uncolored neighbor of the chosen node (either the left child, right child, or parent of the chosen node.)\nIf (and only if) a player cannot choose such a node in this way, they must pass their turn. If both players pass their turn, the game ends, and the winner is the player that colored more nodes.\nYou are the second player. If it is possible to choose such a y to ensure you win the game, return true. If it is not possible, return false.", "examples": ["Example 1:\n\n\nInput: root = [1,2,3,4,5,6,7,8,9,10,11], n = 11, x = 3\nOutput: true\nExplanation: The second player can choose the node with value 2.\n\n\nExample 2:\nInput: root = [1,2,3], n = 3, x = 1\nOutput: false\n"], "constraints": "\nConstraints:\nThe number of nodes in the tree is n.\n1 <= x <= n <= 100\nn is odd.\n1 <= Node.val <= n\nAll the values of the tree are unique.\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\n    public boolean btreeGameWinningMove(TreeNode root, int n, int x) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @param {number} n\n* @param {number} x\n* @return {boolean}\n*/\nvar btreeGameWinningMove = function (root, n, x) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    bool btreeGameWinningMove(TreeNode* root, int n, int x) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\npublic boolean btreeGameWinningMove(TreeNode root, int n, int x) {\nTreeNode node = dfs(root, x);\nint l = count(node.left);\nint r = count(node.right);\nreturn Math.max(Math.max(l, r), n - l - r - 1) > n / 2;\n}\n\nprivate TreeNode dfs(TreeNode root, int x) {\nif (root == null || root.val == x) {\nreturn root;\n}\nTreeNode node = dfs(root.left, x);\nreturn node == null ? dfs(root.right, x) : node;\n}\n\nprivate int count(TreeNode root) {\nif (root == null) {\nreturn 0;\n}\nreturn 1 + count(root.left) + count(root.right);\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @param {number} n\n* @param {number} x\n* @return {boolean}\n*/\nvar btreeGameWinningMove = function (root, n, x) {\nconst dfs = root => {\nif (!root || root.val === x) {\nreturn root;\n}\nreturn dfs(root.left) || dfs(root.right);\n};\n\nconst count = root => {\nif (!root) {\nreturn 0;\n}\nreturn 1 + count(root.left) + count(root.right);\n};\n\nconst node = dfs(root);\nconst l = count(node.left);\nconst r = count(node.right);\nreturn Math.max(l, r, n - l - r - 1) > n / 2;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nbool btreeGameWinningMove(TreeNode* root, int n, int x) {\nauto node = dfs(root, x);\nint l = count(node->left), r = count(node->right);\nreturn max({l, r, n - l - r - 1}) > n / 2;\n}\n\nTreeNode* dfs(TreeNode* root, int x) {\nif (!root || root->val == x) {\nreturn root;\n}\nauto node = dfs(root->left, x);\nreturn node ? node : dfs(root->right, x);\n}\n\nint count(TreeNode* root) {\nif (!root) {\nreturn 0;\n}\nreturn 1 + count(root->left) + count(root->right);\n}\n};\n"]}, {"leetCodeID": "1190", "level": "middle", "question_description": "You are given a string s that consists of lower case English letters and brackets.\nReverse the strings in each pair of matching parentheses, starting from the innermost one.\nYour result should not contain any brackets.", "examples": ["Example 1:\nInput: s = &quot;(abcd)&quot;\nOutput: &quot;dcba&quot;\n", "Example 2:\nInput: s = &quot;(u(love)i)&quot;\nOutput: &quot;iloveu&quot;\nExplanation: The substring &quot;love&quot; is reversed first, then the whole string is reversed.\n", "Example 3:\nInput: s = &quot;(ed(et(oc))el)&quot;\nOutput: &quot;leetcode&quot;\nExplanation: First, we reverse the substring &quot;oc&quot;, then &quot;etco&quot;, and finally, the whole string.\n"], "constraints": "\nConstraints:\n1 <= s.length <= 2000\ns only contains lower case English characters and parentheses.\nIt is guaranteed that all parentheses are balanced.\n", "java_context": "\nclass Solution {\n    public String reverseParentheses(String s) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} s\n* @return {string}\n*/\nvar reverseParentheses = function (s) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    string reverseParentheses(string s) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic String reverseParentheses(String s) {\nint n = s.length();\nint[] d = new int[n];\nDeque<Integer> stk = new ArrayDeque<>();\nfor (int i = 0; i < n; ++i) {\nif (s.charAt(i) == '(') {\nstk.push(i);\n} else if (s.charAt(i) == ')') {\nint j = stk.pop();\nd[i] = j;\nd[j] = i;\n}\n}\nStringBuilder ans = new StringBuilder();\nint i = 0, x = 1;\nwhile (i < n) {\nif (s.charAt(i) == '(' || s.charAt(i) == ')') {\ni = d[i];\nx = -x;\n} else {\nans.append(s.charAt(i));\n}\ni += x;\n}\nreturn ans.toString();\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} s\n* @return {string}\n*/\nvar reverseParentheses = function (s) {\nconst n = s.length;\nconst d = new Array(n).fill(0);\nconst stk = [];\nfor (let i = 0; i < n; ++i) {\nif (s[i] == '(') {\nstk.push(i);\n} else if (s[i] == ')') {\nconst j = stk.pop();\nd[i] = j;\nd[j] = i;\n}\n}\nlet i = 0;\nlet x = 1;\nconst ans = [];\nwhile (i < n) {\nconst c = s.charAt(i);\nif (c == '(' || c == ')') {\ni = d[i];\nx = -x;\n} else {\nans.push(c);\n}\ni += x;\n}\nreturn ans.join('');\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nstring reverseParentheses(string s) {\nstring stk;\nfor (char& c : s) {\nif (c == ')') {\nstring t;\nwhile (stk.back() != '(') {\nt.push_back(stk.back());\nstk.pop_back();\n}\nstk.pop_back();\nstk += t;\n} else {\nstk.push_back(c);\n}\n}\nreturn stk;\n}\n};\n", "\nclass Solution {\npublic:\nstring reverseParentheses(string s) {\nint n = s.size();\nvector<int> d(n);\nstack<int> stk;\nfor (int i = 0; i < n; ++i) {\nif (s[i] == '(') {\nstk.push(i);\n} else if (s[i] == ')') {\nint j = stk.top();\nstk.pop();\nd[i] = j;\nd[j] = i;\n}\n}\nint i = 0, x = 1;\nstring ans;\nwhile (i < n) {\nif (s[i] == '(' || s[i] == ')') {\ni = d[i];\nx = -x;\n} else {\nans.push_back(s[i]);\n}\ni += x;\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1218", "level": "middle", "question_description": "Given an integer array arr and an integer difference, return the length of the longest subsequence in arr which is an arithmetic sequence such that the difference between adjacent elements in the subsequence equals difference.\nA subsequence is a sequence that can be derived from arr by deleting some or no elements without changing the order of the remaining elements.", "examples": ["Example 1:\nInput: arr = [1,2,3,4], difference = 1\nOutput: 4\nExplanation: The longest arithmetic subsequence is [1,2,3,4].", "Example 2:\nInput: arr = [1,3,5,7], difference = 1\nOutput: 1\nExplanation: The longest arithmetic subsequence is any single element.\n", "Example 3:\nInput: arr = [1,5,7,8,5,3,4,2,1], difference = -2\nOutput: 4\nExplanation: The longest arithmetic subsequence is [7,5,3,1].\n"], "constraints": "\nConstraints:\n1 <= arr.length <= 105\n-104 <= arr[i], difference <= 104\n", "java_context": "\nclass Solution {\n    public int longestSubsequence(int[] arr, int difference) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} arr\n* @param {number} difference\n* @return {number}\n*/\nvar longestSubsequence = function (arr, difference) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int longestSubsequence(vector<int>& arr, int difference) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int longestSubsequence(int[] arr, int difference) {\nMap<Integer, Integer> f = new HashMap<>();\nint ans = 0;\nfor (int x : arr) {\nf.put(x, f.getOrDefault(x - difference, 0) + 1);\nans = Math.max(ans, f.get(x));\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} arr\n* @param {number} difference\n* @return {number}\n*/\nvar longestSubsequence = function (arr, difference) {\nconst f = new Map();\nfor (const x of arr) {\nf.set(x, (f.get(x - difference) || 0) + 1);\n}\nreturn Math.max(...f.values());\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint longestSubsequence(vector<int>& arr, int difference) {\nunordered_map<int, int> f;\nint ans = 0;\nfor (int x : arr) {\nf[x] = f[x - difference] + 1;\nans = max(ans, f[x]);\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1219", "level": "middle", "question_description": "In a gold mine grid of size m x n, each cell in this mine has an integer representing the amount of gold in that cell, 0 if it is empty.\nReturn the maximum amount of gold you can collect under the conditions:\nEvery time you are located in a cell you will collect all the gold in that cell.\nFrom your position, you can walk one step to the left, right, up, or down.\nYou can&#39;t visit the same cell more than once.\nNever visit a cell with 0 gold.\nYou can start and stop collecting gold from any position in the grid that has some gold.", "examples": ["Example 1:\nInput: grid = [[0,6,0],[5,8,7],[0,9,0]]\nOutput: 24\nExplanation:\n[[0,6,0],\n[5,8,7],\n[0,9,0]]\nPath to get the maximum gold, 9 -&gt; 8 -&gt; 7.\n", "Example 2:\nInput: grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]\nOutput: 28\nExplanation:\n[[1,0,7],\n[2,0,6],\n[3,4,5],\n[0,3,0],\n[9,0,20]]\nPath to get the maximum gold, 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7.\n"], "constraints": "\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 15\n0 <= grid[i][j] <= 100\nThere are at most 25 cells containing gold.\n", "java_context": "\nclass Solution {\n    private final int[] dirs = {-1, 0, 1, 0, -1};\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[][]} grid\n* @return {number}\n*/\nvar getMaximumGold = function (grid) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int getMaximumGold(vector<vector<int>>& grid) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\nprivate final int[] dirs = {-1, 0, 1, 0, -1};\nprivate int[][] grid;\nprivate int m;\nprivate int n;\n\npublic int getMaximumGold(int[][] grid) {\nm = grid.length;\nn = grid[0].length;\nthis.grid = grid;\nint ans = 0;\nfor (int i = 0; i < m; ++i) {\nfor (int j = 0; j < n; ++j) {\nans = Math.max(ans, dfs(i, j));\n}\n}\nreturn ans;\n}\n\nprivate int dfs(int i, int j) {\nif (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == 0) {\nreturn 0;\n}\nint v = grid[i][j];\ngrid[i][j] = 0;\nint ans = 0;\nfor (int k = 0; k < 4; ++k) {\nans = Math.max(ans, v + dfs(i + dirs[k], j + dirs[k + 1]));\n}\ngrid[i][j] = v;\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[][]} grid\n* @return {number}\n*/\nvar getMaximumGold = function (grid) {\nconst m = grid.length;\nconst n = grid[0].length;\nconst dfs = (i, j) => {\nif (i < 0 || i >= m || j < 0 || j >= n || !grid[i][j]) {\nreturn 0;\n}\nconst v = grid[i][j];\ngrid[i][j] = 0;\nlet ans = v + Math.max(dfs(i - 1, j), dfs(i + 1, j), dfs(i, j - 1), dfs(i, j + 1));\ngrid[i][j] = v;\nreturn ans;\n};\nlet ans = 0;\nfor (let i = 0; i < m; i++) {\nfor (let j = 0; j < n; j++) {\nans = Math.max(ans, dfs(i, j));\n}\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint getMaximumGold(vector<vector<int>>& grid) {\nint m = grid.size(), n = grid[0].size();\nfunction<int(int, int)> dfs = [&](int i, int j) {\nif (i < 0 || i >= m || j < 0 || j >= n || !grid[i][j]) {\nreturn 0;\n}\nint v = grid[i][j];\ngrid[i][j] = 0;\nint ans = v + max({dfs(i - 1, j), dfs(i + 1, j), dfs(i, j - 1), dfs(i, j + 1)});\ngrid[i][j] = v;\nreturn ans;\n};\nint ans = 0;\nfor (int i = 0; i < m; ++i) {\nfor (int j = 0; j < n; ++j) {\nans = max(ans, dfs(i, j));\n}\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1247", "level": "middle", "question_description": "You are given two strings s1 and s2 of equal length consisting of letters &quot;x&quot; and &quot;y&quot; only. Your task is to make these two strings equal to each other. You can swap any two characters that belong to different strings, which means: swap s1[i] and s2[j].\nReturn the minimum number of swaps required to make s1 and s2 equal, or return -1 if it is impossible to do so.", "examples": ["Example 1:\nInput: s1 = &quot;xx&quot;, s2 = &quot;yy&quot;\nOutput: 1\nExplanation: Swap s1[0] and s2[1], s1 = &quot;yx&quot;, s2 = &quot;yx&quot;.\n", "Example 2:\nInput: s1 = &quot;xy&quot;, s2 = &quot;yx&quot;\nOutput: 2\nExplanation: Swap s1[0] and s2[0], s1 = &quot;yy&quot;, s2 = &quot;xx&quot;.\nSwap s1[0] and s2[1], s1 = &quot;xy&quot;, s2 = &quot;xy&quot;.\nNote that you cannot swap s1[0] and s1[1] to make s1 equal to &quot;yx&quot;, cause we can only swap chars in different strings.\n", "Example 3:\nInput: s1 = &quot;xx&quot;, s2 = &quot;xy&quot;\nOutput: -1\n"], "constraints": "\nConstraints:\n1 <= s1.length, s2.length <= 1000\ns1.length == s2.length\ns1, s2 only contain &#39;x&#39; or &#39;y&#39;.\n", "java_context": "\nclass Solution {\n    public int minimumSwap(String s1, String s2) {\n        // your code\n    }\n}", "js_context": "\nvar minimumSwap = function (s1, s2) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int minimumSwap(string s1, string s2) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int minimumSwap(String s1, String s2) {\nint xy = 0, yx = 0;\nfor (int i = 0; i < s1.length(); ++i) {\nchar a = s1.charAt(i), b = s2.charAt(i);\nif (a < b) {\n++xy;\n}\nif (a > b) {\n++yx;\n}\n}\nif ((xy + yx) % 2 == 1) {\nreturn -1;\n}\nreturn xy / 2 + yx / 2 + xy % 2 + yx % 2;\n}\n}\n"], "js_solutions": ["\nvar minimumSwap = function (s1, s2) {\nlet xy = 0,\nyx = 0;\nfor (let i = 0; i < s1.length; ++i) {\nconst a = s1[i],\nb = s2[i];\nif (a < b) {\n++xy;\n}\nif (a > b) {\n++yx;\n}\n}\nif ((xy + yx) % 2 === 1) {\nreturn -1;\n}\nreturn Math.floor(xy / 2) + Math.floor(yx / 2) + (xy % 2) + (yx % 2);\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint minimumSwap(string s1, string s2) {\nint xy = 0, yx = 0;\nfor (int i = 0; i < s1.size(); ++i) {\nchar a = s1[i], b = s2[i];\nxy += a < b;\nyx += a > b;\n}\nif ((xy + yx) % 2) {\nreturn -1;\n}\nreturn xy / 2 + yx / 2 + xy % 2 + yx % 2;\n}\n};\n"]}, {"leetCodeID": "1283", "level": "middle", "question_description": "Given an array of integers nums and an integer threshold, we will choose a positive integer divisor, divide all the array by it, and sum the division&#39;s result. Find the smallest divisor such that the result mentioned above is less than or equal to threshold.\nEach result of the division is rounded to the nearest integer greater than or equal to that element. (For example: 7/3 = 3 and 10/2 = 5).\nThe test cases are generated so that there will be an answer.", "examples": ["Example 1:\nInput: nums = [1,2,5,9], threshold = 6\nOutput: 5\nExplanation: We can get a sum to 17 (1+2+5+9) if the divisor is 1.\nIf the divisor is 4 we can get a sum of 7 (1+1+2+3) and if the divisor is 5 the sum will be 5 (1+1+1+2).\n", "Example 2:\nInput: nums = [44,22,33,11,1], threshold = 5\nOutput: 44\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 5 * 104\n1 <= nums[i] <= 106\nnums.length <= threshold <= 106\n", "java_context": "\nclass Solution {\n    public int smallestDivisor(int[] nums, int threshold) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @param {number} threshold\n* @return {number}\n*/\nvar smallestDivisor = function (nums, threshold) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int smallestDivisor(vector<int>& nums, int threshold) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int smallestDivisor(int[] nums, int threshold) {\nint l = 1, r = 1000000;\nwhile (l < r) {\nint mid = (l + r) >> 1;\nint s = 0;\nfor (int x : nums) {\ns += (x + mid - 1) / mid;\n}\nif (s <= threshold) {\nr = mid;\n} else {\nl = mid + 1;\n}\n}\nreturn l;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @param {number} threshold\n* @return {number}\n*/\nvar smallestDivisor = function (nums, threshold) {\nlet l = 1;\nlet r = Math.max(...nums);\nwhile (l < r) {\nconst mid = (l + r) >> 1;\nlet s = 0;\nfor (const x of nums) {\ns += Math.ceil(x / mid);\n}\nif (s <= threshold) {\nr = mid;\n} else {\nl = mid + 1;\n}\n}\nreturn l;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint smallestDivisor(vector<int>& nums, int threshold) {\nint l = 1;\nint r = *max_element(nums.begin(), nums.end());\nwhile (l < r) {\nint mid = (l + r) >> 1;\nint s = 0;\nfor (int x : nums) {\ns += (x + mid - 1) / mid;\n}\nif (s <= threshold) {\nr = mid;\n} else {\nl = mid + 1;\n}\n}\nreturn l;\n}\n};\n"]}, {"leetCodeID": "1310", "level": "middle", "question_description": "You are given an array arr of positive integers. You are also given the array queries where queries[i] = [lefti, righti].\nFor each query i compute the XOR of elements from lefti to righti (that is, arr[lefti] XOR arr[lefti + 1] XOR ... XOR arr[righti] ).\nReturn an array answer where answer[i] is the answer to the ith query.", "examples": ["Example 1:\nInput: arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]]\nOutput: [2,7,14,8]\nExplanation:\nThe binary representation of the elements in the array are:\n1 = 0001\n3 = 0011\n4 = 0100\n8 = 1000\nThe XOR values for queries are:\n[0,1] = 1 xor 3 = 2\n[1,2] = 3 xor 4 = 7\n[0,3] = 1 xor 3 xor 4 xor 8 = 14\n[3,3] = 8\n", "Example 2:\nInput: arr = [4,8,2,10], queries = [[2,3],[1,3],[0,0],[0,3]]\nOutput: [8,0,4,4]\n"], "constraints": "\nConstraints:\n1 <= arr.length, queries.length <= 3 * 104\n1 <= arr[i] <= 109\nqueries[i].length == 2\n0 <= lefti <= righti < arr.length\n", "java_context": "\nclass Solution {\n    public int[] xorQueries(int[] arr, int[][] queries) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} arr\n* @param {number[][]} queries\n* @return {number[]}\n*/\nvar xorQueries = function (arr, queries) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> xorQueries(vector<int>& arr, vector<vector<int>>& queries) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int[] xorQueries(int[] arr, int[][] queries) {\nint n = arr.length;\nint[] s = new int[n + 1];\nfor (int i = 1; i <= n; ++i) {\ns[i] = s[i - 1] ^ arr[i - 1];\n}\nint m = queries.length;\nint[] ans = new int[m];\nfor (int i = 0; i < m; ++i) {\nint l = queries[i][0], r = queries[i][1];\nans[i] = s[r + 1] ^ s[l];\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} arr\n* @param {number[][]} queries\n* @return {number[]}\n*/\nvar xorQueries = function (arr, queries) {\nconst n = arr.length;\nconst s = new Array(n + 1).fill(0);\nfor (let i = 0; i < n; ++i) {\ns[i + 1] = s[i] ^ arr[i];\n}\nconst ans = [];\nfor (const [l, r] of queries) {\nans.push(s[r + 1] ^ s[l]);\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> xorQueries(vector<int>& arr, vector<vector<int>>& queries) {\nint n = arr.size();\nint s[n + 1];\nmemset(s, 0, sizeof(s));\nfor (int i = 1; i <= n; ++i) {\ns[i] = s[i - 1] ^ arr[i - 1];\n}\nvector<int> ans;\nfor (auto& q : queries) {\nint l = q[0], r = q[1];\nans.push_back(s[r + 1] ^ s[l]);\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1347", "level": "middle", "question_description": "You are given two strings of the same length s and t. In one step you can choose any character of t and replace it with another character.\nReturn the minimum number of steps to make t an anagram of s.\nAn Anagram of a string is a string that contains the same characters with a different (or the same) ordering.", "examples": ["Example 1:\nInput: s = &quot;bab&quot;, t = &quot;aba&quot;\nOutput: 1\nExplanation: Replace the first &#39;a&#39; in t with b, t = &quot;bba&quot; which is anagram of s.\n", "Example 2:\nInput: s = &quot;leetcode&quot;, t = &quot;practice&quot;\nOutput: 5\nExplanation: Replace &#39;p&#39;, &#39;r&#39;, &#39;a&#39;, &#39;i&#39; and &#39;c&#39; from t with proper characters to make t anagram of s.\n", "Example 3:\nInput: s = &quot;anagram&quot;, t = &quot;mangaar&quot;\nOutput: 0\nExplanation: &quot;anagram&quot; and &quot;mangaar&quot; are anagrams.\n"], "constraints": "\nConstraints:\n1 <= s.length <= 5 * 104\ns.length == t.length\ns and t consist of lowercase English letters only.\n", "java_context": "\nclass Solution {\n    public int minSteps(String s, String t) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} s\n* @param {string} t\n* @return {number}\n*/\nvar minSteps = function (s, t) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int minSteps(string s, string t) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int minSteps(String s, String t) {\nint[] cnt = new int[26];\nfor (int i = 0; i < s.length(); ++i) {\n++cnt[s.charAt(i) - 'a'];\n}\nint ans = 0;\nfor (int i = 0; i < t.length(); ++i) {\nif (--cnt[t.charAt(i) - 'a'] < 0) {\n++ans;\n}\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} s\n* @param {string} t\n* @return {number}\n*/\nvar minSteps = function (s, t) {\nconst cnt = new Array(26).fill(0);\nfor (const c of s) {\nconst i = c.charCodeAt(0) - 'a'.charCodeAt(0);\n++cnt[i];\n}\nlet ans = 0;\nfor (const c of t) {\nconst i = c.charCodeAt(0) - 'a'.charCodeAt(0);\nans += --cnt[i] < 0;\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint minSteps(string s, string t) {\nint cnt[26]{};\nfor (char& c : s) ++cnt[c - 'a'];\nint ans = 0;\nfor (char& c : t) {\nans += --cnt[c - 'a'] < 0;\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1423", "level": "middle", "question_description": "There are several cards arranged in a row, and each card has an associated number of points. The points are given in the integer array cardPoints.\nIn one step, you can take one card from the beginning or from the end of the row. You have to take exactly k cards.\nYour score is the sum of the points of the cards you have taken.\nGiven the integer array cardPoints and the integer k, return the maximum score you can obtain.", "examples": ["Example 1:\nInput: cardPoints = [1,2,3,4,5,6,1], k = 3\nOutput: 12\nExplanation: After the first step, your score will always be 1. However, choosing the rightmost card first will maximize your total score. The optimal strategy is to take the three cards on the right, giving a final score of 1 + 6 + 5 = 12.\n", "Example 2:\nInput: cardPoints = [2,2,2], k = 2\nOutput: 4\nExplanation: Regardless of which two cards you take, your score will always be 4.\n", "Example 3:\nInput: cardPoints = [9,7,7,9,7,7,9], k = 7\nOutput: 55\nExplanation: You have to take all the cards. Your score is the sum of points of all cards.\n"], "constraints": "\nConstraints:\n1 <= cardPoints.length <= 105\n1 <= cardPoints[i] <= 104\n1 <= k <= cardPoints.length\n", "java_context": "\nclass Solution {\n    public int maxScore(int[] cardPoints, int k) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} cardPoints\n* @param {number} k\n* @return {number}\n*/\nvar maxScore = function (cardPoints, k) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int maxScore(vector<int>& cardPoints, int k) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int maxScore(int[] cardPoints, int k) {\nint s = 0, n = cardPoints.length;\nfor (int i = n - k; i < n; ++i) {\ns += cardPoints[i];\n}\nint ans = s;\nfor (int i = 0; i < k; ++i) {\ns += cardPoints[i] - cardPoints[n - k + i];\nans = Math.max(ans, s);\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} cardPoints\n* @param {number} k\n* @return {number}\n*/\nvar maxScore = function (cardPoints, k) {\nconst n = cardPoints.length;\nlet s = cardPoints.slice(-k).reduce((a, b) => a + b);\nlet ans = s;\nfor (let i = 0; i < k; ++i) {\ns += cardPoints[i] - cardPoints[n - k + i];\nans = Math.max(ans, s);\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint maxScore(vector<int>& cardPoints, int k) {\nint n = cardPoints.size();\nint s = accumulate(cardPoints.end() - k, cardPoints.end(), 0);\nint ans = s;\nfor (int i = 0; i < k; ++i) {\ns += cardPoints[i] - cardPoints[n - k + i];\nans = max(ans, s);\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1451", "level": "middle", "question_description": "Given a sentence text (A sentence is a string of space-separated words) in the following format:\nFirst letter is in upper case.\nEach word in text are separated by a single space.\nYour task is to rearrange the words in text such that all words are rearranged in an increasing order of their lengths. If two words have the same length, arrange them in their original order.\nReturn the new text following the format shown above.", "examples": ["Example 1:\nInput: text = &quot;Leetcode is cool&quot;\nOutput: &quot;Is cool leetcode&quot;\nExplanation: There are 3 words, &quot;Leetcode&quot; of length 8, &quot;is&quot; of length 2 and &quot;cool&quot; of length 4.\nOutput is ordered by length and the new first word starts with capital letter.\n", "Example 2:\nInput: text = &quot;Keep calm and code on&quot;\nOutput: &quot;On and keep calm code&quot;\nExplanation: Output is ordered as follows:\n&quot;On&quot; 2 letters.\n&quot;and&quot; 3 letters.\n&quot;keep&quot; 4 letters in case of tie order by position in original text.\n&quot;calm&quot; 4 letters.\n&quot;code&quot; 4 letters.\n", "Example 3:\nInput: text = &quot;To be or not to be&quot;\nOutput: &quot;To be or to be not&quot;\n"], "constraints": "\nConstraints:\ntext begins with a capital letter and then contains lowercase letters and single space between words.\n1 <= text.length <= 10^5\n", "java_context": "\nclass Solution {\n    public String arrangeWords(String text) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} text\n* @return {string}\n*/\nvar arrangeWords = function (text) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    string arrangeWords(string text) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic String arrangeWords(String text) {\nString[] words = text.split(\" \");\nwords[0] = words[0].toLowerCase();\nArrays.sort(words, Comparator.comparingInt(String::length));\nwords[0] = words[0].substring(0, 1).toUpperCase() + words[0].substring(1);\nreturn String.join(\" \", words);\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} text\n* @return {string}\n*/\nvar arrangeWords = function (text) {\nlet arr = text.split(' ');\narr[0] = arr[0].toLocaleLowerCase();\narr.sort((a, b) => a.length - b.length);\narr[0] = arr[0][0].toLocaleUpperCase() + arr[0].substr(1);\nreturn arr.join(' ');\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nstring arrangeWords(string text) {\nvector<string> words;\nstringstream ss(text);\nstring t;\nwhile (ss >> t) {\nwords.push_back(t);\n}\nwords[0][0] = tolower(words[0][0]);\nstable_sort(words.begin(), words.end(), [](const string& a, const string& b) {\nreturn a.size() < b.size();\n});\nstring ans = \"\";\nfor (auto& s : words) {\nans += s + \" \";\n}\nans.pop_back();\nans[0] = toupper(ans[0]);\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1552", "level": "middle", "question_description": "In the universe Earth C-137, Rick discovered a special form of magnetic force between two balls if they are put in his new invented basket. Rick has n empty baskets, the ith basket is at position[i], Morty has m balls and needs to distribute the balls into the baskets such that the minimum magnetic force between any two balls is maximum.\nRick stated that magnetic force between two different balls at positions x and y is |x - y|.\nGiven the integer array position and the integer m. Return the required force.", "examples": ["Example 1:\n\n\nInput: position = [1,2,3,4,7], m = 3\nOutput: 3\nExplanation: Distributing the 3 balls into baskets 1, 4 and 7 will make the magnetic force between ball pairs [3, 3, 6]. The minimum magnetic force is 3. We cannot achieve a larger minimum magnetic force than 3.\n\n\nExample 2:\nInput: position = [5,4,3,2,1,1000000000], m = 2\nOutput: 999999999\nExplanation: We can use baskets 1 and 1000000000.\n"], "constraints": "\nConstraints:\nn == position.length\n2 <= n <= 105\n1 <= position[i] <= 109\nAll integers in position are distinct.\n2 <= m <= position.length\n", "java_context": "\nclass Solution {\n    public int maxDistance(int[] position, int m) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} position\n* @param {number} m\n* @return {number}\n*/\nvar maxDistance = function (position, m) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int maxDistance(vector<int>& position, int m) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int maxDistance(int[] position, int m) {\nArrays.sort(position);\nint left = 1, right = position[position.length - 1];\nwhile (left < right) {\nint mid = (left + right + 1) >>> 1;\nif (check(position, mid, m)) {\nleft = mid;\n} else {\nright = mid - 1;\n}\n}\nreturn left;\n}\n\nprivate boolean check(int[] position, int f, int m) {\nint prev = position[0];\nint cnt = 1;\nfor (int i = 1; i < position.length; ++i) {\nint curr = position[i];\nif (curr - prev >= f) {\nprev = curr;\n++cnt;\n}\n}\nreturn cnt >= m;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} position\n* @param {number} m\n* @return {number}\n*/\nvar maxDistance = function (position, m) {\nposition.sort((a, b) => {\nreturn a - b;\n});\nlet left = 1,\nright = position[position.length - 1];\nconst check = function (f) {\nlet prev = position[0];\nlet cnt = 1;\nfor (let i = 1; i < position.length; ++i) {\nconst curr = position[i];\nif (curr - prev >= f) {\nprev = curr;\n++cnt;\n}\n}\nreturn cnt >= m;\n};\nwhile (left < right) {\nconst mid = (left + right + 1) >> 1;\nif (check(mid)) {\nleft = mid;\n} else {\nright = mid - 1;\n}\n}\nreturn left;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint maxDistance(vector<int>& position, int m) {\nsort(position.begin(), position.end());\nint left = 1, right = position[position.size() - 1];\nwhile (left < right) {\nint mid = (left + right + 1) >> 1;\nif (check(position, mid, m))\nleft = mid;\nelse\nright = mid - 1;\n}\nreturn left;\n}\n\nbool check(vector<int>& position, int f, int m) {\nint prev = position[0];\nint cnt = 1;\nfor (int i = 1; i < position.size(); ++i) {\nint curr = position[i];\nif (curr - prev >= f) {\nprev = curr;\n++cnt;\n}\n}\nreturn cnt >= m;\n}\n};\n"]}, {"leetCodeID": "1559", "level": "middle", "question_description": "Given a 2D array of characters grid of size m x n, you need to find if there exists any cycle consisting of the same value in grid.\nA cycle is a path of length 4 or more in the grid that starts and ends at the same cell. From a given cell, you can move to one of the cells adjacent to it - in one of the four directions (up, down, left, or right), if it has the same value of the current cell.\nAlso, you cannot move to the cell that you visited in your last move. For example, the cycle (1, 1) -&gt; (1, 2) -&gt; (1, 1) is invalid because from (1, 2) we visited (1, 1) which was the last visited cell.\nReturn true if any cycle of the same value exists in grid, otherwise, return false.", "examples": ["Example 1:\n\n\nInput: grid = [[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;b&quot;,&quot;b&quot;,&quot;a&quot;],[&quot;a&quot;,&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]]\nOutput: true\nExplanation: There are two valid cycles shown in different colors in the image below:\n\n", "Example 2:\n\n\nInput: grid = [[&quot;c&quot;,&quot;c&quot;,&quot;c&quot;,&quot;a&quot;],[&quot;c&quot;,&quot;d&quot;,&quot;c&quot;,&quot;c&quot;],[&quot;c&quot;,&quot;c&quot;,&quot;e&quot;,&quot;c&quot;],[&quot;f&quot;,&quot;c&quot;,&quot;c&quot;,&quot;c&quot;]]\nOutput: true\nExplanation: There is only one valid cycle highlighted in the image below:\n\n", "Example 3:\n\n\nInput: grid = [[&quot;a&quot;,&quot;b&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;z&quot;,&quot;b&quot;],[&quot;b&quot;,&quot;b&quot;,&quot;a&quot;]]\nOutput: false\n"], "constraints": "\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 500\ngrid consists only of lowercase English letters.\n", "java_context": "\nclass Solution {\n    private int[] p;\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {character[][]} grid\n* @return {boolean}\n*/\nvar containsCycle = function (grid) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> p;\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\nprivate int[] p;\n\npublic boolean containsCycle(char[][] grid) {\nint m = grid.length;\nint n = grid[0].length;\np = new int[m * n];\nfor (int i = 0; i < p.length; ++i) {\np[i] = i;\n}\nint[] dirs = {0, 1, 0};\nfor (int i = 0; i < m; ++i) {\nfor (int j = 0; j < n; ++j) {\nfor (int k = 0; k < 2; ++k) {\nint x = i + dirs[k];\nint y = j + dirs[k + 1];\nif (x < m && y < n && grid[i][j] == grid[x][y]) {\nif (find(x * n + y) == find(i * n + j)) {\nreturn true;\n}\np[find(x * n + y)] = find(i * n + j);\n}\n}\n}\n}\nreturn false;\n}\n\nprivate int find(int x) {\nif (p[x] != x) {\np[x] = find(p[x]);\n}\nreturn p[x];\n}\n}\n"], "js_solutions": ["\n/**\n* @param {character[][]} grid\n* @return {boolean}\n*/\nvar containsCycle = function (grid) {\nconst m = grid.length;\nconst n = grid[0].length;\nlet p = Array.from({ length: m * n }, (_, i) => i);\nfunction find(x) {\nif (p[x] != x) {\np[x] = find(p[x]);\n}\nreturn p[x];\n}\nconst dirs = [0, 1, 0];\nfor (let i = 0; i < m; ++i) {\nfor (let j = 0; j < n; ++j) {\nfor (let k = 0; k < 2; ++k) {\nconst x = i + dirs[k];\nconst y = j + dirs[k + 1];\nif (x < m && y < n && grid[x][y] == grid[i][j]) {\nif (find(x * n + y) == find(i * n + j)) {\nreturn true;\n}\np[find(x * n + y)] = find(i * n + j);\n}\n}\n}\n}\nreturn false;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> p;\n\nbool containsCycle(vector<vector<char>>& grid) {\nint m = grid.size(), n = grid[0].size();\np.resize(m * n);\nfor (int i = 0; i < p.size(); ++i) p[i] = i;\nvector<int> dirs = {0, 1, 0};\nfor (int i = 0; i < m; ++i) {\nfor (int j = 0; j < n; ++j) {\nfor (int k = 0; k < 2; ++k) {\nint x = i + dirs[k], y = j + dirs[k + 1];\nif (x < m && y < n && grid[x][y] == grid[i][j]) {\nif (find(x * n + y) == find(i * n + j)) return 1;\np[find(x * n + y)] = find(i * n + j);\n}\n}\n}\n}\nreturn 0;\n}\n\nint find(int x) {\nif (p[x] != x) p[x] = find(p[x]);\nreturn p[x];\n}\n};\n"]}, {"leetCodeID": "1602", "level": "middle", "question_description": "Given the root of a binary tree and a node u in the tree, return the nearest node on the same level that is to the right of u, or return null if u is the rightmost node in its level.", "examples": [], "constraints": "\nConstraints:\nThe number of nodes in the tree is in the range [1, 105].\n1 <= Node.val <= 105\nAll values in the tree are distinct.\nu is a node in the binary tree rooted at root.\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\n    public TreeNode findNearestRightNode(TreeNode root, TreeNode u) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @param {TreeNode} u\n* @return {TreeNode}\n*/\nvar findNearestRightNode = function (root, u) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    TreeNode* findNearestRightNode(TreeNode* root, TreeNode* u) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\npublic TreeNode findNearestRightNode(TreeNode root, TreeNode u) {\nDeque<TreeNode> q = new ArrayDeque<>();\nq.offer(root);\nwhile (!q.isEmpty()) {\nfor (int i = q.size(); i > 0; --i) {\nroot = q.pollFirst();\nif (root == u) {\nreturn i > 1 ? q.peekFirst() : null;\n}\nif (root.left != null) {\nq.offer(root.left);\n}\nif (root.right != null) {\nq.offer(root.right);\n}\n}\n}\nreturn null;\n}\n}\n", "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\nprivate TreeNode u;\nprivate TreeNode ans;\nprivate int d;\n\npublic TreeNode findNearestRightNode(TreeNode root, TreeNode u) {\nthis.u = u;\ndfs(root, 1);\nreturn ans;\n}\n\nprivate void dfs(TreeNode root, int i) {\nif (root == null || ans != null) {\nreturn;\n}\nif (d == i) {\nans = root;\nreturn;\n}\nif (root == u) {\nd = i;\nreturn;\n}\ndfs(root.left, i + 1);\ndfs(root.right, i + 1);\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @param {TreeNode} u\n* @return {TreeNode}\n*/\nvar findNearestRightNode = function (root, u) {\nconst q = [root];\nwhile (q.length) {\nfor (let i = q.length; i; --i) {\nroot = q.shift();\nif (root == u) {\nreturn i > 1 ? q[0] : null;\n}\nif (root.left) {\nq.push(root.left);\n}\nif (root.right) {\nq.push(root.right);\n}\n}\n}\nreturn null;\n};\n", "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @param {TreeNode} u\n* @return {TreeNode}\n*/\nvar findNearestRightNode = function (root, u) {\nlet d = 0;\nlet ans = null;\nfunction dfs(root, i) {\nif (!root || ans) {\nreturn;\n}\nif (d == i) {\nans = root;\nreturn;\n}\nif (root == u) {\nd = i;\nreturn;\n}\ndfs(root.left, i + 1);\ndfs(root.right, i + 1);\n}\ndfs(root, 1);\nreturn ans;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nTreeNode* findNearestRightNode(TreeNode* root, TreeNode* u) {\nqueue<TreeNode*> q{{root}};\nwhile (q.size()) {\nfor (int i = q.size(); i; --i) {\nroot = q.front();\nq.pop();\nif (root == u) {\nreturn i > 1 ? q.front() : nullptr;\n}\nif (root->left) {\nq.push(root->left);\n}\nif (root->right) {\nq.push(root->right);\n}\n}\n}\nreturn nullptr;\n}\n};\n", "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nTreeNode* findNearestRightNode(TreeNode* root, TreeNode* u) {\nTreeNode* ans;\nint d = 0;\nfunction<void(TreeNode*, int)> dfs = [&](TreeNode* root, int i) {\nif (!root || ans) {\nreturn;\n}\nif (d == i) {\nans = root;\nreturn;\n}\nif (root == u) {\nd = i;\nreturn;\n}\ndfs(root->left, i + 1);\ndfs(root->right, i + 1);\n};\ndfs(root, 1);\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1605", "level": "middle", "question_description": "You are given two arrays rowSum and colSum of non-negative integers where rowSum[i] is the sum of the elements in the ith row and colSum[j] is the sum of the elements of the jth column of a 2D matrix. In other words, you do not know the elements of the matrix, but you do know the sums of each row and column.\nFind any matrix of non-negative integers of size rowSum.length x colSum.length that satisfies the rowSum and colSum requirements.\nReturn a 2D array representing any matrix that fulfills the requirements. It&#39;s guaranteed that at least one matrix that fulfills the requirements exists.", "examples": ["Example 1:\nInput: rowSum = [3,8], colSum = [4,7]\nOutput: [[3,0],\n[1,7]]\nExplanation:\n0th row: 3 + 0 = 3 == rowSum[0]\n1st row: 1 + 7 = 8 == rowSum[1]\n0th column: 3 + 1 = 4 == colSum[0]\n1st column: 0 + 7 = 7 == colSum[1]\nThe row and column sums match, and all matrix elements are non-negative.\nAnother possible matrix is: [[1,2],\n[3,5]]\n", "Example 2:\nInput: rowSum = [5,7,10], colSum = [8,6,8]\nOutput: [[0,5,0],\n[6,1,0],\n[2,0,8]]\n"], "constraints": "\nConstraints:\n1 <= rowSum.length, colSum.length <= 500\n0 <= rowSum[i], colSum[i] <= 108\nsum(rowSum) == sum(colSum)\n", "java_context": "\nclass Solution {\n    public int[][] restoreMatrix(int[] rowSum, int[] colSum) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} rowSum\n* @param {number[]} colSum\n* @return {number[][]}\n*/\nvar restoreMatrix = function (rowSum, colSum) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<vector<int>> restoreMatrix(vector<int>& rowSum, vector<int>& colSum) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int[][] restoreMatrix(int[] rowSum, int[] colSum) {\nint m = rowSum.length;\nint n = colSum.length;\nint[][] ans = new int[m][n];\nfor (int i = 0; i < m; ++i) {\nfor (int j = 0; j < n; ++j) {\nint x = Math.min(rowSum[i], colSum[j]);\nans[i][j] = x;\nrowSum[i] -= x;\ncolSum[j] -= x;\n}\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} rowSum\n* @param {number[]} colSum\n* @return {number[][]}\n*/\nvar restoreMatrix = function (rowSum, colSum) {\nconst m = rowSum.length;\nconst n = colSum.length;\nconst ans = Array.from(new Array(m), () => new Array(n).fill(0));\nfor (let i = 0; i < m; i++) {\nfor (let j = 0; j < n; j++) {\nconst x = Math.min(rowSum[i], colSum[j]);\nans[i][j] = x;\nrowSum[i] -= x;\ncolSum[j] -= x;\n}\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<vector<int>> restoreMatrix(vector<int>& rowSum, vector<int>& colSum) {\nint m = rowSum.size(), n = colSum.size();\nvector<vector<int>> ans(m, vector<int>(n));\nfor (int i = 0; i < m; ++i) {\nfor (int j = 0; j < n; ++j) {\nint x = min(rowSum[i], colSum[j]);\nans[i][j] = x;\nrowSum[i] -= x;\ncolSum[j] -= x;\n}\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1612", "level": "middle", "question_description": "A binary expression tree is a kind of binary tree used to represent arithmetic expressions. Each node of a binary expression tree has either zero or two children. Leaf nodes (nodes with 0 children) correspond to operands (variables), and internal nodes (nodes with two children) correspond to the operators. In this problem, we only consider the &#39;+&#39; operator (i.e. addition).\nYou are given the roots of two binary expression trees, root1 and root2. Return true if the two binary expression trees are equivalent. Otherwise, return false.\nTwo binary expression trees are equivalent if they evaluate to the same value regardless of what the variables are set to.", "examples": ["Example 1:\nInput: root1 = [x], root2 = [x]\nOutput: true\n", "Example 2:\n\n\nInput: root1 = [+,a,+,null,null,b,c], root2 = [+,+,a,b,c]\nOutput: true\nExplanation: a + (b + c) == (b + c) + a", "Example 3:\n\n\nInput: root1 = [+,a,+,null,null,b,c], root2 = [+,+,a,b,d]\nOutput: false\nExplanation: a + (b + c) != (b + d) + a\n"], "constraints": "\nConstraints:\nThe number of nodes in both trees are equal, odd and, in the range [1, 4999].\nNode.val is &#39;+&#39; or a lower-case English letter.\nIt&#39;s guaranteed that the tree given is a valid binary expression tree.\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* class Node {\n*     char val;\n*     Node left;\n*     Node right;\n*     Node() {this.val = ' ';}\n*     Node(char val) { this.val = val; }\n*     Node(char val, Node left, Node right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\n    private int[] cnt = new int[26];\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function Node(val, left, right) {\n*     this.val = (val===undefined ? \" \" : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {Node} root1\n* @param {Node} root2\n* @return {boolean}\n*/\nvar checkEquivalence = function (root1, root2) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct Node {\n*     char val;\n*     Node *left;\n*     Node *right;\n*     Node() : val(' '), left(nullptr), right(nullptr) {}\n*     Node(char x) : val(x), left(nullptr), right(nullptr) {}\n*     Node(char x, Node *left, Node *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    bool checkEquivalence(Node* root1, Node* root2) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* class Node {\n*     char val;\n*     Node left;\n*     Node right;\n*     Node() {this.val = ' ';}\n*     Node(char val) { this.val = val; }\n*     Node(char val, Node left, Node right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\nprivate int[] cnt = new int[26];\n\npublic boolean checkEquivalence(Node root1, Node root2) {\ndfs(root1, 1);\ndfs(root2, -1);\nfor (int x : cnt) {\nif (x != 0) {\nreturn false;\n}\n}\nreturn true;\n}\n\nprivate void dfs(Node root, int v) {\nif (root == null) {\nreturn;\n}\nif (root.val != '+') {\ncnt[root.val - 'a'] += v;\n}\ndfs(root.left, v);\ndfs(root.right, v);\n}\n}\n", "\n/**\n* Definition for a binary tree node.\n* class Node {\n*     char val;\n*     Node left;\n*     Node right;\n*     Node() {this.val = ' ';}\n*     Node(char val) { this.val = val; }\n*     Node(char val, Node left, Node right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\npublic boolean checkEquivalence(Node root1, Node root2) {\nint[] cnt1 = dfs(root1);\nint[] cnt2 = dfs(root2);\nfor (int i = 0; i < 26; ++i) {\nif (cnt1[i] != cnt2[i]) {\nreturn false;\n}\n}\nreturn true;\n}\n\nprivate int[] dfs(Node root) {\nint[] cnt = new int[26];\nif (root == null) {\nreturn cnt;\n}\nif (root.val == '+' || root.val == '-') {\nint[] l = dfs(root.left);\nint[] r = dfs(root.right);\nint k = root.val == '+' ? 1 : -1;\nfor (int i = 0; i < 26; ++i) {\ncnt[i] += l[i] + r[i] * k;\n}\n} else {\ncnt[root.val - 'a']++;\n}\nreturn cnt;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function Node(val, left, right) {\n*     this.val = (val===undefined ? \" \" : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {Node} root1\n* @param {Node} root2\n* @return {boolean}\n*/\nvar checkEquivalence = function (root1, root2) {\nconst cnt = new Array(26).fill(0);\nconst dfs = (root, v) => {\nif (!root) {\nreturn;\n}\nif (root.val !== '+') {\ncnt[root.val.charCodeAt(0) - 'a'.charCodeAt(0)] += v;\n}\ndfs(root.left, v);\ndfs(root.right, v);\n};\ndfs(root1, 1);\ndfs(root2, -1);\nfor (const x of cnt) {\nif (x) {\nreturn false;\n}\n}\nreturn true;\n};\n", "\n/**\n* Definition for a binary tree node.\n* function Node(val, left, right) {\n*     this.val = (val===undefined ? \" \" : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {Node} root1\n* @param {Node} root2\n* @return {boolean}\n*/\nvar checkEquivalence = function (root1, root2) {\nconst dfs = root => {\nconst cnt = new Array(26).fill(0);\nif (!root) {\nreturn cnt;\n}\nif (root.val === '+' || root.val === '-') {\nconst l = dfs(root.left);\nconst r = dfs(root.right);\nconst k = root.val === '+' ? 1 : -1;\nfor (let i = 0; i < 26; ++i) {\ncnt[i] = l[i] + k * r[i];\n}\n} else {\ncnt[root.val.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n}\nreturn cnt;\n};\nconst cnt1 = dfs(root1);\nconst cnt2 = dfs(root2);\nfor (let i = 0; i < 26; ++i) {\nif (cnt1[i] !== cnt2[i]) {\nreturn false;\n}\n}\nreturn true;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct Node {\n*     char val;\n*     Node *left;\n*     Node *right;\n*     Node() : val(' '), left(nullptr), right(nullptr) {}\n*     Node(char x) : val(x), left(nullptr), right(nullptr) {}\n*     Node(char x, Node *left, Node *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nbool checkEquivalence(Node* root1, Node* root2) {\nint cnt[26]{};\nfunction<void(Node*, int)> dfs = [&](Node* root, int v) {\nif (!root) {\nreturn;\n}\nif (root->val != '+') {\ncnt[root->val - 'a'] += v;\n}\ndfs(root->left, v);\ndfs(root->right, v);\n};\ndfs(root1, 1);\ndfs(root2, -1);\nfor (int& x : cnt) {\nif (x) {\nreturn false;\n}\n}\nreturn true;\n}\n};\n", "\n/**\n* Definition for a binary tree node.\n* struct Node {\n*     char val;\n*     Node *left;\n*     Node *right;\n*     Node() : val(' '), left(nullptr), right(nullptr) {}\n*     Node(char x) : val(x), left(nullptr), right(nullptr) {}\n*     Node(char x, Node *left, Node *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nbool checkEquivalence(Node* root1, Node* root2) {\nfunction<vector<int>(Node*)> dfs = [&](Node* root) -> vector<int> {\nvector<int> cnt(26);\nif (!root) {\nreturn cnt;\n}\nif (root->val == '+' || root->val == '-') {\nauto l = dfs(root->left);\nauto r = dfs(root->right);\nint k = root->val == '+' ? 1 : -1;\nfor (int i = 0; i < 26; ++i) {\ncnt[i] += l[i] + r[i] * k;\n}\n} else {\ncnt[root->val - 'a']++;\n}\nreturn cnt;\n};\nreturn dfs(root1) == dfs(root2);\n}\n};\n"]}, {"leetCodeID": "1618", "level": "middle", "question_description": "You are given a string text. We want to display text on a screen of width w and height h. You can choose any font size from array fonts, which contains the available font sizes in ascending order.\nYou can use the FontInfo interface to get the width and height of any character at any available font size.\nThe FontInfo interface is defined as such:\ninterface FontInfo {\n// Returns the width of character ch on the screen using font size fontSize.\n// O(1) per call\npublic int getWidth(int fontSize, char ch);\n// Returns the height of any character on the screen using font size fontSize.\n// O(1) per call\npublic int getHeight(int fontSize);\n}\nThe calculated width of text for some fontSize is the sum of every getWidth(fontSize, text[i]) call for each 0 &lt;= i &lt; text.length (0-indexed). The calculated height of text for some fontSize is getHeight(fontSize). Note that text is displayed on a single line.\nIt is guaranteed that FontInfo will return the same value if you call getHeight or getWidth with the same parameters.\nIt is also guaranteed that for any font size fontSize and any character ch:\ngetHeight(fontSize) &lt;= getHeight(fontSize+1)\ngetWidth(fontSize, ch) &lt;= getWidth(fontSize+1, ch)\nReturn the maximum font size you can use to display text on the screen. If text cannot fit on the display with any font size, return -1.", "examples": ["Example 1:\n\nInput: text = &quot;helloworld&quot;, w = 80, h = 20, fonts = [6,8,10,12,14,16,18,24,36]\n\nOutput: 6\n\n", "Example 2:\n\nInput: text = &quot;leetcode&quot;, w = 1000, h = 50, fonts = [1,2,4]\n\nOutput: 4\n\n", "Example 3:\n\nInput: text = &quot;easyquestion&quot;, w = 100, h = 100, fonts = [10,15,20,25]\n\nOutput: -1\n\n"], "constraints": "\nConstraints:\n1 <= text.length <= 50000\ntext contains only lowercase English letters.\n1 <= w <= 107\n1 <= h <= 104\n1 <= fonts.length <= 105\n1 <= fonts[i] <= 105\nfonts is sorted in ascending order and does not contain duplicates.\n", "java_context": "\n/**\n* // This is the FontInfo's API interface.\n* // You should not implement it, or speculate about its implementation\n* interface FontInfo {\n*     // Return the width of char ch when fontSize is used.\n*     public int getWidth(int fontSize, char ch) {}\n*     // Return Height of any char when fontSize is used.\n*     public int getHeight(int fontSize)\n* }\n*/\nclass Solution {\n    public int maxFont(String text, int w, int h, int[] fonts, FontInfo fontInfo) {\n        // your code\n    }\n}", "js_context": "\n/**\n* // This is the FontInfo's API interface.\n* // You should not implement it, or speculate about its implementation\n* function FontInfo() {\n*\n*\t\t@param {number} fontSize\n*\t\t@param {char} ch\n*     \t@return {number}\n*     \tthis.getWidth = function(fontSize, ch) {\n*      \t...\n*     \t};\n*\n*\t\t@param {number} fontSize\n*     \t@return {number}\n*     \tthis.getHeight = function(fontSize) {\n*      \t...\n*     \t};\n* };\n*/\n/**\n* @param {string} text\n* @param {number} w\n* @param {number} h\n* @param {number[]} fonts\n* @param {FontInfo} fontInfo\n* @return {number}\n*/\nvar maxFont = function (text, w, h, fonts, fontInfo) {\n    // your code\n};", "cpp_context": "\n/**\n* // This is the FontInfo's API interface.\n* // You should not implement it, or speculate about its implementation\n* class FontInfo {\n*   public:\n*     // Return the width of char ch when fontSize is used.\n*     int getWidth(int fontSize, char ch);\n*\n*     // Return Height of any char when fontSize is used.\n*     int getHeight(int fontSize)\n* };\n*/\nclass Solution {\npublic:\n    int maxFont(string text, int w, int h, vector<int>& fonts, FontInfo fontInfo) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* // This is the FontInfo's API interface.\n* // You should not implement it, or speculate about its implementation\n* interface FontInfo {\n*     // Return the width of char ch when fontSize is used.\n*     public int getWidth(int fontSize, char ch) {}\n*     // Return Height of any char when fontSize is used.\n*     public int getHeight(int fontSize)\n* }\n*/\nclass Solution {\npublic int maxFont(String text, int w, int h, int[] fonts, FontInfo fontInfo) {\nint left = 0, right = fonts.length - 1;\nwhile (left < right) {\nint mid = (left + right + 1) >> 1;\nif (check(text, fonts[mid], w, h, fontInfo)) {\nleft = mid;\n} else {\nright = mid - 1;\n}\n}\nreturn check(text, fonts[left], w, h, fontInfo) ? fonts[left] : -1;\n}\n\nprivate boolean check(String text, int size, int w, int h, FontInfo fontInfo) {\nif (fontInfo.getHeight(size) > h) {\nreturn false;\n}\nint width = 0;\nfor (char c : text.toCharArray()) {\nwidth += fontInfo.getWidth(size, c);\n}\nreturn width <= w;\n}\n}\n"], "js_solutions": ["\n/**\n* // This is the FontInfo's API interface.\n* // You should not implement it, or speculate about its implementation\n* function FontInfo() {\n*\n*\t\t@param {number} fontSize\n*\t\t@param {char} ch\n*     \t@return {number}\n*     \tthis.getWidth = function(fontSize, ch) {\n*      \t...\n*     \t};\n*\n*\t\t@param {number} fontSize\n*     \t@return {number}\n*     \tthis.getHeight = function(fontSize) {\n*      \t...\n*     \t};\n* };\n*/\n/**\n* @param {string} text\n* @param {number} w\n* @param {number} h\n* @param {number[]} fonts\n* @param {FontInfo} fontInfo\n* @return {number}\n*/\nvar maxFont = function (text, w, h, fonts, fontInfo) {\nconst check = function (size) {\nif (fontInfo.getHeight(size) > h) {\nreturn false;\n}\nlet width = 0;\nfor (const c of text) {\nwidth += fontInfo.getWidth(size, c);\n}\nreturn width <= w;\n};\nlet left = 0;\nlet right = fonts.length - 1;\nwhile (left < right) {\nconst mid = (left + right + 1) >> 1;\nif (check(fonts[mid])) {\nleft = mid;\n} else {\nright = mid - 1;\n}\n}\nreturn check(fonts[left]) ? fonts[left] : -1;\n};\n"], "cpp_solutions": ["\n/**\n* // This is the FontInfo's API interface.\n* // You should not implement it, or speculate about its implementation\n* class FontInfo {\n*   public:\n*     // Return the width of char ch when fontSize is used.\n*     int getWidth(int fontSize, char ch);\n*\n*     // Return Height of any char when fontSize is used.\n*     int getHeight(int fontSize)\n* };\n*/\nclass Solution {\npublic:\nint maxFont(string text, int w, int h, vector<int>& fonts, FontInfo fontInfo) {\nauto check = [&](int size) {\nif (fontInfo.getHeight(size) > h) return false;\nint width = 0;\nfor (char& c : text) {\nwidth += fontInfo.getWidth(size, c);\n}\nreturn width <= w;\n};\nint left = 0, right = fonts.size() - 1;\nwhile (left < right) {\nint mid = (left + right + 1) >> 1;\nif (check(fonts[mid])) {\nleft = mid;\n} else {\nright = mid - 1;\n}\n}\nreturn check(fonts[left]) ? fonts[left] : -1;\n}\n};\n"]}, {"leetCodeID": "1626", "level": "middle", "question_description": "You are the manager of a basketball team. For the upcoming tournament, you want to choose the team with the highest overall score. The score of the team is the sum of scores of all the players in the team.\nHowever, the basketball team is not allowed to have conflicts. A conflict exists if a younger player has a strictly higher score than an older player. A conflict does not occur between players of the same age.\nGiven two lists, scores and ages, where each scores[i] and ages[i] represents the score and age of the ith player, respectively, return the highest overall score of all possible basketball teams.", "examples": ["Example 1:\nInput: scores = [1,3,5,10,15], ages = [1,2,3,4,5]\nOutput: 34\nExplanation:&nbsp;You can choose all the players.\n", "Example 2:\nInput: scores = [4,5,6,5], ages = [2,1,2,1]\nOutput: 16\nExplanation:&nbsp;It is best to choose the last 3 players. Notice that you are allowed to choose multiple people of the same age.\n", "Example 3:\nInput: scores = [1,2,3,5], ages = [8,9,10,1]\nOutput: 6\nExplanation:&nbsp;It is best to choose the first 3 players.\n"], "constraints": "\nConstraints:\n1 <= scores.length, ages.length <= 1000\nscores.length == ages.length\n1 <= scores[i] <= 106\n1 <= ages[i] <= 1000\n", "java_context": "\nclass Solution {\n    public int bestTeamScore(int[] scores, int[] ages) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} scores\n* @param {number[]} ages\n* @return {number}\n*/\nvar bestTeamScore = function (scores, ages) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int bestTeamScore(vector<int>& scores, vector<int>& ages) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int bestTeamScore(int[] scores, int[] ages) {\nint n = ages.length;\nint[][] arr = new int[n][2];\nfor (int i = 0; i < n; ++i) {\narr[i] = new int[] {scores[i], ages[i]};\n}\nArrays.sort(arr, (a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\nint[] f = new int[n];\nint ans = 0;\nfor (int i = 0; i < n; ++i) {\nfor (int j = 0; j < i; ++j) {\nif (arr[i][1] >= arr[j][1]) {\nf[i] = Math.max(f[i], f[j]);\n}\n}\nf[i] += arr[i][0];\nans = Math.max(ans, f[i]);\n}\nreturn ans;\n}\n}\n", "\nclass BinaryIndexedTree {\nprivate int n;\nprivate int[] c;\n\npublic BinaryIndexedTree(int n) {\nthis.n = n;\nc = new int[n + 1];\n}\n\npublic void update(int x, int val) {\nwhile (x <= n) {\nc[x] = Math.max(c[x], val);\nx += x & -x;\n}\n}\n\npublic int query(int x) {\nint s = 0;\nwhile (x > 0) {\ns = Math.max(s, c[x]);\nx -= x & -x;\n}\nreturn s;\n}\n}\n\nclass Solution {\npublic int bestTeamScore(int[] scores, int[] ages) {\nint n = ages.length;\nint[][] arr = new int[n][2];\nfor (int i = 0; i < n; ++i) {\narr[i] = new int[] {scores[i], ages[i]};\n}\nArrays.sort(arr, (a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\nint m = 0;\nfor (int age : ages) {\nm = Math.max(m, age);\n}\nBinaryIndexedTree tree = new BinaryIndexedTree(m);\nfor (int[] x : arr) {\ntree.update(x[1], x[0] + tree.query(x[1]));\n}\nreturn tree.query(m);\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} scores\n* @param {number[]} ages\n* @return {number}\n*/\nvar bestTeamScore = function (scores, ages) {\nconst arr = ages.map((age, i) => [age, scores[i]]);\narr.sort((a, b) => (a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]));\nconst n = arr.length;\nconst f = new Array(n).fill(0);\nfor (let i = 0; i < n; ++i) {\nfor (let j = 0; j < i; ++j) {\nif (arr[i][1] >= arr[j][1]) {\nf[i] = Math.max(f[i], f[j]);\n}\n}\nf[i] += arr[i][1];\n}\nreturn Math.max(...f);\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint bestTeamScore(vector<int>& scores, vector<int>& ages) {\nint n = ages.size();\nvector<pair<int, int>> arr(n);\nfor (int i = 0; i < n; ++i) {\narr[i] = {scores[i], ages[i]};\n}\nsort(arr.begin(), arr.end());\nvector<int> f(n);\nfor (int i = 0; i < n; ++i) {\nfor (int j = 0; j < i; ++j) {\nif (arr[i].second >= arr[j].second) {\nf[i] = max(f[i], f[j]);\n}\n}\nf[i] += arr[i].first;\n}\nreturn *max_element(f.begin(), f.end());\n}\n};\n", "\nclass BinaryIndexedTree {\npublic:\nBinaryIndexedTree(int _n)\n: n(_n)\n, c(_n + 1) {}\n\nvoid update(int x, int val) {\nwhile (x <= n) {\nc[x] = max(c[x], val);\nx += x & -x;\n}\n}\n\nint query(int x) {\nint s = 0;\nwhile (x) {\ns = max(s, c[x]);\nx -= x & -x;\n}\nreturn s;\n}\n\nprivate:\nint n;\nvector<int> c;\n};\n\nclass Solution {\npublic:\nint bestTeamScore(vector<int>& scores, vector<int>& ages) {\nint n = ages.size();\nvector<pair<int, int>> arr(n);\nfor (int i = 0; i < n; ++i) {\narr[i] = {scores[i], ages[i]};\n}\nsort(arr.begin(), arr.end());\nint m = *max_element(ages.begin(), ages.end());\nBinaryIndexedTree tree(m);\nfor (auto& [score, age] : arr) {\ntree.update(age, score + tree.query(age));\n}\nreturn tree.query(m);\n}\n};\n"]}, {"leetCodeID": "1634", "level": "middle", "question_description": "A polynomial linked list is a special type of linked list where every node represents a term in a polynomial expression.\nEach node has three attributes:\ncoefficient: an integer representing the number multiplier of the term. The coefficient of the term 9x4 is 9.\npower: an integer representing the exponent. The power of the term 9x4 is 4.\nnext: a pointer to the next node in the list, or null if it is the last node of the list.\nFor example, the polynomial 5x3 + 4x - 7 is represented by the polynomial linked list illustrated below:\nThe polynomial linked list must be in its standard form: the polynomial must be in strictly descending order by its power value. Also, terms with a coefficient of 0 are omitted.\nGiven two polynomial linked list heads, poly1 and poly2, add the polynomials together and return the head of the sum of the polynomials.\nPolyNode format:\nThe input/output format is as a list of n nodes, where each node is represented as its [coefficient, power]. For example, the polynomial 5x3 + 4x - 7 would be represented as: [[5,3],[4,1],[-7,0]].", "examples": ["Example 1:\n\n\n\n\n\nInput: poly1 = [[1,1]], poly2 = [[1,0]]\n\nOutput: [[1,1],[1,0]]\n\nExplanation: poly1 = x. poly2 = 1. The sum is x + 1.\n\n\n\nExample 2:\n\nInput: poly1 = [[2,2],[4,1],[3,0]], poly2 = [[3,2],[-4,1],[-1,0]]\n\nOutput: [[5,2],[2,0]]\n\nExplanation: poly1 = 2x2 + 4x + 3. poly2 = 3x2 - 4x - 1. The sum is 5x2 + 2. Notice that we omit the &quot;0x&quot; term.\n\n", "Example 3:\n\nInput: poly1 = [[1,2]], poly2 = [[-1,2]]\n\nOutput: []\n\nExplanation: The sum is 0. We return an empty list.\n\n"], "constraints": "\nConstraints:\n0 <= n <= 104\n-109&nbsp;<= PolyNode.coefficient <= 109\nPolyNode.coefficient != 0\n0&nbsp;<= PolyNode.power <= 109\nPolyNode.power &gt; PolyNode.next.power\n", "java_context": "\n/**\n* Definition for polynomial singly-linked list.\n* class PolyNode {\n*     int coefficient, power;\n*     PolyNode next = null;\n\n*     PolyNode() {}\n*     PolyNode(int x, int y) { this.coefficient = x; this.power = y; }\n*     PolyNode(int x, int y, PolyNode next) { this.coefficient = x; this.power = y; this.next =\nnext; }\n* }\n*/\n\nclass Solution {\n    public PolyNode addPoly(PolyNode poly1, PolyNode poly2) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for polynomial singly-linked list.\n* function PolyNode(x=0, y=0, next=null) {\n*     this.coefficient = x;\n*     this.power = y;\n*     this.next = next;\n* }\n*/\n\n/**\n* @param {PolyNode} poly1\n* @param {PolyNode} poly2\n* @return {PolyNode}\n*/\nvar addPoly = function (poly1, poly2) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for polynomial singly-linked list->\n* struct PolyNode {\n*     int coefficient, power;\n*     PolyNode *next;\n*     PolyNode(): coefficient(0), power(0), next(nullptr) {};\n*     PolyNode(int x, int y): coefficient(x), power(y), next(nullptr) {};\n*     PolyNode(int x, int y, PolyNode* next): coefficient(x), power(y), next(next) {};\n* };\n*/\n\nclass Solution {\npublic:\n    PolyNode* addPoly(PolyNode* poly1, PolyNode* poly2) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for polynomial singly-linked list.\n* class PolyNode {\n*     int coefficient, power;\n*     PolyNode next = null;\n\n*     PolyNode() {}\n*     PolyNode(int x, int y) { this.coefficient = x; this.power = y; }\n*     PolyNode(int x, int y, PolyNode next) { this.coefficient = x; this.power = y; this.next =\nnext; }\n* }\n*/\n\nclass Solution {\npublic PolyNode addPoly(PolyNode poly1, PolyNode poly2) {\nPolyNode dummy = new PolyNode();\nPolyNode curr = dummy;\nwhile (poly1 != null && poly2 != null) {\nif (poly1.power > poly2.power) {\ncurr.next = poly1;\npoly1 = poly1.next;\ncurr = curr.next;\n} else if (poly1.power < poly2.power) {\ncurr.next = poly2;\npoly2 = poly2.next;\ncurr = curr.next;\n} else {\nint c = poly1.coefficient + poly2.coefficient;\nif (c != 0) {\ncurr.next = new PolyNode(c, poly1.power);\ncurr = curr.next;\n}\npoly1 = poly1.next;\npoly2 = poly2.next;\n}\n}\nif (poly1 == null) {\ncurr.next = poly2;\n}\nif (poly2 == null) {\ncurr.next = poly1;\n}\nreturn dummy.next;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for polynomial singly-linked list.\n* function PolyNode(x=0, y=0, next=null) {\n*     this.coefficient = x;\n*     this.power = y;\n*     this.next = next;\n* }\n*/\n\n/**\n* @param {PolyNode} poly1\n* @param {PolyNode} poly2\n* @return {PolyNode}\n*/\nvar addPoly = function (poly1, poly2) {\nconst dummy = new PolyNode();\nlet curr = dummy;\nwhile (poly1 && poly2) {\nif (poly1.power > poly2.power) {\ncurr.next = poly1;\npoly1 = poly1.next;\ncurr = curr.next;\n} else if (poly1.power < poly2.power) {\ncurr.next = poly2;\npoly2 = poly2.next;\ncurr = curr.next;\n} else {\nconst c = poly1.coefficient + poly2.coefficient;\nif (c != 0) {\ncurr.next = new PolyNode(c, poly1.power);\ncurr = curr.next;\n}\npoly1 = poly1.next;\npoly2 = poly2.next;\n}\n}\ncurr.next = poly1 || poly2;\nreturn dummy.next;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for polynomial singly-linked list->\n* struct PolyNode {\n*     int coefficient, power;\n*     PolyNode *next;\n*     PolyNode(): coefficient(0), power(0), next(nullptr) {};\n*     PolyNode(int x, int y): coefficient(x), power(y), next(nullptr) {};\n*     PolyNode(int x, int y, PolyNode* next): coefficient(x), power(y), next(next) {};\n* };\n*/\n\nclass Solution {\npublic:\nPolyNode* addPoly(PolyNode* poly1, PolyNode* poly2) {\nPolyNode* dummy = new PolyNode();\nPolyNode* curr = dummy;\nwhile (poly1 && poly2) {\nif (poly1->power > poly2->power) {\ncurr->next = poly1;\npoly1 = poly1->next;\ncurr = curr->next;\n} else if (poly1->power < poly2->power) {\ncurr->next = poly2;\npoly2 = poly2->next;\ncurr = curr->next;\n} else {\nint c = poly1->coefficient + poly2->coefficient;\nif (c != 0) {\ncurr->next = new PolyNode(c, poly1->power);\ncurr = curr->next;\n}\npoly1 = poly1->next;\npoly2 = poly2->next;\n}\n}\nif (!poly1) {\ncurr->next = poly2;\n}\nif (!poly2) {\ncurr->next = poly1;\n}\nreturn dummy->next;\n}\n};\n"]}, {"leetCodeID": "1644", "level": "middle", "question_description": "Given the root of a binary tree, return the lowest common ancestor (LCA) of two given nodes, p and q. If either node p or q does not exist in the tree, return null. All values of the nodes in the tree are unique.\nAccording to the definition of LCA on Wikipedia: &quot;The lowest common ancestor of two nodes p and q in a binary tree T is the lowest node that has both p and q as descendants (where we allow a node to be a descendant of itself)&quot;. A descendant of a node x is a node y that is on the path from node x to some leaf node.", "examples": [], "constraints": "\nConstraints:\nThe number of nodes in the tree is in the range [1, 104].\n-109 <= Node.val <= 109\nAll Node.val are unique.\np != q\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode(int x) { val = x; }\n* }\n*/\nclass Solution {\n    private TreeNode ans;\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val) {\n*     this.val = val;\n*     this.left = this.right = null;\n* }\n*/\n/**\n* @param {TreeNode} root\n* @param {TreeNode} p\n* @param {TreeNode} q\n* @return {TreeNode}\n*/\nvar lowestCommonAncestor = function (root, p, q) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n* };\n*/\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode(int x) { val = x; }\n* }\n*/\nclass Solution {\nprivate TreeNode ans;\n\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\ndfs(root, p, q);\nreturn ans;\n}\n\nprivate boolean dfs(TreeNode root, TreeNode p, TreeNode q) {\nif (root == null) {\nreturn false;\n}\nboolean l = dfs(root.left, p, q);\nboolean r = dfs(root.right, p, q);\nif (l && r) {\nans = root;\n}\nif ((l || r) && (root.val == p.val || root.val == q.val)) {\nans = root;\n}\nreturn l || r || root.val == p.val || root.val == q.val;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val) {\n*     this.val = val;\n*     this.left = this.right = null;\n* }\n*/\n/**\n* @param {TreeNode} root\n* @param {TreeNode} p\n* @param {TreeNode} q\n* @return {TreeNode}\n*/\nvar lowestCommonAncestor = function (root, p, q) {\nconst dfs = root => {\nif (!root) {\nreturn false;\n}\nconst l = dfs(root.left);\nconst r = dfs(root.right);\nif (l && r) {\nans = root;\n}\nif ((l || r) && (root.val === p.val || root.val === q.val)) {\nans = root;\n}\nreturn l || r || root.val === p.val || root.val === q.val;\n};\nlet ans = null;\ndfs(root);\nreturn ans;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n* };\n*/\nclass Solution {\npublic:\nTreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\ndfs(root, p, q);\nreturn ans;\n}\n\nprivate:\nTreeNode* ans = nullptr;\n\nbool dfs(TreeNode* root, TreeNode* p, TreeNode* q) {\nif (!root) {\nreturn false;\n}\nbool l = dfs(root->left, p, q);\nbool r = dfs(root->right, p, q);\nif (l && r) {\nans = root;\n}\nif ((l || r) && (root->val == p->val || root->val == q->val)) {\nans = root;\n}\nreturn l || r || root->val == p->val || root->val == q->val;\n}\n};\n"]}, {"leetCodeID": "1660", "level": "middle", "question_description": "You have a binary tree with a small defect. There is exactly one invalid node where its right child incorrectly points to another node at the same depth but to the invalid node&#39;s right.\nGiven the root of the binary tree with this defect, root, return the root of the binary tree after removing this invalid node and every node underneath it (minus the node it incorrectly points to).\nCustom testing:\nThe test input is read as 3 lines:\nTreeNode root\nint fromNode (not available to correctBinaryTree)\nint toNode (not available to correctBinaryTree)\nAfter the binary tree rooted at root is parsed, the TreeNode with value of fromNode will have its right child pointer pointing to the TreeNode with a value of toNode. Then, root is passed to correctBinaryTree.", "examples": ["Example 1:\n\n\n\nInput: root = [1,2,3], fromNode = 2, toNode = 3\n\nOutput: [1,null,3]\n\nExplanation: The node with value 2 is invalid, so remove it.\n\n", "Example 2:\n\n\n\nInput: root = [8,3,1,7,null,9,4,2,null,null,null,5,6], fromNode = 7, toNode = 4\n\nOutput: [8,3,1,null,null,9,4,null,null,5,6]\n\nExplanation: The node with value 7 is invalid, so remove it and the node underneath it, node 2.\n\n"], "constraints": "\nConstraints:\nThe number of nodes in the tree is in the range [3, 104].\n-109 <= Node.val <= 109\nAll Node.val are unique.\nfromNode != toNode\nfromNode and toNode will exist in the tree and will be on the same depth.\ntoNode is to the right of fromNode.\nfromNode.right is null in the initial tree from the test data.\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\n    private Set<TreeNode> vis = new HashSet<>();\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @param {number} from\n* @param {number} to\n* @return {TreeNode}\n*/\nvar correctBinaryTree = function (root) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    TreeNode* correctBinaryTree(TreeNode* root) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\nprivate Set<TreeNode> vis = new HashSet<>();\n\npublic TreeNode correctBinaryTree(TreeNode root) {\nreturn dfs(root);\n}\n\nprivate TreeNode dfs(TreeNode root) {\nif (root == null || vis.contains(root.right)) {\nreturn null;\n}\nvis.add(root);\nroot.right = dfs(root.right);\nroot.left = dfs(root.left);\nreturn root;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @param {number} from\n* @param {number} to\n* @return {TreeNode}\n*/\nvar correctBinaryTree = function (root) {\nconst dfs = root => {\nif (!root || vis.has(root.right)) {\nreturn null;\n}\nvis.add(root);\nroot.right = dfs(root.right);\nroot.left = dfs(root.left);\nreturn root;\n};\nconst vis = new Set();\nreturn dfs(root);\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nTreeNode* correctBinaryTree(TreeNode* root) {\nunordered_set<TreeNode*> vis;\nfunction<TreeNode*(TreeNode*)> dfs = [&](TreeNode* root) -> TreeNode* {\nif (!root || vis.count(root->right)) {\nreturn nullptr;\n}\nvis.insert(root);\nroot->right = dfs(root->right);\nroot->left = dfs(root->left);\nreturn root;\n};\nreturn dfs(root);\n}\n};\n"]}, {"leetCodeID": "1664", "level": "middle", "question_description": "You are given an integer array nums. You can choose exactly one index (0-indexed) and remove the element. Notice that the index of the elements may change after the removal.\nFor example, if nums = [6,1,7,4,1]:\nChoosing to remove index 1 results in nums = [6,7,4,1].\nChoosing to remove index 2 results in nums = [6,1,4,1].\nChoosing to remove index 4 results in nums = [6,1,7,4].\nAn array is fair if the sum of the odd-indexed values equals the sum of the even-indexed values.\nReturn the number of indices that you could choose such that after the removal, nums is fair.", "examples": ["Example 1:\nInput: nums = [2,1,6,4]\nOutput: 1\nExplanation:\nRemove index 0: [1,6,4] -&gt; Even sum: 1 + 4 = 5. Odd sum: 6. Not fair.\nRemove index 1: [2,6,4] -&gt; Even sum: 2 + 4 = 6. Odd sum: 6. Fair.\nRemove index 2: [2,1,4] -&gt; Even sum: 2 + 4 = 6. Odd sum: 1. Not fair.\nRemove index 3: [2,1,6] -&gt; Even sum: 2 + 6 = 8. Odd sum: 1. Not fair.\nThere is 1 index that you can remove to make nums fair.\n", "Example 2:\nInput: nums = [1,1,1]\nOutput: 3\nExplanation:&nbsp;You can remove any index and the remaining array is fair.\n", "Example 3:\nInput: nums = [1,2,3]\nOutput: 0\nExplanation:&nbsp;You cannot make a fair array after removing any index.\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 105\n1 <= nums[i] <= 104\n", "java_context": "\nclass Solution {\n    public int waysToMakeFair(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar waysToMakeFair = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int waysToMakeFair(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int waysToMakeFair(int[] nums) {\nint s1 = 0, s2 = 0;\nint n = nums.length;\nfor (int i = 0; i < n; ++i) {\ns1 += i % 2 == 0 ? nums[i] : 0;\ns2 += i % 2 == 1 ? nums[i] : 0;\n}\nint t1 = 0, t2 = 0;\nint ans = 0;\nfor (int i = 0; i < n; ++i) {\nint v = nums[i];\nans += i % 2 == 0 && t2 + s1 - t1 - v == t1 + s2 - t2 ? 1 : 0;\nans += i % 2 == 1 && t2 + s1 - t1 == t1 + s2 - t2 - v ? 1 : 0;\nt1 += i % 2 == 0 ? v : 0;\nt2 += i % 2 == 1 ? v : 0;\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar waysToMakeFair = function (nums) {\nlet [s1, s2, t1, t2] = [0, 0, 0, 0];\nconst n = nums.length;\nfor (let i = 0; i < n; ++i) {\nif (i % 2 == 0) {\ns1 += nums[i];\n} else {\ns2 += nums[i];\n}\n}\nlet ans = 0;\nfor (let i = 0; i < n; ++i) {\nconst v = nums[i];\nans += i % 2 == 0 && t2 + s1 - t1 - v == t1 + s2 - t2;\nans += i % 2 == 1 && t2 + s1 - t1 == t1 + s2 - t2 - v;\nt1 += i % 2 == 0 ? v : 0;\nt2 += i % 2 == 1 ? v : 0;\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint waysToMakeFair(vector<int>& nums) {\nint s1 = 0, s2 = 0;\nint n = nums.size();\nfor (int i = 0; i < n; ++i) {\ns1 += i % 2 == 0 ? nums[i] : 0;\ns2 += i % 2 == 1 ? nums[i] : 0;\n}\nint t1 = 0, t2 = 0;\nint ans = 0;\nfor (int i = 0; i < n; ++i) {\nint v = nums[i];\nans += i % 2 == 0 && t2 + s1 - t1 - v == t1 + s2 - t2;\nans += i % 2 == 1 && t2 + s1 - t1 == t1 + s2 - t2 - v;\nt1 += i % 2 == 0 ? v : 0;\nt2 += i % 2 == 1 ? v : 0;\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1666", "level": "middle", "question_description": "Given the root of a binary tree and a leaf node, reroot the tree so that the leaf is the new root.\nYou can reroot the tree with the following steps for each node cur on the path starting from the leaf up to the root\u200b\u200b\u200b excluding the root:\nIf cur has a left child, then that child becomes cur&#39;s right child.\ncur&#39;s original parent becomes cur&#39;s left child. Note that in this process the original parent&#39;s pointer to cur becomes null, making it have at most one child.\nReturn the new root of the rerooted tree.\nNote: Ensure that your solution sets the Node.parent pointers correctly after rerooting or you will receive &quot;Wrong Answer&quot;.", "examples": ["Example 1:\n\n\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], leaf = 7\nOutput: [7,2,null,5,4,3,6,null,null,null,1,null,null,0,8]\n\n\nExample 2:\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], leaf = 0\nOutput: [0,1,null,3,8,5,null,null,null,6,2,null,null,7,4]\n"], "constraints": "\nConstraints:\nThe number of nodes in the tree is in the range [2, 100].\n-109 <= Node.val <= 109\nAll Node.val are unique.\nleaf exist in the tree.\n", "java_context": "\n/*\n// Definition for a Node.\nclass Node {\npublic int val;\npublic Node left;\npublic Node right;\npublic Node parent;\n};\n*/\n\nclass Solution {\n    public Node flipBinaryTree(Node root, Node leaf) {\n        // your code\n    }\n}", "js_context": "\n/**\n* // Definition for a Node.\n* function Node(val) {\n*    this.val = val;\n*    this.left = null;\n*    this.right = null;\n*    this.parent = null;\n* };\n*/\n\n/**\n* @param {Node} node\n* @return {Node}\n*/\nvar flipBinaryTree = function (root, leaf) {\n    // your code\n};", "cpp_context": "\n/*\n// Definition for a Node->\nclass Node {\npublic:\nint val;\nNode* left;\nNode* right;\nNode* parent;\n};\n*/\n\nclass Solution {\npublic:\n    Node* flipBinaryTree(Node* root, Node* leaf) {\n        // your code\n    }\n};", "java_solutions": ["\n/*\n// Definition for a Node.\nclass Node {\npublic int val;\npublic Node left;\npublic Node right;\npublic Node parent;\n};\n*/\n\nclass Solution {\npublic Node flipBinaryTree(Node root, Node leaf) {\nNode cur = leaf;\nNode p = cur.parent;\nwhile (cur != root) {\nNode gp = p.parent;\nif (cur.left != null) {\ncur.right = cur.left;\n}\ncur.left = p;\np.parent = cur;\nif (p.left == cur) {\np.left = null;\n} else if (p.right == cur) {\np.right = null;\n}\ncur = p;\np = gp;\n}\nleaf.parent = null;\nreturn leaf;\n}\n}\n"], "js_solutions": ["\n/**\n* // Definition for a Node.\n* function Node(val) {\n*    this.val = val;\n*    this.left = null;\n*    this.right = null;\n*    this.parent = null;\n* };\n*/\n\n/**\n* @param {Node} node\n* @return {Node}\n*/\nvar flipBinaryTree = function (root, leaf) {\nlet cur = leaf;\nlet p = cur.parent;\nwhile (cur != root) {\nconst gp = p.parent;\nif (cur.left != null) {\ncur.right = cur.left;\n}\ncur.left = p;\np.parent = cur;\nif (p.left == cur) {\np.left = null;\n} else if (p.right == cur) {\np.right = null;\n}\ncur = p;\np = gp;\n}\nleaf.parent = null;\nreturn leaf;\n};\n"], "cpp_solutions": ["\n/*\n// Definition for a Node->\nclass Node {\npublic:\nint val;\nNode* left;\nNode* right;\nNode* parent;\n};\n*/\n\nclass Solution {\npublic:\nNode* flipBinaryTree(Node* root, Node* leaf) {\nNode* cur = leaf;\nNode* p = cur->parent;\nwhile (cur != root) {\nNode* gp = p->parent;\nif (cur->left) {\ncur->right = cur->left;\n}\ncur->left = p;\np->parent = cur;\nif (p->left == cur) {\np->left = nullptr;\n} else if (p->right == cur) {\np->right = nullptr;\n}\ncur = p;\np = gp;\n}\nleaf->parent = nullptr;\nreturn leaf;\n}\n};\n"]}, {"leetCodeID": "1670", "level": "middle", "question_description": "Design a queue that supports push and pop operations in the front, middle, and back.\nImplement the FrontMiddleBack class:\nFrontMiddleBack() Initializes the queue.\nvoid pushFront(int val) Adds val to the front of the queue.\nvoid pushMiddle(int val) Adds val to the middle of the queue.\nvoid pushBack(int val) Adds val to the back of the queue.\nint popFront() Removes the front element of the queue and returns it. If the queue is empty, return -1.\nint popMiddle() Removes the middle element of the queue and returns it. If the queue is empty, return -1.\nint popBack() Removes the back element of the queue and returns it. If the queue is empty, return -1.\nNotice that when there are two middle position choices, the operation is performed on the frontmost middle position choice. For example:\nPushing 6 into the middle of [1, 2, 3, 4, 5] results in [1, 2, 6, 3, 4, 5].\nPopping the middle from [1, 2, 3, 4, 5, 6] returns 3 and results in [1, 2, 4, 5, 6].", "examples": ["Example 1:\nInput:\n[&quot;FrontMiddleBackQueue&quot;, &quot;pushFront&quot;, &quot;pushBack&quot;, &quot;pushMiddle&quot;, &quot;pushMiddle&quot;, &quot;popFront&quot;, &quot;popMiddle&quot;, &quot;popMiddle&quot;, &quot;popBack&quot;, &quot;popFront&quot;]\n[[], [1], [2], [3], [4], [], [], [], [], []]\nOutput:\n[null, null, null, null, null, 1, 3, 4, 2, -1]\n\nExplanation:\nFrontMiddleBackQueue q = new FrontMiddleBackQueue();\nq.pushFront(1);   // [1]\nq.pushBack(2);    // [1, 2]\nq.pushMiddle(3);  // [1, 3, 2]\nq.pushMiddle(4);  // [1, 4, 3, 2]\nq.popFront();     // return 1 -&gt; [4, 3, 2]\nq.popMiddle();    // return 3 -&gt; [4, 2]\nq.popMiddle();    // return 4 -&gt; [2]\nq.popBack();      // return 2 -&gt; []\nq.popFront();     // return -1 -&gt; [] (The queue is empty)\n"], "constraints": "\nConstraints:\n1 <= val <= 109\nAt most&nbsp;1000&nbsp;calls will be made to&nbsp;pushFront,&nbsp;pushMiddle,&nbsp;pushBack, popFront, popMiddle, and popBack.\n", "java_context": "    \n        // your code\n    }\n}", "js_context": "\n    // your code\n};", "cpp_context": "    \n        // your code\n    }\n};", "java_solutions": ["\nclass FrontMiddleBackQueue {\nprivate Deque<Integer> q1 = new ArrayDeque<>();\nprivate Deque<Integer> q2 = new ArrayDeque<>();\n\npublic FrontMiddleBackQueue() {\n}\n\npublic void pushFront(int val) {\nq1.offerFirst(val);\nrebalance();\n}\n\npublic void pushMiddle(int val) {\nq1.offerLast(val);\nrebalance();\n}\n\npublic void pushBack(int val) {\nq2.offerLast(val);\nrebalance();\n}\n\npublic int popFront() {\nif (q1.isEmpty() && q2.isEmpty()) {\nreturn -1;\n}\nint val = q1.isEmpty() ? q2.pollFirst() : q1.pollFirst();\nrebalance();\nreturn val;\n}\n\npublic int popMiddle() {\nif (q1.isEmpty() && q2.isEmpty()) {\nreturn -1;\n}\nint val = q1.size() == q2.size() ? q1.pollLast() : q2.pollFirst();\nrebalance();\nreturn val;\n}\n\npublic int popBack() {\nif (q2.isEmpty()) {\nreturn -1;\n}\nint val = q2.pollLast();\nrebalance();\nreturn val;\n}\n\nprivate void rebalance() {\nif (q1.size() > q2.size()) {\nq2.offerFirst(q1.pollLast());\n}\nif (q2.size() > q1.size() + 1) {\nq1.offerLast(q2.pollFirst());\n}\n}\n}\n\n/**\n* Your FrontMiddleBackQueue object will be instantiated and called as such:\n* FrontMiddleBackQueue obj = new FrontMiddleBackQueue();\n* obj.pushFront(val);\n* obj.pushMiddle(val);\n* obj.pushBack(val);\n* int param_4 = obj.popFront();\n* int param_5 = obj.popMiddle();\n* int param_6 = obj.popBack();\n*/\n"], "js_solutions": ["\nclass FrontMiddleBackQueue {\nconstructor() {\nthis.q1 = new Deque();\nthis.q2 = new Deque();\n}\n\npushFront(val) {\nthis.q1.pushFront(val);\nthis.rebalance();\n}\n\npushMiddle(val) {\nthis.q1.pushBack(val);\nthis.rebalance();\n}\n\npushBack(val) {\nthis.q2.pushBack(val);\nthis.rebalance();\n}\n\npopFront() {\nif (this.q1.isEmpty() && this.q2.isEmpty()) {\nreturn -1;\n}\nconst val = this.q1.isEmpty() ? this.q2.popFront() : this.q1.popFront();\nthis.rebalance();\nreturn val !== undefined ? val : -1;\n}\n\npopMiddle() {\nif (this.q1.isEmpty() && this.q2.isEmpty()) {\nreturn -1;\n}\nconst val =\nthis.q1.getSize() === this.q2.getSize() ? this.q1.popBack() : this.q2.popFront();\nthis.rebalance();\nreturn val !== undefined ? val : -1;\n}\n\npopBack() {\nif (this.q2.isEmpty()) {\nreturn -1;\n}\nconst val = this.q2.popBack();\nthis.rebalance();\nreturn val !== undefined ? val : -1;\n}\n\nrebalance() {\nif (this.q1.getSize() > this.q2.getSize()) {\nthis.q2.pushFront(this.q1.popBack());\n}\nif (this.q2.getSize() > this.q1.getSize() + 1) {\nthis.q1.pushBack(this.q2.popFront());\n}\n}\n}\n\nclass Node {\nconstructor(value) {\nthis.value = value;\nthis.next = null;\nthis.prev = null;\n}\n}\n\nclass Deque {\nconstructor() {\nthis.front = null;\nthis.back = null;\nthis.size = 0;\n}\n\npushFront(val) {\nconst newNode = new Node(val);\nif (this.isEmpty()) {\nthis.front = newNode;\nthis.back = newNode;\n} else {\nnewNode.next = this.front;\nthis.front.prev = newNode;\nthis.front = newNode;\n}\nthis.size++;\n}\n\npushBack(val) {\nconst newNode = new Node(val);\nif (this.isEmpty()) {\nthis.front = newNode;\nthis.back = newNode;\n} else {\nnewNode.prev = this.back;\nthis.back.next = newNode;\nthis.back = newNode;\n}\nthis.size++;\n}\n\npopFront() {\nif (this.isEmpty()) {\nreturn undefined;\n}\nconst value = this.front.value;\nthis.front = this.front.next;\nif (this.front !== null) {\nthis.front.prev = null;\n} else {\nthis.back = null;\n}\nthis.size--;\nreturn value;\n}\n\npopBack() {\nif (this.isEmpty()) {\nreturn undefined;\n}\nconst value = this.back.value;\nthis.back = this.back.prev;\nif (this.back !== null) {\nthis.back.next = null;\n} else {\nthis.front = null;\n}\nthis.size--;\nreturn value;\n}\n\nfrontValue() {\nreturn this.front?.value;\n}\n\nbackValue() {\nreturn this.back?.value;\n}\n\ngetSize() {\nreturn this.size;\n}\n\nisEmpty() {\nreturn this.size === 0;\n}\n}\n\n/**\n* Your FrontMiddleBackQueue object will be instantiated and called as such:\n* var obj = new FrontMiddleBackQueue()\n* obj.pushFront(val)\n* obj.pushMiddle(val)\n* obj.pushBack(val)\n* var param_4 = obj.popFront()\n* var param_5 = obj.popMiddle()\n* var param_6 = obj.popBack()\n*/\n"], "cpp_solutions": ["\nclass FrontMiddleBackQueue {\npublic:\nFrontMiddleBackQueue() {\n}\n\nvoid pushFront(int val) {\nq1.push_front(val);\nrebalance();\n}\n\nvoid pushMiddle(int val) {\nq1.push_back(val);\nrebalance();\n}\n\nvoid pushBack(int val) {\nq2.push_back(val);\nrebalance();\n}\n\nint popFront() {\nif (q1.empty() && q2.empty()) return -1;\nint val = 0;\nif (q1.size()) {\nval = q1.front();\nq1.pop_front();\n} else {\nval = q2.front();\nq2.pop_front();\n}\nrebalance();\nreturn val;\n}\n\nint popMiddle() {\nif (q1.empty() && q2.empty()) return -1;\nint val = 0;\nif (q1.size() == q2.size()) {\nval = q1.back();\nq1.pop_back();\n} else {\nval = q2.front();\nq2.pop_front();\n}\nrebalance();\nreturn val;\n}\n\nint popBack() {\nif (q2.empty()) return -1;\nint val = q2.back();\nq2.pop_back();\nrebalance();\nreturn val;\n}\n\nprivate:\ndeque<int> q1;\ndeque<int> q2;\n\nvoid rebalance() {\nif (q1.size() > q2.size()) {\nq2.push_front(q1.back());\nq1.pop_back();\n}\nif (q2.size() > q1.size() + 1) {\nq1.push_back(q2.front());\nq2.pop_front();\n}\n}\n};\n\n/**\n* Your FrontMiddleBackQueue object will be instantiated and called as such:\n* FrontMiddleBackQueue* obj = new FrontMiddleBackQueue();\n* obj->pushFront(val);\n* obj->pushMiddle(val);\n* obj->pushBack(val);\n* int param_4 = obj->popFront();\n* int param_5 = obj->popMiddle();\n* int param_6 = obj->popBack();\n*/\n"]}, {"leetCodeID": "1676", "level": "middle", "question_description": "Given the root of a binary tree and an array of TreeNode objects nodes, return the lowest common ancestor (LCA) of all the nodes in nodes. All the nodes will exist in the tree, and all values of the tree&#39;s nodes are unique.\nExtending the definition of LCA on Wikipedia: &quot;The lowest common ancestor of n nodes p1, p2, ..., pn in a binary tree T is the lowest node that has every pi as a descendant (where we allow a node to be a descendant of itself) for every valid i&quot;. A descendant of a node x is a node y that is on the path from node x to some leaf node.", "examples": [], "constraints": "\nConstraints:\nThe number of nodes in the tree is in the range [1, 104].\n-109 <= Node.val <= 109\nAll Node.val are unique.\nAll nodes[i] will exist in the tree.\nAll nodes[i] are distinct.\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode(int x) { val = x; }\n* }\n*/\nclass Solution {\n    private Set<Integer> s = new HashSet<>();\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val) {\n*     this.val = val;\n*     this.left = this.right = null;\n* }\n*/\n/**\n* @param {TreeNode} root\n* @param {TreeNode[]} nodes\n* @return {TreeNode}\n*/\nvar lowestCommonAncestor = function (root, nodes) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, vector<TreeNode*>& nodes) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode(int x) { val = x; }\n* }\n*/\nclass Solution {\nprivate Set<Integer> s = new HashSet<>();\n\npublic TreeNode lowestCommonAncestor(TreeNode root, TreeNode[] nodes) {\nfor (TreeNode node : nodes) {\ns.add(node.val);\n}\nreturn dfs(root);\n}\n\nprivate TreeNode dfs(TreeNode root) {\nif (root == null || s.contains(root.val)) {\nreturn root;\n}\nTreeNode left = dfs(root.left);\nTreeNode right = dfs(root.right);\nif (left == null) {\nreturn right;\n}\nif (right == null) {\nreturn left;\n}\nreturn root;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val) {\n*     this.val = val;\n*     this.left = this.right = null;\n* }\n*/\n/**\n* @param {TreeNode} root\n* @param {TreeNode[]} nodes\n* @return {TreeNode}\n*/\nvar lowestCommonAncestor = function (root, nodes) {\nconst s = new Set();\nfor (const node of nodes) {\ns.add(node.val);\n}\nfunction dfs(root) {\nif (!root || s.has(root.val)) {\nreturn root;\n}\nconst [left, right] = [dfs(root.left), dfs(root.right)];\nif (left && right) {\nreturn root;\n}\nreturn left || right;\n}\nreturn dfs(root);\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nTreeNode* lowestCommonAncestor(TreeNode* root, vector<TreeNode*>& nodes) {\nunordered_set<int> s;\nfor (auto node : nodes) s.insert(node->val);\nfunction<TreeNode*(TreeNode*)> dfs = [&](TreeNode* root) -> TreeNode* {\nif (!root || s.count(root->val)) return root;\nauto left = dfs(root->left);\nauto right = dfs(root->right);\nif (!left) return right;\nif (!right) return left;\nreturn root;\n};\nreturn dfs(root);\n}\n};\n"]}, {"leetCodeID": "1685", "level": "middle", "question_description": "You are given an integer array nums sorted in non-decreasing order.\nBuild and return an integer array result with the same length as nums such that result[i] is equal to the summation of absolute differences between nums[i] and all the other elements in the array.\nIn other words, result[i] is equal to sum(|nums[i]-nums[j]|) where 0 &lt;= j &lt; nums.length and j != i (0-indexed).", "examples": ["Example 1:\nInput: nums = [2,3,5]\nOutput: [4,3,5]\nExplanation: Assuming the arrays are 0-indexed, then\nresult[0] = |2-2| + |2-3| + |2-5| = 0 + 1 + 3 = 4,\nresult[1] = |3-2| + |3-3| + |3-5| = 1 + 0 + 2 = 3,\nresult[2] = |5-2| + |5-3| + |5-5| = 3 + 2 + 0 = 5.\n", "Example 2:\nInput: nums = [1,4,6,8,10]\nOutput: [24,15,13,15,21]\n"], "constraints": "\nConstraints:\n2 <= nums.length <= 105\n1 <= nums[i] <= nums[i + 1] <= 104\n", "java_context": "\nclass Solution {\n    public int[] getSumAbsoluteDifferences(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number[]}\n*/\nvar getSumAbsoluteDifferences = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> getSumAbsoluteDifferences(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int[] getSumAbsoluteDifferences(int[] nums) {\n// int s = Arrays.stream(nums).sum();\nint s = 0, t = 0;\nfor (int x : nums) {\ns += x;\n}\nint n = nums.length;\nint[] ans = new int[n];\nfor (int i = 0; i < n; ++i) {\nint v = nums[i] * i - t + s - t - nums[i] * (n - i);\nans[i] = v;\nt += nums[i];\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number[]}\n*/\nvar getSumAbsoluteDifferences = function (nums) {\nconst s = nums.reduce((a, b) => a + b);\nlet t = 0;\nconst n = nums.length;\nconst ans = new Array(n);\nfor (let i = 0; i < n; ++i) {\nconst v = nums[i] * i - t + s - t - nums[i] * (n - i);\nans[i] = v;\nt += nums[i];\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> getSumAbsoluteDifferences(vector<int>& nums) {\nint s = accumulate(nums.begin(), nums.end(), 0), t = 0;\nint n = nums.size();\nvector<int> ans(n);\nfor (int i = 0; i < n; ++i) {\nint v = nums[i] * i - t + s - t - nums[i] * (n - i);\nans[i] = v;\nt += nums[i];\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1712", "level": "middle", "question_description": "A split of an integer array is good if:\nThe array is split into three non-empty contiguous subarrays - named left, mid, right respectively from left to right.\nThe sum of the elements in left is less than or equal to the sum of the elements in mid, and the sum of the elements in mid is less than or equal to the sum of the elements in right.\nGiven nums, an array of non-negative integers, return the number of good ways to split nums. As the number may be too large, return it modulo 109 + 7.", "examples": ["Example 1:\nInput: nums = [1,1,1]\nOutput: 1\nExplanation: The only good way to split nums is [1] [1] [1].", "Example 2:\nInput: nums = [1,2,2,2,5,0]\nOutput: 3\nExplanation: There are three good ways of splitting nums:\n[1] [2] [2,2,5,0]\n[1] [2,2] [2,5,0]\n[1,2] [2,2] [5,0]\n", "Example 3:\nInput: nums = [3,2,1]\nOutput: 0\nExplanation: There is no good way to split nums."], "constraints": "\nConstraints:\n3 <= nums.length <= 105\n0 <= nums[i] <= 104\n", "java_context": "\nclass Solution {\n    private static final int MOD = (int) 1e9 + 7;\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar waysToSplit = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    const int mod = 1e9 + 7;\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\nprivate static final int MOD = (int) 1e9 + 7;\n\npublic int waysToSplit(int[] nums) {\nint n = nums.length;\nint[] s = new int[n];\ns[0] = nums[0];\nfor (int i = 1; i < n; ++i) {\ns[i] = s[i - 1] + nums[i];\n}\nint ans = 0;\nfor (int i = 0; i < n - 2; ++i) {\nint j = search(s, s[i] << 1, i + 1, n - 1);\nint k = search(s, ((s[n - 1] + s[i]) >> 1) + 1, j, n - 1);\nans = (ans + k - j) % MOD;\n}\nreturn ans;\n}\n\nprivate int search(int[] s, int x, int left, int right) {\nwhile (left < right) {\nint mid = (left + right) >> 1;\nif (s[mid] >= x) {\nright = mid;\n} else {\nleft = mid + 1;\n}\n}\nreturn left;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar waysToSplit = function (nums) {\nconst mod = 1e9 + 7;\nconst n = nums.length;\nconst s = new Array(n).fill(nums[0]);\nfor (let i = 1; i < n; ++i) {\ns[i] = s[i - 1] + nums[i];\n}\nfunction search(s, x, left, right) {\nwhile (left < right) {\nconst mid = (left + right) >> 1;\nif (s[mid] >= x) {\nright = mid;\n} else {\nleft = mid + 1;\n}\n}\nreturn left;\n}\nlet ans = 0;\nfor (let i = 0; i < n - 2; ++i) {\nconst j = search(s, s[i] << 1, i + 1, n - 1);\nconst k = search(s, ((s[n - 1] + s[i]) >> 1) + 1, j, n - 1);\nans = (ans + k - j) % mod;\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nconst int mod = 1e9 + 7;\n\nint waysToSplit(vector<int>& nums) {\nint n = nums.size();\nvector<int> s(n, nums[0]);\nfor (int i = 1; i < n; ++i) s[i] = s[i - 1] + nums[i];\nint ans = 0;\nfor (int i = 0; i < n - 2; ++i) {\nint j = lower_bound(s.begin() + i + 1, s.begin() + n - 1, s[i] << 1) - s.begin();\nint k = upper_bound(s.begin() + j, s.begin() + n - 1, (s[n - 1] + s[i]) >> 1) - s.begin();\nans = (ans + k - j) % mod;\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1730", "level": "middle", "question_description": "You are starving and you want to eat food as quickly as possible. You want to find the shortest path to arrive at any food cell.\nYou are given an m x n character matrix, grid, of these different types of cells:\n&#39;*&#39; is your location. There is exactly one &#39;*&#39; cell.\n&#39;#&#39; is a food cell. There may be multiple food cells.\n&#39;O&#39; is free space, and you can travel through these cells.\n&#39;X&#39; is an obstacle, and you cannot travel through these cells.\nYou can travel to any adjacent cell north, east, south, or west of your current location if there is not an obstacle.\nReturn the length of the shortest path for you to reach any food cell. If there is no path for you to reach food, return -1.", "examples": [], "constraints": "\nConstraints:\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 200\ngrid[row][col] is &#39;*&#39;, &#39;X&#39;, &#39;O&#39;, or &#39;#&#39;.\nThe grid contains exactly one &#39;*&#39;.\n", "java_context": "\nclass Solution {\n    private int[] dirs = {-1, 0, 1, 0, -1};\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {character[][]} grid\n* @return {number}\n*/\nvar getFood = function (grid) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    const static inline vector<int> dirs = {-1, 0, 1, 0, -1};\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\nprivate int[] dirs = {-1, 0, 1, 0, -1};\n\npublic int getFood(char[][] grid) {\nint m = grid.length, n = grid[0].length;\nDeque<int[]> q = new ArrayDeque<>();\nfor (int i = 0, x = 1; i < m && x == 1; ++i) {\nfor (int j = 0; j < n; ++j) {\nif (grid[i][j] == '*') {\nq.offer(new int[] {i, j});\nx = 0;\nbreak;\n}\n}\n}\nint ans = 0;\nwhile (!q.isEmpty()) {\n++ans;\nfor (int t = q.size(); t > 0; --t) {\nvar p = q.poll();\nfor (int k = 0; k < 4; ++k) {\nint x = p[0] + dirs[k];\nint y = p[1] + dirs[k + 1];\nif (x >= 0 && x < m && y >= 0 && y < n) {\nif (grid[x][y] == '#') {\nreturn ans;\n}\nif (grid[x][y] == 'O') {\ngrid[x][y] = 'X';\nq.offer(new int[] {x, y});\n}\n}\n}\n}\n}\nreturn -1;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {character[][]} grid\n* @return {number}\n*/\nvar getFood = function (grid) {\nconst m = grid.length;\nconst n = grid[0].length;\nconst dirs = [-1, 0, 1, 0, -1];\nconst q = [];\nfor (let i = 0, x = 1; i < m && x == 1; ++i) {\nfor (let j = 0; j < n; ++j) {\nif (grid[i][j] == '*') {\nq.push([i, j]);\nx = 0;\nbreak;\n}\n}\n}\nlet ans = 0;\nwhile (q.length) {\n++ans;\nfor (let t = q.length; t > 0; --t) {\nconst [i, j] = q.shift();\nfor (let k = 0; k < 4; ++k) {\nconst x = i + dirs[k];\nconst y = j + dirs[k + 1];\nif (x >= 0 && x < m && y >= 0 && y < n) {\nif (grid[x][y] == '#') {\nreturn ans;\n}\nif (grid[x][y] == 'O') {\ngrid[x][y] = 'X';\nq.push([x, y]);\n}\n}\n}\n}\n}\nreturn -1;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nconst static inline vector<int> dirs = {-1, 0, 1, 0, -1};\n\nint getFood(vector<vector<char>>& grid) {\nint m = grid.size(), n = grid[0].size();\nqueue<pair<int, int>> q;\nfor (int i = 0, x = 1; i < m && x == 1; ++i) {\nfor (int j = 0; j < n; ++j) {\nif (grid[i][j] == '*') {\nq.emplace(i, j);\nx = 0;\nbreak;\n}\n}\n}\nint ans = 0;\nwhile (!q.empty()) {\n++ans;\nfor (int t = q.size(); t; --t) {\nauto [i, j] = q.front();\nq.pop();\nfor (int k = 0; k < 4; ++k) {\nint x = i + dirs[k], y = j + dirs[k + 1];\nif (x >= 0 && x < m && y >= 0 && y < n) {\nif (grid[x][y] == '#') return ans;\nif (grid[x][y] == 'O') {\ngrid[x][y] = 'X';\nq.emplace(x, y);\n}\n}\n}\n}\n}\nreturn -1;\n}\n};\n"]}, {"leetCodeID": "1760", "level": "middle", "question_description": "You are given an integer array nums where the ith bag contains nums[i] balls. You are also given an integer maxOperations.\nYou can perform the following operation at most maxOperations times:\nTake any bag of balls and divide it into two new bags with a positive number of balls.\nFor example, a bag of 5 balls can become two new bags of 1 and 4 balls, or two new bags of 2 and 3 balls.\nYour penalty is the maximum number of balls in a bag. You want to minimize your penalty after the operations.\nReturn the minimum possible penalty after performing the operations.", "examples": ["Example 1:\nInput: nums = [9], maxOperations = 2\nOutput: 3\nExplanation:\n- Divide the bag with 9 balls into two bags of sizes 6 and 3. [9] -&gt; [6,3].\n- Divide the bag with 6 balls into two bags of sizes 3 and 3. [6,3] -&gt; [3,3,3].\nThe bag with the most number of balls has 3 balls, so your penalty is 3 and you should return 3.\n", "Example 2:\nInput: nums = [2,4,8,2], maxOperations = 4\nOutput: 2\nExplanation:\n- Divide the bag with 8 balls into two bags of sizes 4 and 4. [2,4,8,2] -&gt; [2,4,4,4,2].\n- Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,4,4,4,2] -&gt; [2,2,2,4,4,2].\n- Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,2,2,4,4,2] -&gt; [2,2,2,2,2,4,2].\n- Divide the bag with 4 balls into two bags of sizes 2 and 2. [2,2,2,2,2,4,2] -&gt; [2,2,2,2,2,2,2,2].\nThe bag with the most number of balls has 2 balls, so your penalty is 2, and you should return 2.\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 105\n1 <= maxOperations, nums[i] <= 109\n", "java_context": "\nclass Solution {\n    public int minimumSize(int[] nums, int maxOperations) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @param {number} maxOperations\n* @return {number}\n*/\nvar minimumSize = function (nums, maxOperations) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int minimumSize(vector<int>& nums, int maxOperations) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int minimumSize(int[] nums, int maxOperations) {\nint left = 1, right = 0;\nfor (int x : nums) {\nright = Math.max(right, x);\n}\nwhile (left < right) {\nint mid = (left + right) >> 1;\nlong cnt = 0;\nfor (int x : nums) {\ncnt += (x - 1) / mid;\n}\nif (cnt <= maxOperations) {\nright = mid;\n} else {\nleft = mid + 1;\n}\n}\nreturn left;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @param {number} maxOperations\n* @return {number}\n*/\nvar minimumSize = function (nums, maxOperations) {\nlet left = 1;\nlet right = Math.max(...nums);\nwhile (left < right) {\nconst mid = (left + right) >> 1;\nlet cnt = 0;\nfor (const x of nums) {\ncnt += ~~((x - 1) / mid);\n}\nif (cnt <= maxOperations) {\nright = mid;\n} else {\nleft = mid + 1;\n}\n}\nreturn left;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint minimumSize(vector<int>& nums, int maxOperations) {\nint left = 1, right = *max_element(nums.begin(), nums.end());\nwhile (left < right) {\nint mid = (left + right) >> 1;\nlong long cnt = 0;\nfor (int x : nums) {\ncnt += (x - 1) / mid;\n}\nif (cnt <= maxOperations) {\nright = mid;\n} else {\nleft = mid + 1;\n}\n}\nreturn left;\n}\n};\n"]}, {"leetCodeID": "1762", "level": "middle", "question_description": "There are n buildings in a line. You are given an integer array heights of size n that represents the heights of the buildings in the line.\nThe ocean is to the right of the buildings. A building has an ocean view if the building can see the ocean without obstructions. Formally, a building has an ocean view if all the buildings to its right have a smaller height.\nReturn a list of indices (0-indexed) of buildings that have an ocean view, sorted in increasing order.", "examples": ["Example 1:\nInput: heights = [4,2,3,1]\nOutput: [0,2,3]\nExplanation: Building 1 (0-indexed) does not have an ocean view because building 2 is taller.\n", "Example 2:\nInput: heights = [4,3,2,1]\nOutput: [0,1,2,3]\nExplanation: All the buildings have an ocean view.\n", "Example 3:\nInput: heights = [1,3,2,4]\nOutput: [3]\nExplanation: Only building 3 has an ocean view.\n"], "constraints": "\nConstraints:\n1 <= heights.length <= 105\n1 <= heights[i] <= 109\n", "java_context": "\nclass Solution {\n    public int[] findBuildings(int[] heights) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} heights\n* @return {number[]}\n*/\nvar findBuildings = function (heights) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> findBuildings(vector<int>& heights) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int[] findBuildings(int[] heights) {\nint n = heights.length;\nList<Integer> ans = new ArrayList<>();\nint mx = 0;\nfor (int i = heights.length - 1; i >= 0; --i) {\nif (heights[i] > mx) {\nans.add(i);\nmx = heights[i];\n}\n}\nCollections.reverse(ans);\nreturn ans.stream().mapToInt(Integer::intValue).toArray();\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} heights\n* @return {number[]}\n*/\nvar findBuildings = function (heights) {\nconst ans = [];\nlet mx = 0;\nfor (let i = heights.length - 1; ~i; --i) {\nif (heights[i] > mx) {\nans.push(i);\nmx = heights[i];\n}\n}\nreturn ans.reverse();\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> findBuildings(vector<int>& heights) {\nvector<int> ans;\nint mx = 0;\nfor (int i = heights.size() - 1; ~i; --i) {\nif (heights[i] > mx) {\nans.push_back(i);\nmx = heights[i];\n}\n}\nreverse(ans.begin(), ans.end());\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1774", "level": "middle", "question_description": "You would like to make dessert and are preparing to buy the ingredients. You have n ice cream base flavors and m types of toppings to choose from. You must follow these rules when making your dessert:\nThere must be exactly one ice cream base.\nYou can add one or more types of topping or have no toppings at all.\nThere are at most two of each type of topping.\nYou are given three inputs:\nbaseCosts, an integer array of length n, where each baseCosts[i] represents the price of the ith ice cream base flavor.\ntoppingCosts, an integer array of length m, where each toppingCosts[i] is the price of one of the ith topping.\ntarget, an integer representing your target price for dessert.\nYou want to make a dessert with a total cost as close to target as possible.\nReturn the closest possible cost of the dessert to target. If there are multiple, return the lower one.", "examples": ["Example 1:\nInput: baseCosts = [1,7], toppingCosts = [3,4], target = 10\nOutput: 10\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 7\n- Take 1 of topping 0: cost 1 x 3 = 3\n- Take 0 of topping 1: cost 0 x 4 = 0\nTotal: 7 + 3 + 0 = 10.\n", "Example 2:\nInput: baseCosts = [2,3], toppingCosts = [4,5,100], target = 18\nOutput: 17\nExplanation: Consider the following combination (all 0-indexed):\n- Choose base 1: cost 3\n- Take 1 of topping 0: cost 1 x 4 = 4\n- Take 2 of topping 1: cost 2 x 5 = 10\n- Take 0 of topping 2: cost 0 x 100 = 0\nTotal: 3 + 4 + 10 + 0 = 17. You cannot make a dessert with a total cost of 18.\n", "Example 3:\nInput: baseCosts = [3,10], toppingCosts = [2,5], target = 9\nOutput: 8\nExplanation: It is possible to make desserts with cost 8 and 10. Return 8 as it is the lower cost.\n"], "constraints": "\nConstraints:\nn == baseCosts.length\nm == toppingCosts.length\n1 <= n, m <= 10\n1 <= baseCosts[i], toppingCosts[i] <= 104\n1 <= target <= 104\n", "java_context": "\nclass Solution {\n    private List<Integer> arr = new ArrayList<>();\n        // your code\n    }\n}", "js_context": "\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    const int inf = INT_MAX;\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\nprivate List<Integer> arr = new ArrayList<>();\nprivate int[] ts;\nprivate int inf = 1 << 30;\n\npublic int closestCost(int[] baseCosts, int[] toppingCosts, int target) {\nts = toppingCosts;\ndfs(0, 0);\nCollections.sort(arr);\nint d = inf, ans = inf;\n\n// \u9009\u62e9\u4e00\u79cd\u51b0\u6fc0\u6dcb\u57fa\u6599\nfor (int x : baseCosts) {\n// \u679a\u4e3e\u5b50\u96c6\u548c\nfor (int y : arr) {\n// \u4e8c\u5206\u67e5\u627e\nint i = search(target - x - y);\nfor (int j : new int[] {i, i - 1}) {\nif (j >= 0 && j < arr.size()) {\nint t = Math.abs(x + y + arr.get(j) - target);\nif (d > t || (d == t && ans > x + y + arr.get(j))) {\nd = t;\nans = x + y + arr.get(j);\n}\n}\n}\n}\n}\nreturn ans;\n}\n\nprivate int search(int x) {\nint left = 0, right = arr.size();\nwhile (left < right) {\nint mid = (left + right) >> 1;\nif (arr.get(mid) >= x) {\nright = mid;\n} else {\nleft = mid + 1;\n}\n}\nreturn left;\n}\n\nprivate void dfs(int i, int t) {\nif (i >= ts.length) {\narr.add(t);\nreturn;\n}\ndfs(i + 1, t);\ndfs(i + 1, t + ts[i]);\n}\n}\n"], "js_solutions": ["\nconst closestCost = function (baseCosts, toppingCosts, target) {\nlet closestDessertCost = -Infinity;\nfunction dfs(dessertCost, j) {\nconst tarCurrDiff = Math.abs(target - dessertCost);\nconst tarCloseDiff = Math.abs(target - closestDessertCost);\nif (tarCurrDiff < tarCloseDiff) {\nclosestDessertCost = dessertCost;\n} else if (tarCurrDiff === tarCloseDiff && dessertCost < closestDessertCost) {\nclosestDessertCost = dessertCost;\n}\nif (dessertCost > target) return;\nif (j === toppingCosts.length) return;\nfor (let count = 0; count <= 2; count++) {\ndfs(dessertCost + count * toppingCosts[j], j + 1);\n}\n}\nfor (let i = 0; i < baseCosts.length; i++) {\ndfs(baseCosts[i], 0);\n}\nreturn closestDessertCost;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nconst int inf = INT_MAX;\nint closestCost(vector<int>& baseCosts, vector<int>& toppingCosts, int target) {\nvector<int> arr;\nfunction<void(int, int)> dfs = [&](int i, int t) {\nif (i >= toppingCosts.size()) {\narr.push_back(t);\nreturn;\n}\ndfs(i + 1, t);\ndfs(i + 1, t + toppingCosts[i]);\n};\ndfs(0, 0);\nsort(arr.begin(), arr.end());\nint d = inf, ans = inf;\n// \u9009\u62e9\u4e00\u79cd\u51b0\u6fc0\u6dcb\u57fa\u6599\nfor (int x : baseCosts) {\n// \u679a\u4e3e\u5b50\u96c6\u548c\nfor (int y : arr) {\n// \u4e8c\u5206\u67e5\u627e\nint i = lower_bound(arr.begin(), arr.end(), target - x - y) - arr.begin();\nfor (int j = i - 1; j < i + 1; ++j) {\nif (j >= 0 && j < arr.size()) {\nint t = abs(x + y + arr[j] - target);\nif (d > t || (d == t && ans > x + y + arr[j])) {\nd = t;\nans = x + y + arr[j];\n}\n}\n}\n}\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1781", "level": "middle", "question_description": "The beauty of a string is the difference in frequencies between the most frequent and least frequent characters.\nFor example, the beauty of &quot;abaacc&quot; is 3 - 1 = 2.\nGiven a string s, return the sum of beauty of all of its substrings.", "examples": ["Example 1:\nInput: s = &quot;aabcb&quot;\nOutput: 5\nExplanation: The substrings with non-zero beauty are [&quot;aab&quot;,&quot;aabc&quot;,&quot;aabcb&quot;,&quot;abcb&quot;,&quot;bcb&quot;], each with beauty equal to 1.", "Example 2:\nInput: s = &quot;aabcbaa&quot;\nOutput: 17\n"], "constraints": "\nConstraints:\n1 <= s.length <= 500\ns consists of only lowercase English letters.\n", "java_context": "\nclass Solution {\n    public int beautySum(String s) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} s\n* @return {number}\n*/\nvar beautySum = function (s) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int beautySum(string s) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int beautySum(String s) {\nint ans = 0;\nint n = s.length();\nfor (int i = 0; i < n; ++i) {\nint[] cnt = new int[26];\nfor (int j = i; j < n; ++j) {\n++cnt[s.charAt(j) - 'a'];\nint mi = 1000, mx = 0;\nfor (int v : cnt) {\nif (v > 0) {\nmi = Math.min(mi, v);\nmx = Math.max(mx, v);\n}\n}\nans += mx - mi;\n}\n}\nreturn ans;\n}\n}\n", "\nclass Solution {\npublic int beautySum(String s) {\nint n = s.length();\nint ans = 0;\nfor (int i = 0; i < n; ++i) {\nint[] cnt = new int[26];\nMap<Integer, Integer> freq = new HashMap<>();\nint mi = 1, mx = 1;\nfor (int j = i; j < n; ++j) {\nint k = s.charAt(j) - 'a';\nfreq.merge(cnt[k], -1, Integer::sum);\n++cnt[k];\nfreq.merge(cnt[k], 1, Integer::sum);\n\nif (cnt[k] == 1) {\nmi = 1;\n}\nif (freq.getOrDefault(mi, 0) == 0) {\n++mi;\n}\nif (cnt[k] > mx) {\nmx = cnt[k];\n}\nans += mx - mi;\n}\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} s\n* @return {number}\n*/\nvar beautySum = function (s) {\nlet ans = 0;\nfor (let i = 0; i < s.length; ++i) {\nconst cnt = new Map();\nfor (let j = i; j < s.length; ++j) {\ncnt.set(s[j], (cnt.get(s[j]) || 0) + 1);\nconst t = Array.from(cnt.values());\nans += Math.max(...t) - Math.min(...t);\n}\n}\nreturn ans;\n};\n", "\n/**\n* @param {string} s\n* @return {number}\n*/\nvar beautySum = function (s) {\nconst n = s.length;\nlet ans = 0;\nfor (let i = 0; i < n; ++i) {\nconst cnt = Array(26).fill(0);\nconst freq = new Map();\nlet [mi, mx] = [1, 1];\nfor (let j = i; j < n; ++j) {\nconst k = s[j].charCodeAt() - 97;\nfreq.set(cnt[k], (freq.get(cnt[k]) || 0) - 1);\n++cnt[k];\nfreq.set(cnt[k], (freq.get(cnt[k]) || 0) + 1);\nif (cnt[k] === 1) {\nmi = 1;\n}\nif (freq.get(mi) === 0) {\n++mi;\n}\nif (cnt[k] > mx) {\nmx = cnt[k];\n}\nans += mx - mi;\n}\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint beautySum(string s) {\nint ans = 0;\nint n = s.size();\nint cnt[26];\nfor (int i = 0; i < n; ++i) {\nmemset(cnt, 0, sizeof cnt);\nfor (int j = i; j < n; ++j) {\n++cnt[s[j] - 'a'];\nint mi = 1000, mx = 0;\nfor (int& v : cnt) {\nif (v > 0) {\nmi = min(mi, v);\nmx = max(mx, v);\n}\n}\nans += mx - mi;\n}\n}\nreturn ans;\n}\n};\n", "\nclass Solution {\npublic:\nint beautySum(string s) {\nint n = s.size();\nint ans = 0;\nfor (int i = 0; i < n; ++i) {\nint cnt[26]{};\nunordered_map<int, int> freq;\nint mi = 1, mx = 1;\nfor (int j = i; j < n; ++j) {\nint k = s[j] - 'a';\n--freq[cnt[k]];\n++cnt[k];\n++freq[cnt[k]];\n\nif (cnt[k] == 1) {\nmi = 1;\n}\nif (freq[mi] == 0) {\n++mi;\n}\nif (cnt[k] > mx) {\nmx = cnt[k];\n}\nans += mx - mi;\n}\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1814", "level": "middle", "question_description": "You are given an array nums that consists of non-negative integers. Let us define rev(x) as the reverse of the non-negative integer x. For example, rev(123) = 321, and rev(120) = 21. A pair of indices (i, j) is nice if it satisfies all of the following conditions:\n0 &lt;= i &lt; j &lt; nums.length\nnums[i] + rev(nums[j]) == nums[j] + rev(nums[i])\nReturn the number of nice pairs of indices. Since that number can be too large, return it modulo 109 + 7.", "examples": ["Example 1:\nInput: nums = [42,11,1,97]\nOutput: 2\nExplanation: The two pairs are:\n- (0,3) : 42 + rev(97) = 42 + 79 = 121, 97 + rev(42) = 97 + 24 = 121.\n- (1,2) : 11 + rev(1) = 11 + 1 = 12, 1 + rev(11) = 1 + 11 = 12.\n", "Example 2:\nInput: nums = [13,10,35,24,76]\nOutput: 4\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 105\n0 <= nums[i] <= 109\n", "java_context": "\nclass Solution {\n    public int countNicePairs(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar countNicePairs = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int countNicePairs(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int countNicePairs(int[] nums) {\nMap<Integer, Integer> cnt = new HashMap<>();\nfor (int x : nums) {\nint y = x - rev(x);\ncnt.merge(y, 1, Integer::sum);\n}\nfinal int mod = (int) 1e9 + 7;\nlong ans = 0;\nfor (int v : cnt.values()) {\nans = (ans + (long) v * (v - 1) / 2) % mod;\n}\nreturn (int) ans;\n}\n\nprivate int rev(int x) {\nint y = 0;\nfor (; x > 0; x /= 10) {\ny = y * 10 + x % 10;\n}\nreturn y;\n}\n}\n", "\nclass Solution {\npublic int countNicePairs(int[] nums) {\nMap<Integer, Integer> cnt = new HashMap<>();\nfinal int mod = (int) 1e9 + 7;\nint ans = 0;\nfor (int x : nums) {\nint y = x - rev(x);\nans = (ans + cnt.getOrDefault(y, 0)) % mod;\ncnt.merge(y, 1, Integer::sum);\n}\nreturn ans;\n}\n\nprivate int rev(int x) {\nint y = 0;\nfor (; x > 0; x /= 10) {\ny = y * 10 + x % 10;\n}\nreturn y;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar countNicePairs = function (nums) {\nconst rev = x => {\nlet y = 0;\nfor (; x > 0; x = Math.floor(x / 10)) {\ny = y * 10 + (x % 10);\n}\nreturn y;\n};\nconst cnt = new Map();\nfor (const x of nums) {\nconst y = x - rev(x);\ncnt.set(y, (cnt.get(y) | 0) + 1);\n}\nlet ans = 0;\nconst mod = 1e9 + 7;\nfor (const [_, v] of cnt) {\nans = (ans + Math.floor((v * (v - 1)) / 2)) % mod;\n}\nreturn ans;\n};\n", "\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar countNicePairs = function (nums) {\nconst rev = x => {\nlet y = 0;\nfor (; x > 0; x = Math.floor(x / 10)) {\ny = y * 10 + (x % 10);\n}\nreturn y;\n};\nlet ans = 0;\nconst mod = 1e9 + 7;\nconst cnt = new Map();\nfor (const x of nums) {\nconst y = x - rev(x);\nconst v = cnt.get(y) | 0;\nans = (ans + v) % mod;\ncnt.set(y, v + 1);\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint countNicePairs(vector<int>& nums) {\nauto rev = [](int x) {\nint y = 0;\nfor (; x > 0; x /= 10) {\ny = y * 10 + x % 10;\n}\nreturn y;\n};\nunordered_map<int, int> cnt;\nfor (int& x : nums) {\nint y = x - rev(x);\ncnt[y]++;\n}\nlong long ans = 0;\nconst int mod = 1e9 + 7;\nfor (auto& [_, v] : cnt) {\nans = (ans + 1ll * v * (v - 1) / 2) % mod;\n}\nreturn ans;\n}\n};\n", "\nclass Solution {\npublic:\nint countNicePairs(vector<int>& nums) {\nauto rev = [](int x) {\nint y = 0;\nfor (; x > 0; x /= 10) {\ny = y * 10 + x % 10;\n}\nreturn y;\n};\nunordered_map<int, int> cnt;\nint ans = 0;\nconst int mod = 1e9 + 7;\nfor (int& x : nums) {\nint y = x - rev(x);\nans = (ans + cnt[y]++) % mod;\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1818", "level": "middle", "question_description": "You are given two positive integer arrays nums1 and nums2, both of length n.\nThe absolute sum difference of arrays nums1 and nums2 is defined as the sum of |nums1[i] - nums2[i]| for each 0 &lt;= i &lt; n (0-indexed).\nYou can replace at most one element of nums1 with any other element in nums1 to minimize the absolute sum difference.\nReturn the minimum absolute sum difference after replacing at most one element in the array nums1. Since the answer may be large, return it modulo 109 + 7.\n|x| is defined as:\nx if x &gt;= 0, or\n-x if x &lt; 0.", "examples": ["Example 1:\nInput: nums1 = [1,7,5], nums2 = [2,3,5]\nOutput: 3\nExplanation: There are two possible optimal solutions:\n- Replace the second element with the first: [1,7,5] =&gt; [1,1,5], or\n- Replace the second element with the third: [1,7,5] =&gt; [1,5,5].\nBoth will yield an absolute sum difference of |1-2| + (|1-3| or |5-3|) + |5-5| = 3.\n", "Example 2:\nInput: nums1 = [2,4,6,8,10], nums2 = [2,4,6,8,10]\nOutput: 0\nExplanation: nums1 is equal to nums2 so no replacement is needed. This will result in an\nabsolute sum difference of 0.\n", "Example 3:\nInput: nums1 = [1,10,4,4,2,7], nums2 = [9,3,5,1,7,4]\nOutput: 20\nExplanation: Replace the first element with the second: [1,10,4,4,2,7] =&gt; [10,10,4,4,2,7].\nThis yields an absolute sum difference of |10-9| + |10-3| + |4-5| + |4-1| + |2-7| + |7-4| = 20\n"], "constraints": "\nConstraints:\nn == nums1.length\nn == nums2.length\n1 <= n <= 105\n1 <= nums1[i], nums2[i] <= 105\n", "java_context": "\nclass Solution {\n    public int minAbsoluteSumDiff(int[] nums1, int[] nums2) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums1\n* @param {number[]} nums2\n* @return {number}\n*/\nvar minAbsoluteSumDiff = function (nums1, nums2) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int minAbsoluteSumDiff(vector<int>& nums1, vector<int>& nums2) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int minAbsoluteSumDiff(int[] nums1, int[] nums2) {\nfinal int mod = (int) 1e9 + 7;\nint[] nums = nums1.clone();\nArrays.sort(nums);\nint s = 0, n = nums.length;\nfor (int i = 0; i < n; ++i) {\ns = (s + Math.abs(nums1[i] - nums2[i])) % mod;\n}\nint mx = 0;\nfor (int i = 0; i < n; ++i) {\nint d1 = Math.abs(nums1[i] - nums2[i]);\nint d2 = 1 << 30;\nint j = search(nums, nums2[i]);\nif (j < n) {\nd2 = Math.min(d2, Math.abs(nums[j] - nums2[i]));\n}\nif (j > 0) {\nd2 = Math.min(d2, Math.abs(nums[j - 1] - nums2[i]));\n}\nmx = Math.max(mx, d1 - d2);\n}\nreturn (s - mx + mod) % mod;\n}\n\nprivate int search(int[] nums, int x) {\nint left = 0, right = nums.length;\nwhile (left < right) {\nint mid = (left + right) >>> 1;\nif (nums[mid] >= x) {\nright = mid;\n} else {\nleft = mid + 1;\n}\n}\nreturn left;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums1\n* @param {number[]} nums2\n* @return {number}\n*/\nvar minAbsoluteSumDiff = function (nums1, nums2) {\nconst mod = 10 ** 9 + 7;\nconst nums = [...nums1];\nnums.sort((a, b) => a - b);\nconst n = nums.length;\nlet s = 0;\nfor (let i = 0; i < n; ++i) {\ns = (s + Math.abs(nums1[i] - nums2[i])) % mod;\n}\nlet mx = 0;\nfor (let i = 0; i < n; ++i) {\nconst d1 = Math.abs(nums1[i] - nums2[i]);\nlet d2 = 1 << 30;\nlet j = search(nums, nums2[i]);\nif (j < n) {\nd2 = Math.min(d2, Math.abs(nums[j] - nums2[i]));\n}\nif (j) {\nd2 = Math.min(d2, Math.abs(nums[j - 1] - nums2[i]));\n}\nmx = Math.max(mx, d1 - d2);\n}\nreturn (s - mx + mod) % mod;\n};\n\nfunction search(nums, x) {\nlet left = 0;\nlet right = nums.length;\nwhile (left < right) {\nconst mid = (left + right) >> 1;\nif (nums[mid] >= x) {\nright = mid;\n} else {\nleft = mid + 1;\n}\n}\nreturn left;\n}\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint minAbsoluteSumDiff(vector<int>& nums1, vector<int>& nums2) {\nconst int mod = 1e9 + 7;\nvector<int> nums(nums1);\nsort(nums.begin(), nums.end());\nint s = 0, n = nums.size();\nfor (int i = 0; i < n; ++i) {\ns = (s + abs(nums1[i] - nums2[i])) % mod;\n}\nint mx = 0;\nfor (int i = 0; i < n; ++i) {\nint d1 = abs(nums1[i] - nums2[i]);\nint d2 = 1 << 30;\nint j = lower_bound(nums.begin(), nums.end(), nums2[i]) - nums.begin();\nif (j < n) {\nd2 = min(d2, abs(nums[j] - nums2[i]));\n}\nif (j) {\nd2 = min(d2, abs(nums[j - 1] - nums2[i]));\n}\nmx = max(mx, d1 - d2);\n}\nreturn (s - mx + mod) % mod;\n}\n};\n"]}, {"leetCodeID": "1829", "level": "middle", "question_description": "You are given a sorted array nums of n non-negative integers and an integer maximumBit. You want to perform the following query n times:\nFind a non-negative integer k &lt; 2maximumBit such that nums[0] XOR nums[1] XOR ... XOR nums[nums.length-1] XOR k is maximized. k is the answer to the ith query.\nRemove the last element from the current array nums.\nReturn an array answer, where answer[i] is the answer to the ith query.", "examples": ["Example 1:\nInput: nums = [0,1,1,3], maximumBit = 2\nOutput: [0,3,2,3]\nExplanation: The queries are answered as follows:\n1st query: nums = [0,1,1,3], k = 0 since 0 XOR 1 XOR 1 XOR 3 XOR 0 = 3.\n2nd query: nums = [0,1,1], k = 3 since 0 XOR 1 XOR 1 XOR 3 = 3.\n3rd query: nums = [0,1], k = 2 since 0 XOR 1 XOR 2 = 3.\n4th query: nums = [0], k = 3 since 0 XOR 3 = 3.\n", "Example 2:\nInput: nums = [2,3,4,7], maximumBit = 3\nOutput: [5,2,6,5]\nExplanation: The queries are answered as follows:\n1st query: nums = [2,3,4,7], k = 5 since 2 XOR 3 XOR 4 XOR 7 XOR 5 = 7.\n2nd query: nums = [2,3,4], k = 2 since 2 XOR 3 XOR 4 XOR 2 = 7.\n3rd query: nums = [2,3], k = 6 since 2 XOR 3 XOR 6 = 7.\n4th query: nums = [2], k = 5 since 2 XOR 5 = 7.\n", "Example 3:\nInput: nums = [0,1,2,2,5,7], maximumBit = 3\nOutput: [4,3,6,4,6,7]\n"], "constraints": "\nConstraints:\nnums.length == n\n1 <= n <= 105\n1 <= maximumBit <= 20\n0 <= nums[i] < 2maximumBit\nnums\u200b\u200b\u200b is sorted in ascending order.\n", "java_context": "\nclass Solution {\n    public int[] getMaximumXor(int[] nums, int maximumBit) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @param {number} maximumBit\n* @return {number[]}\n*/\nvar getMaximumXor = function (nums, maximumBit) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> getMaximumXor(vector<int>& nums, int maximumBit) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int[] getMaximumXor(int[] nums, int maximumBit) {\nint n = nums.length;\nint xs = 0;\nfor (int x : nums) {\nxs ^= x;\n}\nint[] ans = new int[n];\nfor (int i = 0; i < n; ++i) {\nint x = nums[n - i - 1];\nint k = 0;\nfor (int j = maximumBit - 1; j >= 0; --j) {\nif (((xs >> j) & 1) == 0) {\nk |= 1 << j;\n}\n}\nans[i] = k;\nxs ^= x;\n}\nreturn ans;\n}\n}\n", "\nclass Solution {\npublic int[] getMaximumXor(int[] nums, int maximumBit) {\nint xs = 0;\nfor (int x : nums) {\nxs ^= x;\n}\nint mask = (1 << maximumBit) - 1;\nint n = nums.length;\nint[] ans = new int[n];\nfor (int i = 0; i < n; ++i) {\nint x = nums[n - i - 1];\nint k = xs ^ mask;\nans[i] = k;\nxs ^= x;\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @param {number} maximumBit\n* @return {number[]}\n*/\nvar getMaximumXor = function (nums, maximumBit) {\nlet xs = 0;\nfor (const x of nums) {\nxs ^= x;\n}\nconst n = nums.length;\nconst ans = new Array(n);\nfor (let i = 0; i < n; ++i) {\nconst x = nums[n - i - 1];\nlet k = 0;\nfor (let j = maximumBit - 1; j >= 0; --j) {\nif (((xs >> j) & 1) == 0) {\nk |= 1 << j;\n}\n}\nans[i] = k;\nxs ^= x;\n}\nreturn ans;\n};\n", "\n/**\n* @param {number[]} nums\n* @param {number} maximumBit\n* @return {number[]}\n*/\nvar getMaximumXor = function (nums, maximumBit) {\nlet xs = 0;\nfor (const x of nums) {\nxs ^= x;\n}\nconst mask = (1 << maximumBit) - 1;\nconst n = nums.length;\nconst ans = new Array(n);\nfor (let i = 0; i < n; ++i) {\nconst x = nums[n - i - 1];\nlet k = xs ^ mask;\nans[i] = k;\nxs ^= x;\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> getMaximumXor(vector<int>& nums, int maximumBit) {\nint xs = 0;\nfor (int& x : nums) {\nxs ^= x;\n}\nint n = nums.size();\nvector<int> ans(n);\nfor (int i = 0; i < n; ++i) {\nint x = nums[n - i - 1];\nint k = 0;\nfor (int j = maximumBit - 1; ~j; --j) {\nif ((xs >> j & 1) == 0) {\nk |= 1 << j;\n}\n}\nans[i] = k;\nxs ^= x;\n}\nreturn ans;\n}\n};\n", "\nclass Solution {\npublic:\nvector<int> getMaximumXor(vector<int>& nums, int maximumBit) {\nint xs = 0;\nfor (int& x : nums) {\nxs ^= x;\n}\nint mask = (1 << maximumBit) - 1;\nint n = nums.size();\nvector<int> ans(n);\nfor (int i = 0; i < n; ++i) {\nint x = nums[n - i - 1];\nint k = xs ^ mask;\nans[i] = k;\nxs ^= x;\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1833", "level": "middle", "question_description": "It is a sweltering summer day, and a boy wants to buy some ice cream bars.\nAt the store, there are n ice cream bars. You are given an array costs of length n, where costs[i] is the price of the ith ice cream bar in coins. The boy initially has coins coins to spend, and he wants to buy as many ice cream bars as possible. \nNote: The boy can buy the ice cream bars in any order.\nReturn the maximum number of ice cream bars the boy can buy with coins coins.\nYou must solve the problem by counting sort.", "examples": ["Example 1:\nInput: costs = [1,3,2,4,1], coins = 7\nOutput: 4\nExplanation: The boy can buy ice cream bars at indices 0,1,2,4 for a total price of 1 + 3 + 2 + 1 = 7.\n", "Example 2:\nInput: costs = [10,6,8,7,7,8], coins = 5\nOutput: 0\nExplanation: The boy cannot afford any of the ice cream bars.\n", "Example 3:\nInput: costs = [1,6,3,1,2,5], coins = 20\nOutput: 6\nExplanation: The boy can buy all the ice cream bars for a total price of 1 + 6 + 3 + 1 + 2 + 5 = 18.\n"], "constraints": "\nConstraints:\ncosts.length == n\n1 <= n <= 105\n1 <= costs[i] <= 105\n1 <= coins <= 108\n", "java_context": "\nclass Solution {\n    public int maxIceCream(int[] costs, int coins) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} costs\n* @param {number} coins\n* @return {number}\n*/\nvar maxIceCream = function (costs, coins) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int maxIceCream(vector<int>& costs, int coins) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int maxIceCream(int[] costs, int coins) {\nArrays.sort(costs);\nint n = costs.length;\nfor (int i = 0; i < n; ++i) {\nif (coins < costs[i]) {\nreturn i;\n}\ncoins -= costs[i];\n}\nreturn n;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} costs\n* @param {number} coins\n* @return {number}\n*/\nvar maxIceCream = function (costs, coins) {\ncosts.sort((a, b) => a - b);\nconst n = costs.length;\nfor (let i = 0; i < n; ++i) {\nif (coins < costs[i]) {\nreturn i;\n}\ncoins -= costs[i];\n}\nreturn n;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint maxIceCream(vector<int>& costs, int coins) {\nsort(costs.begin(), costs.end());\nint n = costs.size();\nfor (int i = 0; i < n; ++i) {\nif (coins < costs[i]) return i;\ncoins -= costs[i];\n}\nreturn n;\n}\n};\n"]}, {"leetCodeID": "1855", "level": "middle", "question_description": "You are given two non-increasing 0-indexed integer arrays nums1\u200b\u200b\u200b\u200b\u200b\u200b and nums2\u200b\u200b\u200b\u200b\u200b\u200b.\nA pair of indices (i, j), where 0 &lt;= i &lt; nums1.length and 0 &lt;= j &lt; nums2.length, is valid if both i &lt;= j and nums1[i] &lt;= nums2[j]. The distance of the pair is j - i\u200b\u200b\u200b\u200b.\nReturn the maximum distance of any valid pair (i, j). If there are no valid pairs, return 0.\nAn array arr is non-increasing if arr[i-1] &gt;= arr[i] for every 1 &lt;= i &lt; arr.length.", "examples": ["Example 1:\nInput: nums1 = [55,30,5,4,2], nums2 = [100,20,10,10,5]\nOutput: 2\nExplanation: The valid pairs are (0,0), (2,2), (2,3), (2,4), (3,3), (3,4), and (4,4).\nThe maximum distance is 2 with pair (2,4).\n", "Example 2:\nInput: nums1 = [2,2,2], nums2 = [10,10,1]\nOutput: 1\nExplanation: The valid pairs are (0,0), (0,1), and (1,1).\nThe maximum distance is 1 with pair (0,1).\n", "Example 3:\nInput: nums1 = [30,29,19,5], nums2 = [25,25,25,25,25]\nOutput: 2\nExplanation: The valid pairs are (2,2), (2,3), (2,4), (3,3), and (3,4).\nThe maximum distance is 2 with pair (2,4).\n"], "constraints": "\nConstraints:\n1 <= nums1.length, nums2.length <= 105\n1 <= nums1[i], nums2[j] <= 105\nBoth nums1 and nums2 are non-increasing.\n", "java_context": "\nclass Solution {\n    public int maxDistance(int[] nums1, int[] nums2) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums1\n* @param {number[]} nums2\n* @return {number}\n*/\nvar maxDistance = function (nums1, nums2) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int maxDistance(vector<int>& nums1, vector<int>& nums2) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int maxDistance(int[] nums1, int[] nums2) {\nint ans = 0;\nint m = nums1.length, n = nums2.length;\nfor (int i = 0; i < m; ++i) {\nint left = i, right = n - 1;\nwhile (left < right) {\nint mid = (left + right + 1) >> 1;\nif (nums2[mid] >= nums1[i]) {\nleft = mid;\n} else {\nright = mid - 1;\n}\n}\nans = Math.max(ans, left - i);\n}\nreturn ans;\n}\n}\n", "\nclass Solution {\npublic int maxDistance(int[] nums1, int[] nums2) {\nint m = nums1.length, n = nums2.length;\nint ans = 0;\nfor (int i = 0, j = 0; i < m; ++i) {\nwhile (j < n && nums1[i] <= nums2[j]) {\n++j;\n}\nans = Math.max(ans, j - i - 1);\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums1\n* @param {number[]} nums2\n* @return {number}\n*/\nvar maxDistance = function (nums1, nums2) {\nlet ans = 0;\nlet m = nums1.length;\nlet n = nums2.length;\nfor (let i = 0; i < m; ++i) {\nlet left = i;\nlet right = n - 1;\nwhile (left < right) {\nconst mid = (left + right + 1) >> 1;\nif (nums2[mid] >= nums1[i]) {\nleft = mid;\n} else {\nright = mid - 1;\n}\n}\nans = Math.max(ans, left - i);\n}\nreturn ans;\n};\n", "\n/**\n* @param {number[]} nums1\n* @param {number[]} nums2\n* @return {number}\n*/\nvar maxDistance = function (nums1, nums2) {\nlet ans = 0;\nconst m = nums1.length;\nconst n = nums2.length;\nfor (let i = 0, j = 0; i < m; ++i) {\nwhile (j < n && nums1[i] <= nums2[j]) {\nj++;\n}\nans = Math.max(ans, j - i - 1);\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint maxDistance(vector<int>& nums1, vector<int>& nums2) {\nint ans = 0;\nreverse(nums2.begin(), nums2.end());\nfor (int i = 0; i < nums1.size(); ++i) {\nint j = nums2.size() - (lower_bound(nums2.begin(), nums2.end(), nums1[i]) - nums2.begin()) - 1;\nans = max(ans, j - i);\n}\nreturn ans;\n}\n};\n", "\nclass Solution {\npublic:\nint maxDistance(vector<int>& nums1, vector<int>& nums2) {\nint m = nums1.size(), n = nums2.size();\nint ans = 0;\nfor (int i = 0, j = 0; i < m; ++i) {\nwhile (j < n && nums1[i] <= nums2[j]) {\n++j;\n}\nans = max(ans, j - i - 1);\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1860", "level": "middle", "question_description": "You are given two integers memory1 and memory2 representing the available memory in bits on two memory sticks. There is currently a faulty program running that consumes an increasing amount of memory every second.\nAt the ith second (starting from 1), i bits of memory are allocated to the stick with more available memory (or from the first memory stick if both have the same available memory). If neither stick has at least i bits of available memory, the program crashes.\nReturn an array containing [crashTime, memory1crash, memory2crash], where crashTime is the time (in seconds) when the program crashed and memory1crash and memory2crash are the available bits of memory in the first and second sticks respectively.", "examples": ["Example 1:\nInput: memory1 = 2, memory2 = 2\nOutput: [3,1,0]\nExplanation: The memory is allocated as follows:\n- At the 1st second, 1 bit of memory is allocated to stick 1. The first stick now has 1 bit of available memory.\n- At the 2nd second, 2 bits of memory are allocated to stick 2. The second stick now has 0 bits of available memory.\n- At the 3rd second, the program crashes. The sticks have 1 and 0 bits available respectively.\n", "Example 2:\nInput: memory1 = 8, memory2 = 11\nOutput: [6,0,4]\nExplanation: The memory is allocated as follows:\n- At the 1st second, 1 bit of memory is allocated to stick 2. The second stick now has 10 bit of available memory.\n- At the 2nd second, 2 bits of memory are allocated to stick 2. The second stick now has 8 bits of available memory.\n- At the 3rd second, 3 bits of memory are allocated to stick 1. The first stick now has 5 bits of available memory.\n- At the 4th second, 4 bits of memory are allocated to stick 2. The second stick now has 4 bits of available memory.\n- At the 5th second, 5 bits of memory are allocated to stick 1. The first stick now has 0 bits of available memory.\n- At the 6th second, the program crashes. The sticks have 0 and 4 bits available respectively.\n"], "constraints": "\nConstraints:\n0 <= memory1, memory2 <= 231 - 1\n", "java_context": "\nclass Solution {\n    public int[] memLeak(int memory1, int memory2) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number} memory1\n* @param {number} memory2\n* @return {number[]}\n*/\nvar memLeak = function (memory1, memory2) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> memLeak(int memory1, int memory2) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int[] memLeak(int memory1, int memory2) {\nint i = 1;\nfor (; i <= Math.max(memory1, memory2); ++i) {\nif (memory1 >= memory2) {\nmemory1 -= i;\n} else {\nmemory2 -= i;\n}\n}\nreturn new int[] {i, memory1, memory2};\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number} memory1\n* @param {number} memory2\n* @return {number[]}\n*/\nvar memLeak = function (memory1, memory2) {\nlet i = 1;\nfor (; i <= Math.max(memory1, memory2); ++i) {\nif (memory1 >= memory2) {\nmemory1 -= i;\n} else {\nmemory2 -= i;\n}\n}\nreturn [i, memory1, memory2];\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> memLeak(int memory1, int memory2) {\nint i = 1;\nfor (; i <= max(memory1, memory2); ++i) {\nif (memory1 >= memory2) {\nmemory1 -= i;\n} else {\nmemory2 -= i;\n}\n}\nreturn {i, memory1, memory2};\n}\n};\n"]}, {"leetCodeID": "1870", "level": "middle", "question_description": "You are given a floating-point number hour, representing the amount of time you have to reach the office. To commute to the office, you must take n trains in sequential order. You are also given an integer array dist of length n, where dist[i] describes the distance (in kilometers) of the ith train ride.\nEach train can only depart at an integer hour, so you may need to wait in between each train ride.\nFor example, if the 1st train ride takes 1.5 hours, you must wait for an additional 0.5 hours before you can depart on the 2nd train ride at the 2 hour mark.\nReturn the minimum positive integer speed (in kilometers per hour) that all the trains must travel at for you to reach the office on time, or -1 if it is impossible to be on time.\nTests are generated such that the answer will not exceed 107 and hour will have at most two digits after the decimal point.", "examples": ["Example 1:\nInput: dist = [1,3,2], hour = 6\nOutput: 1\nExplanation: At speed 1:\n- The first train ride takes 1/1 = 1 hour.\n- Since we are already at an integer hour, we depart immediately at the 1 hour mark. The second train takes 3/1 = 3 hours.\n- Since we are already at an integer hour, we depart immediately at the 4 hour mark. The third train takes 2/1 = 2 hours.\n- You will arrive at exactly the 6 hour mark.\n", "Example 2:\nInput: dist = [1,3,2], hour = 2.7\nOutput: 3\nExplanation: At speed 3:\n- The first train ride takes 1/3 = 0.33333 hours.\n- Since we are not at an integer hour, we wait until the 1 hour mark to depart. The second train ride takes 3/3 = 1 hour.\n- Since we are already at an integer hour, we depart immediately at the 2 hour mark. The third train takes 2/3 = 0.66667 hours.\n- You will arrive at the 2.66667 hour mark.\n", "Example 3:\nInput: dist = [1,3,2], hour = 1.9\nOutput: -1\nExplanation: It is impossible because the earliest the third train can depart is at the 2 hour mark.\n"], "constraints": "\nConstraints:\nn == dist.length\n1 <= n <= 105\n1 <= dist[i] <= 105\n1 <= hour <= 109\nThere will be at most two digits after the decimal point in hour.\n", "java_context": "\nclass Solution {\n    public int minSpeedOnTime(int[] dist, double hour) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} dist\n* @param {number} hour\n* @return {number}\n*/\nvar minSpeedOnTime = function (dist, hour) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int minSpeedOnTime(vector<int>& dist, double hour) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int minSpeedOnTime(int[] dist, double hour) {\nint left = 1, right = (int) 1e7;\nwhile (left < right) {\nint mid = (left + right) >> 1;\nif (check(dist, mid, hour)) {\nright = mid;\n} else {\nleft = mid + 1;\n}\n}\nreturn check(dist, left, hour) ? left : -1;\n}\n\nprivate boolean check(int[] dist, int speed, double hour) {\ndouble res = 0;\nfor (int i = 0; i < dist.length; ++i) {\ndouble cost = dist[i] * 1.0 / speed;\nres += (i == dist.length - 1 ? cost : Math.ceil(cost));\n}\nreturn res <= hour;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} dist\n* @param {number} hour\n* @return {number}\n*/\nvar minSpeedOnTime = function (dist, hour) {\nif (dist.length > Math.ceil(hour)) return -1;\nlet left = 1,\nright = 10 ** 7;\nwhile (left < right) {\nlet mid = (left + right) >> 1;\nif (arriveOnTime(dist, mid, hour)) {\nright = mid;\n} else {\nleft = mid + 1;\n}\n}\nreturn left;\n};\n\nfunction arriveOnTime(dist, speed, hour) {\nlet res = 0.0;\nlet n = dist.length;\nfor (let i = 0; i < n; i++) {\nlet cost = parseFloat(dist[i]) / speed;\nif (i != n - 1) {\ncost = Math.ceil(cost);\n}\nres += cost;\n}\nreturn res <= hour;\n}\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint minSpeedOnTime(vector<int>& dist, double hour) {\nint left = 1, right = 1e7;\nwhile (left < right) {\nint mid = (left + right) >> 1;\nif (check(dist, mid, hour)) {\nright = mid;\n} else {\nleft = mid + 1;\n}\n}\nreturn check(dist, left, hour) ? left : -1;\n}\n\nbool check(vector<int>& dist, int speed, double hour) {\ndouble res = 0;\nfor (int i = 0; i < dist.size(); ++i) {\ndouble cost = dist[i] * 1.0 / speed;\nres += (i == dist.size() - 1 ? cost : ceil(cost));\n}\nreturn res <= hour;\n}\n};\n"]}, {"leetCodeID": "1871", "level": "middle", "question_description": "You are given a 0-indexed binary string s and two integers minJump and maxJump. In the beginning, you are standing at index 0, which is equal to &#39;0&#39;. You can move from index i to index j if the following conditions are fulfilled:\ni + minJump &lt;= j &lt;= min(i + maxJump, s.length - 1), and\ns[j] == &#39;0&#39;.\nReturn true if you can reach index s.length - 1 in s, or false otherwise.", "examples": ["Example 1:\nInput: s = &quot;011010&quot;, minJump = 2, maxJump = 3\nOutput: true\nExplanation:\nIn the first step, move from index 0 to index 3.\nIn the second step, move from index 3 to index 5.\n", "Example 2:\nInput: s = &quot;01101110&quot;, minJump = 2, maxJump = 3\nOutput: false\n"], "constraints": "\nConstraints:\n2 <= s.length <= 105\ns[i] is either &#39;0&#39; or &#39;1&#39;.\ns[0] == &#39;0&#39;\n1 <= minJump <= maxJump < s.length\n", "java_context": "\nclass Solution {\n    public boolean canReach(String s, int minJump, int maxJump) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} s\n* @param {number} minJump\n* @param {number} maxJump\n* @return {boolean}\n*/\nvar canReach = function (s, minJump, maxJump) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    bool canReach(string s, int minJump, int maxJump) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic boolean canReach(String s, int minJump, int maxJump) {\nint n = s.length();\nint[] pre = new int[n + 1];\npre[1] = 1;\nboolean[] f = new boolean[n];\nf[0] = true;\nfor (int i = 1; i < n; ++i) {\nif (s.charAt(i) == '0') {\nint l = Math.max(0, i - maxJump);\nint r = i - minJump;\nf[i] = l <= r && pre[r + 1] - pre[l] > 0;\n}\npre[i + 1] = pre[i] + (f[i] ? 1 : 0);\n}\nreturn f[n - 1];\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} s\n* @param {number} minJump\n* @param {number} maxJump\n* @return {boolean}\n*/\nvar canReach = function (s, minJump, maxJump) {\nconst n = s.length;\nconst pre = Array(n + 1).fill(0);\npre[1] = 1;\nconst f = Array(n).fill(false);\nf[0] = true;\nfor (let i = 1; i < n; ++i) {\nif (s[i] === '0') {\nconst [l, r] = [Math.max(0, i - maxJump), i - minJump];\nf[i] = l <= r && pre[r + 1] - pre[l] > 0;\n}\npre[i + 1] = pre[i] + (f[i] ? 1 : 0);\n}\nreturn f[n - 1];\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nbool canReach(string s, int minJump, int maxJump) {\nint n = s.size();\nint pre[n + 1];\nmemset(pre, 0, sizeof(pre));\npre[1] = 1;\nbool f[n];\nmemset(f, 0, sizeof(f));\nf[0] = true;\nfor (int i = 1; i < n; ++i) {\nif (s[i] == '0') {\nint l = max(0, i - maxJump);\nint r = i - minJump;\nf[i] = l <= r && pre[r + 1] - pre[l];\n}\npre[i + 1] = pre[i] + f[i];\n}\nreturn f[n - 1];\n}\n};\n"]}, {"leetCodeID": "1881", "level": "middle", "question_description": "You are given a very large integer n, represented as a string,\u200b\u200b\u200b\u200b\u200b\u200b and an integer digit x. The digits in n and the digit x are in the inclusive range [1, 9], and n may represent a negative number.\nYou want to maximize n&#39;s numerical value by inserting x anywhere in the decimal representation of n\u200b\u200b\u200b\u200b\u200b\u200b. You cannot insert x to the left of the negative sign.\nFor example, if n = 73 and x = 6, it would be best to insert it between 7 and 3, making n = 763.\nIf n = -55 and x = 2, it would be best to insert it before the first 5, making n = -255.\nReturn a string representing the maximum value of n\u200b\u200b\u200b\u200b\u200b\u200b after the insertion.", "examples": ["Example 1:\nInput: n = &quot;99&quot;, x = 9\nOutput: &quot;999&quot;\nExplanation: The result is the same regardless of where you insert 9.\n", "Example 2:\nInput: n = &quot;-13&quot;, x = 2\nOutput: &quot;-123&quot;\nExplanation: You can make n one of {-213, -123, -132}, and the largest of those three is -123.\n"], "constraints": "\nConstraints:\n1 <= n.length <= 105\n1 <= x <= 9\nThe digits in n\u200b\u200b\u200b are in the range [1, 9].\nn is a valid representation of an integer.\nIn the case of a negative n,\u200b\u200b\u200b\u200b\u200b\u200b it will begin with &#39;-&#39;.\n", "java_context": "\nclass Solution {\n    public String maxValue(String n, int x) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} n\n* @param {number} x\n* @return {string}\n*/\nvar maxValue = function (n, x) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    string maxValue(string n, int x) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic String maxValue(String n, int x) {\nint i = 0;\nif (n.charAt(0) != '-') {\nfor (; i < n.length() && n.charAt(i) - '0' >= x; ++i)\n;\n} else {\nfor (i = 1; i < n.length() && n.charAt(i) - '0' <= x; ++i)\n;\n}\nreturn n.substring(0, i) + x + n.substring(i);\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} n\n* @param {number} x\n* @return {string}\n*/\nvar maxValue = function (n, x) {\nlet nums = [...n];\nlet sign = 1,\ni = 0;\nif (nums[0] == '-') {\nsign = -1;\ni++;\n}\nwhile (i < n.length && (nums[i] - x) * sign >= 0) {\ni++;\n}\nnums.splice(i, 0, x);\nreturn nums.join('');\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nstring maxValue(string n, int x) {\nint i = 0;\nif (n[0] != '-')\nfor (; i < n.size() && n[i] - '0' >= x; ++i)\n;\nelse\nfor (i = 1; i < n.size() && n[i] - '0' <= x; ++i)\n;\nreturn n.substr(0, i) + to_string(x) + n.substr(i);\n}\n};\n"]}, {"leetCodeID": "1891", "level": "middle", "question_description": "You are given an integer array ribbons, where ribbons[i] represents the length of the ith ribbon, and an integer k. You may cut any of the ribbons into any number of segments of positive integer lengths, or perform no cuts at all.\nFor example, if you have a ribbon of length 4, you can:\nKeep the ribbon of length 4,\nCut it into one ribbon of length 3 and one ribbon of length 1,\nCut it into two ribbons of length 2,\nCut it into one ribbon of length 2 and two ribbons of length 1, or\nCut it into four ribbons of length 1.\nYour goal is to obtain k ribbons of all the same positive integer length. You are allowed to throw away any excess ribbon as a result of cutting.\nReturn the maximum possible positive integer length that you can obtain k ribbons of, or 0 if you cannot obtain k ribbons of the same length.", "examples": ["Example 1:\nInput: ribbons = [9,7,5], k = 3\nOutput: 5\nExplanation:\n- Cut the first ribbon to two ribbons, one of length 5 and one of length 4.\n- Cut the second ribbon to two ribbons, one of length 5 and one of length 2.\n- Keep the third ribbon as it is.\nNow you have 3 ribbons of length 5.", "Example 2:\nInput: ribbons = [7,5,9], k = 4\nOutput: 4\nExplanation:\n- Cut the first ribbon to two ribbons, one of length 4 and one of length 3.\n- Cut the second ribbon to two ribbons, one of length 4 and one of length 1.\n- Cut the third ribbon to three ribbons, two of length 4 and one of length 1.\nNow you have 4 ribbons of length 4.\n", "Example 3:\nInput: ribbons = [5,7,9], k = 22\nOutput: 0\nExplanation: You cannot obtain k ribbons of the same positive integer length.\n"], "constraints": "\nConstraints:\n1 <= ribbons.length <= 105\n1 <= ribbons[i] <= 105\n1 <= k <= 109\n", "java_context": "\nclass Solution {\n    public int maxLength(int[] ribbons, int k) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} ribbons\n* @param {number} k\n* @return {number}\n*/\nvar maxLength = function (ribbons, k) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int maxLength(vector<int>& ribbons, int k) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int maxLength(int[] ribbons, int k) {\nint left = 0, right = 0;\nfor (int x : ribbons) {\nright = Math.max(right, x);\n}\nwhile (left < right) {\nint mid = (left + right + 1) >>> 1;\nint cnt = 0;\nfor (int x : ribbons) {\ncnt += x / mid;\n}\nif (cnt >= k) {\nleft = mid;\n} else {\nright = mid - 1;\n}\n}\nreturn left;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} ribbons\n* @param {number} k\n* @return {number}\n*/\nvar maxLength = function (ribbons, k) {\nlet left = 0;\nlet right = Math.max(...ribbons);\nwhile (left < right) {\nconst mid = (left + right + 1) >> 1;\nlet cnt = 0;\nfor (const x of ribbons) {\ncnt += Math.floor(x / mid);\n}\nif (cnt >= k) {\nleft = mid;\n} else {\nright = mid - 1;\n}\n}\nreturn left;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint maxLength(vector<int>& ribbons, int k) {\nint left = 0, right = *max_element(ribbons.begin(), ribbons.end());\nwhile (left < right) {\nint mid = (left + right + 1) >> 1;\nint cnt = 0;\nfor (int ribbon : ribbons) {\ncnt += ribbon / mid;\n}\nif (cnt >= k) {\nleft = mid;\n} else {\nright = mid - 1;\n}\n}\nreturn left;\n}\n};\n"]}, {"leetCodeID": "1915", "level": "middle", "question_description": "A wonderful string is a string where at most one letter appears an odd number of times.\nFor example, &quot;ccjjc&quot; and &quot;abab&quot; are wonderful, but &quot;ab&quot; is not.\nGiven a string word that consists of the first ten lowercase English letters (&#39;a&#39; through &#39;j&#39;), return the number of wonderful non-empty substrings in word. If the same substring appears multiple times in word, then count each occurrence separately.\nA substring is a contiguous sequence of characters in a string.", "examples": ["Example 1:\n\nInput: word = &quot;aba&quot;\n\nOutput: 4\n\nExplanation: The four wonderful substrings are underlined below:\n\n- &quot;aba&quot; -&gt; &quot;a&quot;\n\n- &quot;aba&quot; -&gt; &quot;b&quot;\n\n- &quot;aba&quot; -&gt; &quot;a&quot;\n\n- &quot;aba&quot; -&gt; &quot;aba&quot;\n\n", "Example 2:\n\nInput: word = &quot;aabb&quot;\n\nOutput: 9\n\nExplanation: The nine wonderful substrings are underlined below:\n\n- &quot;aabb&quot; -&gt; &quot;a&quot;\n\n- &quot;aabb&quot; -&gt; &quot;aa&quot;\n\n- &quot;aabb&quot; -&gt; &quot;aab&quot;\n\n- &quot;aabb&quot; -&gt; &quot;aabb&quot;\n\n- &quot;aabb&quot; -&gt; &quot;a&quot;\n\n- &quot;aabb&quot; -&gt; &quot;abb&quot;\n\n- &quot;aabb&quot; -&gt; &quot;b&quot;\n\n- &quot;aabb&quot; -&gt; &quot;bb&quot;\n\n- &quot;aabb&quot; -&gt; &quot;b&quot;\n\n", "Example 3:\n\nInput: word = &quot;he&quot;\n\nOutput: 2\n\nExplanation: The two wonderful substrings are underlined below:\n\n- &quot;he&quot; -&gt; &quot;h&quot;\n\n- &quot;he&quot; -&gt; &quot;e&quot;\n\n"], "constraints": "\nConstraints:\n1 <= word.length <= 105\nword consists of lowercase English letters from &#39;a&#39;&nbsp;to &#39;j&#39;.\n", "java_context": "\nclass Solution {\n    public long wonderfulSubstrings(String word) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} word\n* @return {number}\n*/\nvar wonderfulSubstrings = function (word) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    long long wonderfulSubstrings(string word) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic long wonderfulSubstrings(String word) {\nint[] cnt = new int[1 << 10];\ncnt[0] = 1;\nlong ans = 0;\nint st = 0;\nfor (char c : word.toCharArray()) {\nst ^= 1 << (c - 'a');\nans += cnt[st];\nfor (int i = 0; i < 10; ++i) {\nans += cnt[st ^ (1 << i)];\n}\n++cnt[st];\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} word\n* @return {number}\n*/\nvar wonderfulSubstrings = function (word) {\nconst cnt = new Array(1024).fill(0);\ncnt[0] = 1;\nlet ans = 0;\nlet st = 0;\nfor (const c of word) {\nst ^= 1 << (c.charCodeAt() - 'a'.charCodeAt());\nans += cnt[st];\nfor (let i = 0; i < 10; ++i) {\nans += cnt[st ^ (1 << i)];\n}\ncnt[st]++;\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nlong long wonderfulSubstrings(string word) {\nint cnt[1024] = {1};\nlong long ans = 0;\nint st = 0;\nfor (char c : word) {\nst ^= 1 << (c - 'a');\nans += cnt[st];\nfor (int i = 0; i < 10; ++i) {\nans += cnt[st ^ (1 << i)];\n}\n++cnt[st];\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1921", "level": "middle", "question_description": "You are playing a video game where you are defending your city from a group of n monsters. You are given a 0-indexed integer array dist of size n, where dist[i] is the initial distance in kilometers of the ith monster from the city.\nThe monsters walk toward the city at a constant speed. The speed of each monster is given to you in an integer array speed of size n, where speed[i] is the speed of the ith monster in kilometers per minute.\nYou have a weapon that, once fully charged, can eliminate a single monster. However, the weapon takes one minute to charge. The weapon is fully charged at the very start.\nYou lose when any monster reaches your city. If a monster reaches the city at the exact moment the weapon is fully charged, it counts as a loss, and the game ends before you can use your weapon.\nReturn the maximum number of monsters that you can eliminate before you lose, or n if you can eliminate all the monsters before they reach the city.", "examples": ["Example 1:\nInput: dist = [1,3,4], speed = [1,1,1]\nOutput: 3\nExplanation:\nIn the beginning, the distances of the monsters are [1,3,4]. You eliminate the first monster.\nAfter a minute, the distances of the monsters are [X,2,3]. You eliminate the second monster.\nAfter a minute, the distances of the monsters are [X,X,2]. You eliminate the third monster.\nAll 3 monsters can be eliminated.", "Example 2:\nInput: dist = [1,1,2,3], speed = [1,1,1,1]\nOutput: 1\nExplanation:\nIn the beginning, the distances of the monsters are [1,1,2,3]. You eliminate the first monster.\nAfter a minute, the distances of the monsters are [X,0,1,2], so you lose.\nYou can only eliminate 1 monster.\n", "Example 3:\nInput: dist = [3,2,4], speed = [5,3,2]\nOutput: 1\nExplanation:\nIn the beginning, the distances of the monsters are [3,2,4]. You eliminate the first monster.\nAfter a minute, the distances of the monsters are [X,0,2], so you lose.\nYou can only eliminate 1 monster.\n"], "constraints": "\nConstraints:\nn == dist.length == speed.length\n1 <= n <= 105\n1 <= dist[i], speed[i] <= 105\n", "java_context": "\nclass Solution {\n    public int eliminateMaximum(int[] dist, int[] speed) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} dist\n* @param {number[]} speed\n* @return {number}\n*/\nvar eliminateMaximum = function (dist, speed) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int eliminateMaximum(vector<int>& dist, vector<int>& speed) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int eliminateMaximum(int[] dist, int[] speed) {\nint n = dist.length;\nint[] times = new int[n];\nfor (int i = 0; i < n; ++i) {\ntimes[i] = (dist[i] - 1) / speed[i];\n}\nArrays.sort(times);\nfor (int i = 0; i < n; ++i) {\nif (times[i] < i) {\nreturn i;\n}\n}\nreturn n;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} dist\n* @param {number[]} speed\n* @return {number}\n*/\nvar eliminateMaximum = function (dist, speed) {\nlet arr = [];\nfor (let i = 0; i < dist.length; i++) {\narr[i] = dist[i] / speed[i];\n}\narr.sort((a, b) => a - b);\nlet ans = 0;\nwhile (arr[0] > ans) {\narr.shift();\n++ans;\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint eliminateMaximum(vector<int>& dist, vector<int>& speed) {\nint n = dist.size();\nvector<int> times;\nfor (int i = 0; i < n; ++i) {\ntimes.push_back((dist[i] - 1) / speed[i]);\n}\nsort(times.begin(), times.end());\nfor (int i = 0; i < n; ++i) {\nif (times[i] < i) {\nreturn i;\n}\n}\nreturn n;\n}\n};\n"]}, {"leetCodeID": "1940", "level": "middle", "question_description": "Given an array of integer arrays arrays where each arrays[i] is sorted in strictly increasing order, return an integer array representing the longest common subsequence between all the arrays.\nA subsequence is a sequence that can be derived from another sequence by deleting some elements (possibly none) without changing the order of the remaining elements.", "examples": ["Example 1:\nInput: arrays = [[1,3,4],\n[1,4,7,9]]\nOutput: [1,4]\nExplanation: The longest common subsequence in the two arrays is [1,4].\n", "Example 2:\nInput: arrays = [[2,3,6,8],\n[1,2,3,5,6,7,10],\n[2,3,4,6,9]]\nOutput: [2,3,6]\nExplanation: The longest common subsequence in all three arrays is [2,3,6].\n", "Example 3:\nInput: arrays = [[1,2,3,4,5],\n[6,7,8]]\nOutput: []\nExplanation: There is no common subsequence between the two arrays.\n"], "constraints": "\nConstraints:\n2 <= arrays.length <= 100\n1 <= arrays[i].length <= 100\n1 <= arrays[i][j] <= 100\narrays[i] is sorted in strictly increasing order.\n", "java_context": "\nclass Solution {\n    public List<Integer> longestCommomSubsequence(int[][] arrays) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[][]} arrays\n* @return {number[]}\n*/\nvar longestCommonSubsequence = function (arrays) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> longestCommomSubsequence(vector<vector<int>>& arrays) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic List<Integer> longestCommomSubsequence(int[][] arrays) {\nMap<Integer, Integer> counter = new HashMap<>();\nfor (int[] array : arrays) {\nfor (int e : array) {\ncounter.put(e, counter.getOrDefault(e, 0) + 1);\n}\n}\nint n = arrays.length;\nList<Integer> res = new ArrayList<>();\nfor (Map.Entry<Integer, Integer> entry : counter.entrySet()) {\nif (entry.getValue() == n) {\nres.add(entry.getKey());\n}\n}\nreturn res;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[][]} arrays\n* @return {number[]}\n*/\nvar longestCommonSubsequence = function (arrays) {\nconst m = new Map();\nconst rs = [];\nconst len = arrays.length;\nfor (let i = 0; i < len; i++) {\nfor (let j = 0; j < arrays[i].length; j++) {\nm.set(arrays[i][j], (m.get(arrays[i][j]) || 0) + 1);\nif (m.get(arrays[i][j]) === len) rs.push(arrays[i][j]);\n}\n}\nreturn rs;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> longestCommomSubsequence(vector<vector<int>>& arrays) {\nunordered_map<int, int> counter;\nvector<int> res;\nint n = arrays.size();\nfor (auto array : arrays) {\nfor (auto e : array) {\ncounter[e] += 1;\nif (counter[e] == n) {\nres.push_back(e);\n}\n}\n}\nreturn res;\n}\n};\n"]}, {"leetCodeID": "1975", "level": "middle", "question_description": "You are given an n x n integer matrix. You can do the following operation any number of times:\nChoose any two adjacent elements of matrix and multiply each of them by -1.\nTwo elements are considered adjacent if and only if they share a border.\nYour goal is to maximize the summation of the matrix&#39;s elements. Return the maximum sum of the matrix&#39;s elements using the operation mentioned above.", "examples": [], "constraints": "\nConstraints:\nn == matrix.length == matrix[i].length\n2 <= n <= 250\n-105 <= matrix[i][j] <= 105\n", "java_context": "\nclass Solution {\n    public long maxMatrixSum(int[][] matrix) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[][]} matrix\n* @return {number}\n*/\nvar maxMatrixSum = function (matrix) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    long long maxMatrixSum(vector<vector<int>>& matrix) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic long maxMatrixSum(int[][] matrix) {\nlong s = 0;\nint cnt = 0;\nint mi = Integer.MAX_VALUE;\nfor (var row : matrix) {\nfor (var v : row) {\ns += Math.abs(v);\nmi = Math.min(mi, Math.abs(v));\nif (v < 0) {\n++cnt;\n}\n}\n}\nif (cnt % 2 == 0 || mi == 0) {\nreturn s;\n}\nreturn s - mi * 2;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[][]} matrix\n* @return {number}\n*/\nvar maxMatrixSum = function (matrix) {\nlet cnt = 0;\nlet s = 0;\nlet mi = Infinity;\nfor (const row of matrix) {\nfor (const v of row) {\ns += Math.abs(v);\nmi = Math.min(mi, Math.abs(v));\ncnt += v < 0;\n}\n}\nif (cnt % 2 == 0) {\nreturn s;\n}\nreturn s - mi * 2;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nlong long maxMatrixSum(vector<vector<int>>& matrix) {\nlong long s = 0;\nint cnt = 0, mi = INT_MAX;\nfor (auto& row : matrix) {\nfor (int& v : row) {\ns += abs(v);\nmi = min(mi, abs(v));\ncnt += v < 0;\n}\n}\nif (cnt % 2 == 0 || mi == 0) return s;\nreturn s - mi * 2;\n}\n};\n"]}, {"leetCodeID": "1996", "level": "middle", "question_description": "You are playing a game that contains multiple characters, and each of the characters has two main properties: attack and defense. You are given a 2D integer array properties where properties[i] = [attacki, defensei] represents the properties of the ith character in the game.\nA character is said to be weak if any other character has both attack and defense levels strictly greater than this character&#39;s attack and defense levels. More formally, a character i is said to be weak if there exists another character j where attackj &gt; attacki and defensej &gt; defensei.\nReturn the number of weak characters.", "examples": ["Example 1:\nInput: properties = [[5,5],[6,3],[3,6]]\nOutput: 0\nExplanation: No character has strictly greater attack and defense than the other.\n", "Example 2:\nInput: properties = [[2,2],[3,3]]\nOutput: 1\nExplanation: The first character is weak because the second character has a strictly greater attack and defense.\n", "Example 3:\nInput: properties = [[1,5],[10,4],[4,3]]\nOutput: 1\nExplanation: The third character is weak because the second character has a strictly greater attack and defense.\n"], "constraints": "\nConstraints:\n2 <= properties.length <= 105\nproperties[i].length == 2\n1 <= attacki, defensei <= 105\n", "java_context": "\nclass Solution {\n    public int numberOfWeakCharacters(int[][] properties) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[][]} properties\n* @return {number}\n*/\nvar numberOfWeakCharacters = function (properties) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int numberOfWeakCharacters(vector<vector<int>>& properties) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int numberOfWeakCharacters(int[][] properties) {\nArrays.sort(properties, (a, b) -> b[0] - a[0] == 0 ? a[1] - b[1] : b[0] - a[0]);\nint ans = 0, mx = 0;\nfor (var x : properties) {\nif (x[1] < mx) {\n++ans;\n}\nmx = Math.max(mx, x[1]);\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[][]} properties\n* @return {number}\n*/\nvar numberOfWeakCharacters = function (properties) {\nproperties.sort((a, b) => (a[0] == b[0] ? a[1] - b[1] : b[0] - a[0]));\nlet ans = 0;\nlet mx = 0;\nfor (const [, x] of properties) {\nif (x < mx) {\nans++;\n} else {\nmx = x;\n}\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint numberOfWeakCharacters(vector<vector<int>>& properties) {\nsort(properties.begin(), properties.end(), [&](auto& a, auto& b) { return a[0] == b[0] ? a[1] < b[1] : a[0] > b[0]; });\nint ans = 0, mx = 0;\nfor (auto& x : properties) {\nans += x[1] < mx;\nmx = max(mx, x[1]);\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "2001", "level": "middle", "question_description": "You are given n rectangles represented by a 0-indexed 2D integer array rectangles, where rectangles[i] = [widthi, heighti] denotes the width and height of the ith rectangle.\nTwo rectangles i and j (i &lt; j) are considered interchangeable if they have the same width-to-height ratio. More formally, two rectangles are interchangeable if widthi/heighti == widthj/heightj (using decimal division, not integer division).\nReturn the number of pairs of interchangeable rectangles in rectangles.", "examples": ["Example 1:\nInput: rectangles = [[4,8],[3,6],[10,20],[15,30]]\nOutput: 6\nExplanation: The following are the interchangeable pairs of rectangles by index (0-indexed):\n- Rectangle 0 with rectangle 1: 4/8 == 3/6.\n- Rectangle 0 with rectangle 2: 4/8 == 10/20.\n- Rectangle 0 with rectangle 3: 4/8 == 15/30.\n- Rectangle 1 with rectangle 2: 3/6 == 10/20.\n- Rectangle 1 with rectangle 3: 3/6 == 15/30.\n- Rectangle 2 with rectangle 3: 10/20 == 15/30.\n", "Example 2:\nInput: rectangles = [[4,5],[7,8]]\nOutput: 0\nExplanation: There are no interchangeable pairs of rectangles.\n"], "constraints": "\nConstraints:\nn == rectangles.length\n1 <= n <= 105\nrectangles[i].length == 2\n1 <= widthi, heighti <= 105\n", "java_context": "\nclass Solution {\n    public long interchangeableRectangles(int[][] rectangles) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[][]} rectangles\n* @return {number}\n*/\nvar interchangeableRectangles = function (rectangles) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    long long interchangeableRectangles(vector<vector<int>>& rectangles) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic long interchangeableRectangles(int[][] rectangles) {\nlong ans = 0;\nint n = rectangles.length + 1;\nMap<Long, Integer> cnt = new HashMap<>();\nfor (var e : rectangles) {\nint w = e[0], h = e[1];\nint g = gcd(w, h);\nw /= g;\nh /= g;\nlong x = (long) w * n + h;\nans += cnt.getOrDefault(x, 0);\ncnt.merge(x, 1, Integer::sum);\n}\nreturn ans;\n}\n\nprivate int gcd(int a, int b) {\nreturn b == 0 ? a : gcd(b, a % b);\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[][]} rectangles\n* @return {number}\n*/\nvar interchangeableRectangles = function (rectangles) {\nconst cnt = new Map();\nlet ans = 0;\nfor (let [w, h] of rectangles) {\nconst g = gcd(w, h);\nw = Math.floor(w / g);\nh = Math.floor(h / g);\nconst x = w * (rectangles.length + 1) + h;\nans += cnt.get(x) | 0;\ncnt.set(x, (cnt.get(x) | 0) + 1);\n}\nreturn ans;\n};\n\nfunction gcd(a, b) {\nif (b == 0) {\nreturn a;\n}\nreturn gcd(b, a % b);\n}\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nlong long interchangeableRectangles(vector<vector<int>>& rectangles) {\nlong long ans = 0;\nint n = rectangles.size();\nunordered_map<long long, int> cnt;\nfor (auto& e : rectangles) {\nint w = e[0], h = e[1];\nint g = gcd(w, h);\nw /= g;\nh /= g;\nlong long x = 1ll * w * (n + 1) + h;\nans += cnt[x];\ncnt[x]++;\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "2021", "level": "middle", "question_description": "A perfectly straight street is represented by a number line. The street has street lamp(s) on it and is represented by a 2D integer array lights. Each lights[i] = [positioni, rangei] indicates that there is a street lamp at position positioni that lights up the area from [positioni - rangei, positioni + rangei] (inclusive).\nThe brightness of a position p is defined as the number of street lamp that light up the position p.\nGiven lights, return the brightest position on the street. If there are multiple brightest positions, return the smallest one.", "examples": ["Example 1:\n\n\nInput: lights = [[-3,2],[1,2],[3,3]]\nOutput: -1\nExplanation:\nThe first street lamp lights up the area from [(-3) - 2, (-3) + 2] = [-5, -1].\nThe second street lamp lights up the area from [1 - 2, 1 + 2] = [-1, 3].\nThe third street lamp lights up the area from [3 - 3, 3 + 3] = [0, 6].\n\nPosition -1 has a brightness of 2, illuminated by the first and second street light.\nPositions 0, 1, 2, and 3 have a brightness of 2, illuminated by the second and third street light.\nOut of all these positions, -1 is the smallest, so return it.\n\n\n\nExample 2:\nInput: lights = [[1,0],[0,1]]\nOutput: 1\nExplanation:\nThe first street lamp lights up the area from [1 - 0, 1 + 0] = [1, 1].\nThe second street lamp lights up the area from [0 - 1, 0 + 1] = [-1, 1].\n\nPosition 1 has a brightness of 2, illuminated by the first and second street light.\nReturn 1 because it is the brightest position on the street.\n", "Example 3:\nInput: lights = [[1,2]]\nOutput: -1\nExplanation:\nThe first street lamp lights up the area from [1 - 2, 1 + 2] = [-1, 3].\n\nPositions -1, 0, 1, 2, and 3 have a brightness of 1, illuminated by the first street light.\nOut of all these positions, -1 is the smallest, so return it.\n"], "constraints": "\nConstraints:\n1 <= lights.length <= 105\nlights[i].length == 2\n-108 <= positioni <= 108\n0 <= rangei <= 108\n", "java_context": "\nclass Solution {\n    public int brightestPosition(int[][] lights) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[][]} lights\n* @return {number}\n*/\nvar brightestPosition = function (lights) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int brightestPosition(vector<vector<int>>& lights) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int brightestPosition(int[][] lights) {\nTreeMap<Integer, Integer> d = new TreeMap<>();\nfor (var x : lights) {\nint l = x[0] - x[1], r = x[0] + x[1];\nd.merge(l, 1, Integer::sum);\nd.merge(r + 1, -1, Integer::sum);\n}\nint ans = 0, s = 0, mx = 0;\nfor (var x : d.entrySet()) {\nint v = x.getValue();\ns += v;\nif (mx < s) {\nmx = s;\nans = x.getKey();\n}\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[][]} lights\n* @return {number}\n*/\nvar brightestPosition = function (lights) {\nconst d = new Map();\nfor (const [i, j] of lights) {\nconst l = i - j;\nconst r = i + j;\nd.set(l, (d.get(l) ?? 0) + 1);\nd.set(r + 1, (d.get(r + 1) ?? 0) - 1);\n}\nconst keys = [];\nfor (const k of d.keys()) {\nkeys.push(k);\n}\nkeys.sort((a, b) => a - b);\nlet ans = 0;\nlet s = 0;\nlet mx = 0;\nfor (const i of keys) {\ns += d.get(i);\nif (mx < s) {\nmx = s;\nans = i;\n}\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint brightestPosition(vector<vector<int>>& lights) {\nmap<int, int> d;\nfor (auto& x : lights) {\nint l = x[0] - x[1], r = x[0] + x[1];\n++d[l];\n--d[r + 1];\n}\nint ans = 0, s = 0, mx = 0;\nfor (auto& [i, v] : d) {\ns += v;\nif (mx < s) {\nmx = s;\nans = i;\n}\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "2067", "level": "middle", "question_description": "You are given a 0-indexed string s consisting of only lowercase English letters, and an integer count. A substring of s is said to be an equal count substring if, for each unique letter in the substring, it appears exactly count times in the substring.\nReturn the number of equal count substrings in s.\nA substring is a contiguous non-empty sequence of characters within a string.", "examples": ["Example 1:\nInput: s = &quot;aaabcbbcc&quot;, count = 3\nOutput: 3\nExplanation:\nThe substring that starts at index 0 and ends at index 2 is &quot;aaa&quot;.\nThe letter &#39;a&#39; in the substring appears exactly 3 times.\nThe substring that starts at index 3 and ends at index 8 is &quot;bcbbcc&quot;.\nThe letters &#39;b&#39; and &#39;c&#39; in the substring appear exactly 3 times.\nThe substring that starts at index 0 and ends at index 8 is &quot;aaabcbbcc&quot;.\nThe letters &#39;a&#39;, &#39;b&#39;, and &#39;c&#39; in the substring appear exactly 3 times.\n", "Example 2:\nInput: s = &quot;abcd&quot;, count = 2\nOutput: 0\nExplanation:\nThe number of times each letter appears in s is less than count.\nTherefore, no substrings in s are equal count substrings, so return 0.\n", "Example 3:\nInput: s = &quot;a&quot;, count = 5\nOutput: 0\nExplanation:\nThe number of times each letter appears in s is less than count.\nTherefore, no substrings in s are equal count substrings, so return 0"], "constraints": "\nConstraints:\n1 <= s.length <= 3 * 104\n1 <= count <= 3 * 104\ns consists only of lowercase English letters.\n", "java_context": "\nclass Solution {\n    public int equalCountSubstrings(String s, int count) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} s\n* @param {number} count\n* @return {number}\n*/\nvar equalCountSubstrings = function (s, count) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int equalCountSubstrings(string s, int count) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int equalCountSubstrings(String s, int count) {\nint ans = 0;\nint[] cnt = new int[26];\nint n = s.length();\nfor (int i = 1; i < 27 && i * count <= n; ++i) {\nint k = i * count;\nArrays.fill(cnt, 0);\nint t = 0;\nfor (int j = 0; j < n; ++j) {\nint a = s.charAt(j) - 'a';\n++cnt[a];\nt += cnt[a] == count ? 1 : 0;\nt -= cnt[a] == count + 1 ? 1 : 0;\nif (j - k >= 0) {\nint b = s.charAt(j - k) - 'a';\n--cnt[b];\nt += cnt[b] == count ? 1 : 0;\nt -= cnt[b] == count - 1 ? 1 : 0;\n}\nans += i == t ? 1 : 0;\n}\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} s\n* @param {number} count\n* @return {number}\n*/\nvar equalCountSubstrings = function (s, count) {\nconst n = s.length;\nlet ans = 0;\nfor (let i = 1; i < 27 && i * count <= n; ++i) {\nconst k = i * count;\nconst cnt = Array(26).fill(0);\nlet t = 0;\nfor (let j = 0; j < n; ++j) {\nconst a = s.charCodeAt(j) - 97;\nt += ++cnt[a] === count ? 1 : 0;\nt -= cnt[a] === count + 1 ? 1 : 0;\nif (j >= k) {\nconst b = s.charCodeAt(j - k) - 97;\nt += --cnt[b] === count ? 1 : 0;\nt -= cnt[b] === count - 1 ? 1 : 0;\n}\nans += i === t ? 1 : 0;\n}\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint equalCountSubstrings(string s, int count) {\nint ans = 0;\nint n = s.size();\nint cnt[26];\nfor (int i = 1; i < 27 && i * count <= n; ++i) {\nint k = i * count;\nmemset(cnt, 0, sizeof(cnt));\nint t = 0;\nfor (int j = 0; j < n; ++j) {\nint a = s[j] - 'a';\nt += ++cnt[a] == count;\nt -= cnt[a] == count + 1;\nif (j >= k) {\nint b = s[j - k] - 'a';\nt += --cnt[b] == count;\nt -= cnt[b] == count - 1;\n}\nans += i == t;\n}\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "2186", "level": "middle", "question_description": "You are given two strings s and t. In one step, you can append any character to either s or t.\nReturn the minimum number of steps to make s and t anagrams of each other.\nAn anagram of a string is a string that contains the same characters with a different (or the same) ordering.", "examples": ["Example 1:\nInput: s = &quot;leetcode&quot;, t = &quot;coats&quot;\nOutput: 7\nExplanation:\n- In 2 steps, we can append the letters in &quot;as&quot; onto s = &quot;leetcode&quot;, forming s = &quot;leetcodeas&quot;.\n- In 5 steps, we can append the letters in &quot;leede&quot; onto t = &quot;coats&quot;, forming t = &quot;coatsleede&quot;.\n&quot;leetcodeas&quot; and &quot;coatsleede&quot; are now anagrams of each other.\nWe used a total of 2 + 5 = 7 steps.\nIt can be shown that there is no way to make them anagrams of each other with less than 7 steps.\n", "Example 2:\nInput: s = &quot;night&quot;, t = &quot;thing&quot;\nOutput: 0\nExplanation: The given strings are already anagrams of each other. Thus, we do not need any further steps.\n"], "constraints": "\nConstraints:\n1 <= s.length, t.length <= 2 * 105\ns and t consist of lowercase English letters.\n", "java_context": "\nclass Solution {\n    public int minSteps(String s, String t) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} s\n* @param {string} t\n* @return {number}\n*/\nvar minSteps = function (s, t) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int minSteps(string s, string t) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int minSteps(String s, String t) {\nint[] cnt = new int[26];\nfor (char c : s.toCharArray()) {\n++cnt[c - 'a'];\n}\nfor (char c : t.toCharArray()) {\n--cnt[c - 'a'];\n}\nint ans = 0;\nfor (int v : cnt) {\nans += Math.abs(v);\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} s\n* @param {string} t\n* @return {number}\n*/\nvar minSteps = function (s, t) {\nlet cnt = new Array(26).fill(0);\nfor (const c of s) {\n++cnt[c.charCodeAt() - 'a'.charCodeAt()];\n}\nfor (const c of t) {\n--cnt[c.charCodeAt() - 'a'.charCodeAt()];\n}\nlet ans = 0;\nfor (const v of cnt) {\nans += Math.abs(v);\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint minSteps(string s, string t) {\nvector<int> cnt(26);\nfor (char& c : s) ++cnt[c - 'a'];\nfor (char& c : t) --cnt[c - 'a'];\nint ans = 0;\nfor (int& v : cnt) ans += abs(v);\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "2219", "level": "middle", "question_description": "You are given a 0-indexed integer array nums of length n.\nThe sum score of nums at an index i where 0 &lt;= i &lt; n is the maximum of:\nThe sum of the first i + 1 elements of nums.\nThe sum of the last n - i elements of nums.\nReturn the maximum sum score of nums at any index.", "examples": ["Example 1:\nInput: nums = [4,3,-2,5]\nOutput: 10\nExplanation:\nThe sum score at index 0 is max(4, 4 + 3 + -2 + 5) = max(4, 10) = 10.\nThe sum score at index 1 is max(4 + 3, 3 + -2 + 5) = max(7, 6) = 7.\nThe sum score at index 2 is max(4 + 3 + -2, -2 + 5) = max(5, 3) = 5.\nThe sum score at index 3 is max(4 + 3 + -2 + 5, 5) = max(10, 5) = 10.\nThe maximum sum score of nums is 10.\n", "Example 2:\nInput: nums = [-3,-5]\nOutput: -3\nExplanation:\nThe sum score at index 0 is max(-3, -3 + -5) = max(-3, -8) = -3.\nThe sum score at index 1 is max(-3 + -5, -5) = max(-8, -5) = -5.\nThe maximum sum score of nums is -3.\n"], "constraints": "\nConstraints:\nn == nums.length\n1 <= n <= 105\n-105 <= nums[i] <= 105\n", "java_context": "\nclass Solution {\n    public long maximumSumScore(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar maximumSumScore = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    long long maximumSumScore(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic long maximumSumScore(int[] nums) {\nint n = nums.length;\nlong[] s = new long[n + 1];\nfor (int i = 0; i < n; ++i) {\ns[i + 1] = s[i] + nums[i];\n}\nlong ans = Long.MIN_VALUE;\nfor (int i = 0; i < n; ++i) {\nans = Math.max(ans, Math.max(s[i + 1], s[n] - s[i]));\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar maximumSumScore = function (nums) {\nconst n = nums.length;\nlet s = new Array(n + 1).fill(0);\nfor (let i = 0; i < n; ++i) {\ns[i + 1] = s[i] + nums[i];\n}\nlet ans = -Infinity;\nfor (let i = 0; i < n; ++i) {\nans = Math.max(ans, Math.max(s[i + 1], s[n] - s[i]));\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nlong long maximumSumScore(vector<int>& nums) {\nint n = nums.size();\nvector<long long> s(n + 1);\nfor (int i = 0; i < n; ++i) s[i + 1] = s[i] + nums[i];\nlong long ans = INT_MIN;\nfor (int i = 0; i < n; ++i) ans = max(ans, max(s[i + 1], s[n] - s[i]));\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "2225", "level": "middle", "question_description": "You are given an integer array matches where matches[i] = [winneri, loseri] indicates that the player winneri defeated player loseri in a match.\nReturn a list answer of size 2 where:\nanswer[0] is a list of all players that have not lost any matches.\nanswer[1] is a list of all players that have lost exactly one match.\nThe values in the two lists should be returned in increasing order.\nNote:\nYou should only consider the players that have played at least one match.\nThe testcases will be generated such that no two matches will have the same outcome.", "examples": ["Example 1:\nInput: matches = [[1,3],[2,3],[3,6],[5,6],[5,7],[4,5],[4,8],[4,9],[10,4],[10,9]]\nOutput: [[1,2,10],[4,5,7,8]]\nExplanation:\nPlayers 1, 2, and 10 have not lost any matches.\nPlayers 4, 5, 7, and 8 each have lost one match.\nPlayers 3, 6, and 9 each have lost two matches.\nThus, answer[0] = [1,2,10] and answer[1] = [4,5,7,8].\n", "Example 2:\nInput: matches = [[2,3],[1,3],[5,4],[6,4]]\nOutput: [[1,2,5,6],[]]\nExplanation:\nPlayers 1, 2, 5, and 6 have not lost any matches.\nPlayers 3 and 4 each have lost two matches.\nThus, answer[0] = [1,2,5,6] and answer[1] = [].\n"], "constraints": "\nConstraints:\n1 <= matches.length <= 105\nmatches[i].length == 2\n1 <= winneri, loseri <= 105\nwinneri != loseri\nAll matches[i] are unique.\n", "java_context": "\nclass Solution {\n    public List<List<Integer>> findWinners(int[][] matches) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[][]} matches\n* @return {number[][]}\n*/\nvar findWinners = function (matches) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<vector<int>> findWinners(vector<vector<int>>& matches) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic List<List<Integer>> findWinners(int[][] matches) {\nMap<Integer, Integer> cnt = new HashMap<>();\nfor (int[] m : matches) {\nint a = m[0], b = m[1];\ncnt.putIfAbsent(a, 0);\ncnt.put(b, cnt.getOrDefault(b, 0) + 1);\n}\nList<List<Integer>> ans = new ArrayList<>();\nans.add(new ArrayList<>());\nans.add(new ArrayList<>());\nfor (Map.Entry<Integer, Integer> entry : cnt.entrySet()) {\nint u = entry.getKey();\nint v = entry.getValue();\nif (v < 2) {\nans.get(v).add(u);\n}\n}\nCollections.sort(ans.get(0));\nCollections.sort(ans.get(1));\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[][]} matches\n* @return {number[][]}\n*/\nvar findWinners = function (matches) {\nconst cnt = new Map();\nfor (const [a, b] of matches) {\ncnt.set(a, cnt.has(a) ? cnt.get(a) : 0);\ncnt.set(b, (cnt.get(b) || 0) + 1);\n}\nconst ans = [[], []];\nfor (let [u, v] of cnt.entries()) {\nif (v < 2) {\nans[v].push(u);\n}\n}\nans[0].sort((a, b) => a - b);\nans[1].sort((a, b) => a - b);\nreturn ans;\n};\n", "\n/**\n* @param {number[][]} matches\n* @return {number[][]}\n*/\nvar findWinners = function (matches) {\nconst onlyWins = new Set(),\noneLose = new Set(),\nmoreLosses = new Set();\n\nfor (const [winner, loser] of matches) {\nif (!moreLosses.has(loser)) {\nif (oneLose.has(loser)) {\noneLose.delete(loser);\nmoreLosses.add(loser);\n} else {\nonlyWins.delete(loser);\noneLose.add(loser);\n}\n}\n\nif (!moreLosses.has(winner) && !oneLose.has(winner)) {\nonlyWins.add(winner);\n}\n}\n\nreturn [[...onlyWins].sort((a, b) => a - b), [...oneLose].sort((a, b) => a - b)];\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<vector<int>> findWinners(vector<vector<int>>& matches) {\nunordered_map<int, int> cnt;\nfor (auto& m : matches) {\nint a = m[0], b = m[1];\nif (!cnt.count(a)) cnt[a] = 0;\n++cnt[b];\n}\nvector<vector<int>> ans(2);\nfor (auto& [u, v] : cnt) {\nif (v < 2) ans[v].push_back(u);\n}\nsort(ans[0].begin(), ans[0].end());\nsort(ans[1].begin(), ans[1].end());\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "2233", "level": "middle", "question_description": "You are given an array of non-negative integers nums and an integer k. In one operation, you may choose any element from nums and increment it by 1.\nReturn the maximum product of nums after at most k operations. Since the answer may be very large, return it modulo 109 + 7. Note that you should maximize the product before taking the modulo.", "examples": ["Example 1:\nInput: nums = [0,4], k = 5\nOutput: 20\nExplanation: Increment the first number 5 times.\nNow nums = [5, 4], with a product of 5 * 4 = 20.\nIt can be shown that 20 is maximum product possible, so we return 20.\nNote that there may be other ways to increment nums to have the maximum product.\n", "Example 2:\nInput: nums = [6,3,3,2], k = 2\nOutput: 216\nExplanation: Increment the second number 1 time and increment the fourth number 1 time.\nNow nums = [6, 4, 3, 3], with a product of 6 * 4 * 3 * 3 = 216.\nIt can be shown that 216 is maximum product possible, so we return 216.\nNote that there may be other ways to increment nums to have the maximum product.\n"], "constraints": "\nConstraints:\n1 <= nums.length, k <= 105\n0 <= nums[i] <= 106\n", "java_context": "\nclass Solution {\n    private static final int MOD = (int) 1e9 + 7;\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @param {number} k\n* @return {number}\n*/\nvar maximumProduct = function (nums, k) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int maximumProduct(vector<int>& nums, int k) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\nprivate static final int MOD = (int) 1e9 + 7;\n\npublic int maximumProduct(int[] nums, int k) {\nPriorityQueue<Integer> q = new PriorityQueue<>();\nfor (int v : nums) {\nq.offer(v);\n}\nwhile (k-- > 0) {\nq.offer(q.poll() + 1);\n}\nlong ans = 1;\nwhile (!q.isEmpty()) {\nans = (ans * q.poll()) % MOD;\n}\nreturn (int) ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @param {number} k\n* @return {number}\n*/\nvar maximumProduct = function (nums, k) {\nconst n = nums.length;\nlet pq = new MinPriorityQueue();\nfor (let i = 0; i < n; i++) {\npq.enqueue(nums[i]);\n}\nfor (let i = 0; i < k; i++) {\npq.enqueue(pq.dequeue().element + 1);\n}\nlet ans = 1;\nconst limit = 10 ** 9 + 7;\nfor (let i = 0; i < n; i++) {\nans = (ans * pq.dequeue().element) % limit;\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint maximumProduct(vector<int>& nums, int k) {\nint mod = 1e9 + 7;\nmake_heap(nums.begin(), nums.end(), greater<int>());\nwhile (k--) {\npop_heap(nums.begin(), nums.end(), greater<int>());\n++nums.back();\npush_heap(nums.begin(), nums.end(), greater<int>());\n}\nlong long ans = 1;\nfor (int v : nums) ans = (ans * v) % mod;\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "2311", "level": "middle", "question_description": "You are given a binary string s and a positive integer k.\nReturn the length of the longest subsequence of s that makes up a binary number less than or equal to k.\nNote:\nThe subsequence can contain leading zeroes.\nThe empty string is considered to be equal to 0.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.", "examples": ["Example 1:\nInput: s = &quot;1001010&quot;, k = 5\nOutput: 5\nExplanation: The longest subsequence of s that makes up a binary number less than or equal to 5 is &quot;00010&quot;, as this number is equal to 2 in decimal.\nNote that &quot;00100&quot; and &quot;00101&quot; are also possible, which are equal to 4 and 5 in decimal, respectively.\nThe length of this subsequence is 5, so 5 is returned.\n", "Example 2:\nInput: s = &quot;00101001&quot;, k = 1\nOutput: 6\nExplanation: &quot;000001&quot; is the longest subsequence of s that makes up a binary number less than or equal to 1, as this number is equal to 1 in decimal.\nThe length of this subsequence is 6, so 6 is returned.\n"], "constraints": "\nConstraints:\n1 <= s.length <= 1000\ns[i] is either &#39;0&#39; or &#39;1&#39;.\n1 <= k <= 109\n", "java_context": "\nclass Solution {\n    public int longestSubsequence(String s, int k) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} s\n* @param {number} k\n* @return {number}\n*/\nvar longestSubsequence = function (s, k) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int longestSubsequence(string s, int k) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int longestSubsequence(String s, int k) {\nint ans = 0, v = 0;\nfor (int i = s.length() - 1; i >= 0; --i) {\nif (s.charAt(i) == '0') {\n++ans;\n} else if (ans < 30 && (v | 1 << ans) <= k) {\nv |= 1 << ans;\n++ans;\n}\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} s\n* @param {number} k\n* @return {number}\n*/\nvar longestSubsequence = function (s, k) {\nlet ans = 0;\nfor (let i = s.length - 1, v = 0; ~i; --i) {\nif (s[i] == '0') {\n++ans;\n} else if (ans < 30 && (v | (1 << ans)) <= k) {\nv |= 1 << ans;\n++ans;\n}\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint longestSubsequence(string s, int k) {\nint ans = 0, v = 0;\nfor (int i = s.size() - 1; ~i; --i) {\nif (s[i] == '0') {\n++ans;\n} else if (ans < 30 && (v | 1 << ans) <= k) {\nv |= 1 << ans;\n++ans;\n}\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "2332", "level": "middle", "question_description": "You are given a 0-indexed integer array buses of length n, where buses[i] represents the departure time of the ith bus. You are also given a 0-indexed integer array passengers of length m, where passengers[j] represents the arrival time of the jth passenger. All bus departure times are unique. All passenger arrival times are unique.\nYou are given an integer capacity, which represents the maximum number of passengers that can get on each bus.\nWhen a passenger arrives, they will wait in line for the next available bus. You can get on a bus that departs at x minutes if you arrive at y minutes where y &lt;= x, and the bus is not full. Passengers with the earliest arrival times get on the bus first.\nMore formally when a bus arrives, either:\nIf capacity or fewer passengers are waiting for a bus, they will all get on the bus, or\nThe capacity passengers with the earliest arrival times will get on the bus.\nReturn the latest time you may arrive at the bus station to catch a bus. You cannot arrive at the same time as another passenger.\nNote: The arrays buses and passengers are not necessarily sorted.", "examples": ["Example 1:\nInput: buses = [10,20], passengers = [2,17,18,19], capacity = 2\nOutput: 16\nExplanation: Suppose you arrive at time 16.\nAt time 10, the first bus departs with the 0th passenger.\nAt time 20, the second bus departs with you and the 1st passenger.\nNote that you may not arrive at the same time as another passenger, which is why you must arrive before the 1st passenger to catch the bus.", "Example 2:\nInput: buses = [20,30,10], passengers = [19,13,26,4,25,11,21], capacity = 2\nOutput: 20\nExplanation: Suppose you arrive at time 20.\nAt time 10, the first bus departs with the 3rd passenger.\nAt time 20, the second bus departs with the 5th and 1st passengers.\nAt time 30, the third bus departs with the 0th passenger and you.\nNotice if you had arrived any later, then the 6th passenger would have taken your seat on the third bus."], "constraints": "\nConstraints:\nn == buses.length\nm == passengers.length\n1 <= n, m, capacity <= 105\n2 <= buses[i], passengers[i] <= 109\nEach element in buses is unique.\nEach element in passengers is unique.\n", "java_context": "\nclass Solution {\n    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} buses\n* @param {number[]} passengers\n* @param {number} capacity\n* @return {number}\n*/\nvar latestTimeCatchTheBus = function (buses, passengers, capacity) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {\nArrays.sort(buses);\nArrays.sort(passengers);\nint j = 0, c = 0;\nfor (int t : buses) {\nc = capacity;\nwhile (c > 0 && j < passengers.length && passengers[j] <= t) {\n--c;\n++j;\n}\n}\n--j;\nint ans = c > 0 ? buses[buses.length - 1] : passengers[j];\nwhile (j >= 0 && ans == passengers[j]) {\n--ans;\n--j;\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} buses\n* @param {number[]} passengers\n* @param {number} capacity\n* @return {number}\n*/\nvar latestTimeCatchTheBus = function (buses, passengers, capacity) {\nbuses.sort((a, b) => a - b);\npassengers.sort((a, b) => a - b);\nlet [j, c] = [0, 0];\nfor (const t of buses) {\nc = capacity;\nwhile (c && j < passengers.length && passengers[j] <= t) {\n--c;\n++j;\n}\n}\n--j;\nlet ans = c > 0 ? buses.at(-1) : passengers[j];\nwhile (j >= 0 && passengers[j] === ans) {\n--ans;\n--j;\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint latestTimeCatchTheBus(vector<int>& buses, vector<int>& passengers, int capacity) {\nsort(buses.begin(), buses.end());\nsort(passengers.begin(), passengers.end());\nint j = 0, c = 0;\nfor (int t : buses) {\nc = capacity;\nwhile (c && j < passengers.size() && passengers[j] <= t) --c, ++j;\n}\n--j;\nint ans = c ? buses[buses.size() - 1] : passengers[j];\nwhile (~j && ans == passengers[j]) --j, --ans;\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "2491", "level": "middle", "question_description": "You are given a positive integer array skill of even length n where skill[i] denotes the skill of the ith player. Divide the players into n / 2 teams of size 2 such that the total skill of each team is equal.\nThe chemistry of a team is equal to the product of the skills of the players on that team.\nReturn the sum of the chemistry of all the teams, or return -1 if there is no way to divide the players into teams such that the total skill of each team is equal.", "examples": ["Example 1:\nInput: skill = [3,2,5,1,3,4]\nOutput: 22\nExplanation:\nDivide the players into the following teams: (1, 5), (2, 4), (3, 3), where each team has a total skill of 6.\nThe sum of the chemistry of all the teams is: 1 * 5 + 2 * 4 + 3 * 3 = 5 + 8 + 9 = 22.\n", "Example 2:\nInput: skill = [3,4]\nOutput: 12\nExplanation:\nThe two players form a team with a total skill of 7.\nThe chemistry of the team is 3 * 4 = 12.\n", "Example 3:\nInput: skill = [1,1,2,3]\nOutput: -1\nExplanation:\nThere is no way to divide the players into teams such that the total skill of each team is equal.\n"], "constraints": "\nConstraints:\n2 <= skill.length <= 105\nskill.length is even.\n1 <= skill[i] <= 1000\n", "java_context": "\nclass Solution {\n    public long dividePlayers(int[] skill) {\n        // your code\n    }\n}", "js_context": "\nvar dividePlayers = function (skill) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    long long dividePlayers(vector<int>& skill) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic long dividePlayers(int[] skill) {\nArrays.sort(skill);\nint n = skill.length;\nint t = skill[0] + skill[n - 1];\nlong ans = 0;\nfor (int i = 0, j = n - 1; i < j; ++i, --j) {\nif (skill[i] + skill[j] != t) {\nreturn -1;\n}\nans += (long) skill[i] * skill[j];\n}\nreturn ans;\n}\n}\n", "\nclass Solution {\npublic long dividePlayers(int[] skill) {\nint s = Arrays.stream(skill).sum();\nint m = skill.length >> 1;\nif (s % m != 0) {\nreturn -1;\n}\nint t = s / m;\nint[] d = new int[1010];\nlong ans = 0;\nfor (int v : skill) {\nif (d[t - v] > 0) {\nans += (long) v * (t - v);\n--d[t - v];\n--m;\n} else {\n++d[v];\n}\n}\nreturn m == 0 ? ans : -1;\n}\n}\n"], "js_solutions": ["\nvar dividePlayers = function (skill) {\nconst n = skill.length,\nm = n / 2;\nskill.sort((a, b) => a - b);\nconst sum = skill[0] + skill[n - 1];\nlet ans = 0;\nfor (let i = 0; i < m; i++) {\nconst x = skill[i],\ny = skill[n - 1 - i];\nif (x + y != sum) return -1;\nans += x * y;\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nlong long dividePlayers(vector<int>& skill) {\nsort(skill.begin(), skill.end());\nint n = skill.size();\nint t = skill[0] + skill[n - 1];\nlong long ans = 0;\nfor (int i = 0, j = n - 1; i < j; ++i, --j) {\nif (skill[i] + skill[j] != t) return -1;\nans += 1ll * skill[i] * skill[j];\n}\nreturn ans;\n}\n};\n", "\nclass Solution {\npublic:\nlong long dividePlayers(vector<int>& skill) {\nint s = accumulate(skill.begin(), skill.end(), 0);\nint m = skill.size() / 2;\nif (s % m) return -1;\nint t = s / m;\nint d[1010] = {0};\nlong long ans = 0;\nfor (int& v : skill) {\nif (d[t - v]) {\nans += 1ll * v * (t - v);\n--d[t - v];\n--m;\n} else {\n++d[v];\n}\n}\nreturn m == 0 ? ans : -1;\n}\n};\n"]}, {"leetCodeID": "2492", "level": "middle", "question_description": "You are given a positive integer n representing n cities numbered from 1 to n. You are also given a 2D array roads where roads[i] = [ai, bi, distancei] indicates that there is a bidirectional road between cities ai and bi with a distance equal to distancei. The cities graph is not necessarily connected.\nThe score of a path between two cities is defined as the minimum distance of a road in this path.\nReturn the minimum possible score of a path between cities 1 and n.\nNote:\nA path is a sequence of roads between two cities.\nIt is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\nThe test cases are generated such that there is at least one path between 1 and n.", "examples": [], "constraints": "\nConstraints:\n2 <= n <= 105\n1 <= roads.length <= 105\nroads[i].length == 3\n1 <= ai, bi <= n\nai != bi\n1 <= distancei <= 104\nThere are no repeated edges.\nThere is at least one path between 1 and n.\n", "java_context": "\nclass Solution {\n    private List<int[]>[] g;\n        // your code\n    }\n}", "js_context": "\nvar minScore = function (n, roads) {\n// \u6784\u5efa\u70b9\u5230\u70b9\u7684\u6620\u5c04\u8868\nconst graph = Array.from({ length: n + 1 }, () => new Map());\nfor (let [u, v, w] of roads) {\ngraph[u].set(v, w);\ngraph[v].set(u, w);\n}\n\n// DFS\nconst vis = new Array(n).fill(false);\nlet ans = Infinity;\nvar dfs = function (u) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int minScore(int n, vector<vector<int>>& roads) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\nprivate List<int[]>[] g;\nprivate boolean[] vis;\nprivate int ans = 1 << 30;\n\npublic int minScore(int n, int[][] roads) {\ng = new List[n];\nvis = new boolean[n];\nArrays.setAll(g, k -> new ArrayList<>());\nfor (var e : roads) {\nint a = e[0] - 1, b = e[1] - 1, d = e[2];\ng[a].add(new int[] {b, d});\ng[b].add(new int[] {a, d});\n}\ndfs(0);\nreturn ans;\n}\n\nprivate void dfs(int i) {\nfor (var nxt : g[i]) {\nint j = nxt[0], d = nxt[1];\nans = Math.min(ans, d);\nif (!vis[j]) {\nvis[j] = true;\ndfs(j);\n}\n}\n}\n}\n", "\nclass Solution {\npublic int minScore(int n, int[][] roads) {\nList<int[]>[] g = new List[n];\nboolean[] vis = new boolean[n];\nArrays.setAll(g, k -> new ArrayList<>());\nfor (var e : roads) {\nint a = e[0] - 1, b = e[1] - 1, d = e[2];\ng[a].add(new int[] {b, d});\ng[b].add(new int[] {a, d});\n}\nDeque<Integer> q = new ArrayDeque<>();\nq.offer(0);\nvis[0] = true;\nint ans = 1 << 30;\nwhile (!q.isEmpty()) {\nfor (int k = q.size(); k > 0; --k) {\nint i = q.pollFirst();\nfor (var nxt : g[i]) {\nint j = nxt[0], d = nxt[1];\nans = Math.min(ans, d);\nif (!vis[j]) {\nvis[j] = true;\nq.offer(j);\n}\n}\n}\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\nvar minScore = function (n, roads) {\n// \u6784\u5efa\u70b9\u5230\u70b9\u7684\u6620\u5c04\u8868\nconst graph = Array.from({ length: n + 1 }, () => new Map());\nfor (let [u, v, w] of roads) {\ngraph[u].set(v, w);\ngraph[v].set(u, w);\n}\n\n// DFS\nconst vis = new Array(n).fill(false);\nlet ans = Infinity;\nvar dfs = function (u) {\nvis[u] = true;\nfor (const [v, w] of graph[u]) {\nans = Math.min(ans, w);\nif (!vis[v]) dfs(v);\n}\n};\ndfs(1);\n\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint minScore(int n, vector<vector<int>>& roads) {\nvector<vector<pair<int, int>>> g(n);\nbool vis[n];\nmemset(vis, 0, sizeof vis);\nfor (auto& e : roads) {\nint a = e[0] - 1, b = e[1] - 1, d = e[2];\ng[a].emplace_back(b, d);\ng[b].emplace_back(a, d);\n}\nint ans = INT_MAX;\nfunction<void(int)> dfs = [&](int i) {\nfor (auto [j, d] : g[i]) {\nans = min(ans, d);\nif (!vis[j]) {\nvis[j] = true;\ndfs(j);\n}\n}\n};\ndfs(0);\nreturn ans;\n}\n};\n", "\nclass Solution {\npublic:\nint minScore(int n, vector<vector<int>>& roads) {\nvector<vector<pair<int, int>>> g(n);\nbool vis[n];\nmemset(vis, 0, sizeof vis);\nfor (auto& e : roads) {\nint a = e[0] - 1, b = e[1] - 1, d = e[2];\ng[a].emplace_back(b, d);\ng[b].emplace_back(a, d);\n}\nint ans = INT_MAX;\nqueue<int> q{{0}};\nvis[0] = true;\nwhile (!q.empty()) {\nfor (int k = q.size(); k; --k) {\nint i = q.front();\nq.pop();\nfor (auto [j, d] : g[i]) {\nans = min(ans, d);\nif (!vis[j]) {\nvis[j] = true;\nq.push(j);\n}\n}\n}\n}\nreturn ans;\n}\n};\n"]}]