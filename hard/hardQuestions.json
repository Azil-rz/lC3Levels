[{"leetCodeID": "0004", "level": "hard", "question_description": "Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\nThe overall run time complexity should be O(log (m+n)).", "examples": ["Example 1:\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\n", "Example 2:\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n"], "constraints": "\nConstraints:\nnums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-106 <= nums1[i], nums2[i] <= 106\n", "java_context": "\nclass Solution {\n    private int m;\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums1\n* @param {number[]} nums2\n* @return {number}\n*/\nvar findMedianSortedArrays = function (nums1, nums2) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\nprivate int m;\nprivate int n;\nprivate int[] nums1;\nprivate int[] nums2;\n\npublic double findMedianSortedArrays(int[] nums1, int[] nums2) {\nm = nums1.length;\nn = nums2.length;\nthis.nums1 = nums1;\nthis.nums2 = nums2;\nint a = f(0, 0, (m + n + 1) / 2);\nint b = f(0, 0, (m + n + 2) / 2);\nreturn (a + b) / 2.0;\n}\n\nprivate int f(int i, int j, int k) {\nif (i >= m) {\nreturn nums2[j + k - 1];\n}\nif (j >= n) {\nreturn nums1[i + k - 1];\n}\nif (k == 1) {\nreturn Math.min(nums1[i], nums2[j]);\n}\nint p = k / 2;\nint x = i + p - 1 < m ? nums1[i + p - 1] : 1 << 30;\nint y = j + p - 1 < n ? nums2[j + p - 1] : 1 << 30;\nreturn x < y ? f(i + p, j, k - p) : f(i, j + p, k - p);\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums1\n* @param {number[]} nums2\n* @return {number}\n*/\nvar findMedianSortedArrays = function (nums1, nums2) {\nconst m = nums1.length;\nconst n = nums2.length;\nconst f = (i, j, k) => {\nif (i >= m) {\nreturn nums2[j + k - 1];\n}\nif (j >= n) {\nreturn nums1[i + k - 1];\n}\nif (k == 1) {\nreturn Math.min(nums1[i], nums2[j]);\n}\nconst p = Math.floor(k / 2);\nconst x = i + p - 1 < m ? nums1[i + p - 1] : 1 << 30;\nconst y = j + p - 1 < n ? nums2[j + p - 1] : 1 << 30;\nreturn x < y ? f(i + p, j, k - p) : f(i, j + p, k - p);\n};\nconst a = f(0, 0, Math.floor((m + n + 1) / 2));\nconst b = f(0, 0, Math.floor((m + n + 2) / 2));\nreturn (a + b) / 2;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\ndouble findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\nint m = nums1.size(), n = nums2.size();\nfunction<int(int, int, int)> f = [&](int i, int j, int k) {\nif (i >= m) {\nreturn nums2[j + k - 1];\n}\nif (j >= n) {\nreturn nums1[i + k - 1];\n}\nif (k == 1) {\nreturn min(nums1[i], nums2[j]);\n}\nint p = k / 2;\nint x = i + p - 1 < m ? nums1[i + p - 1] : 1 << 30;\nint y = j + p - 1 < n ? nums2[j + p - 1] : 1 << 30;\nreturn x < y ? f(i + p, j, k - p) : f(i, j + p, k - p);\n};\nint a = f(0, 0, (m + n + 1) / 2);\nint b = f(0, 0, (m + n + 2) / 2);\nreturn (a + b) / 2.0;\n}\n};\n"]}, {"leetCodeID": "0010", "level": "hard", "question_description": "Given an input string s and a pattern p, implement regular expression matching with support for &#39;.&#39; and &#39;*&#39; where:\n&#39;.&#39; Matches any single character.\u200b\u200b\u200b\u200b\n&#39;*&#39; Matches zero or more of the preceding element.\nThe matching should cover the entire input string (not partial).", "examples": ["Example 1:\nInput: s = &quot;aa&quot;, p = &quot;a&quot;\nOutput: false\nExplanation: &quot;a&quot; does not match the entire string &quot;aa&quot;.\n", "Example 2:\nInput: s = &quot;aa&quot;, p = &quot;a*&quot;\nOutput: true\nExplanation: &#39;*&#39; means zero or more of the preceding element, &#39;a&#39;. Therefore, by repeating &#39;a&#39; once, it becomes &quot;aa&quot;.\n", "Example 3:\nInput: s = &quot;ab&quot;, p = &quot;.*&quot;\nOutput: true\nExplanation: &quot;.*&quot; means &quot;zero or more (*) of any character (.)&quot;.\n"], "constraints": "\nConstraints:\n1 <= s.length&nbsp;<= 20\n1 <= p.length&nbsp;<= 20\ns contains only lowercase English letters.\np contains only lowercase English letters, &#39;.&#39;, and&nbsp;&#39;*&#39;.\nIt is guaranteed for each appearance of the character &#39;*&#39;, there will be a previous valid character to match.\n", "java_context": "\nclass Solution {\n    private Boolean[][] f;\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} s\n* @param {string} p\n* @return {boolean}\n*/\nvar isMatch = function (s, p) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    bool isMatch(string s, string p) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\nprivate Boolean[][] f;\nprivate String s;\nprivate String p;\nprivate int m;\nprivate int n;\n\npublic boolean isMatch(String s, String p) {\nm = s.length();\nn = p.length();\nf = new Boolean[m + 1][n + 1];\nthis.s = s;\nthis.p = p;\nreturn dfs(0, 0);\n}\n\nprivate boolean dfs(int i, int j) {\nif (j >= n) {\nreturn i == m;\n}\nif (f[i][j] != null) {\nreturn f[i][j];\n}\nboolean res = false;\nif (j + 1 < n && p.charAt(j + 1) == '*') {\nres = dfs(i, j + 2)\n|| (i < m && (s.charAt(i) == p.charAt(j) || p.charAt(j) == '.') && dfs(i + 1, j));\n} else {\nres = i < m && (s.charAt(i) == p.charAt(j) || p.charAt(j) == '.') && dfs(i + 1, j + 1);\n}\nreturn f[i][j] = res;\n}\n}\n", "\nclass Solution {\npublic boolean isMatch(String s, String p) {\nint m = s.length(), n = p.length();\nboolean[][] f = new boolean[m + 1][n + 1];\nf[0][0] = true;\nfor (int i = 0; i <= m; ++i) {\nfor (int j = 1; j <= n; ++j) {\nif (p.charAt(j - 1) == '*') {\nf[i][j] = f[i][j - 2];\nif (i > 0 && (p.charAt(j - 2) == '.' || p.charAt(j - 2) == s.charAt(i - 1))) {\nf[i][j] |= f[i - 1][j];\n}\n} else if (i > 0\n&& (p.charAt(j - 1) == '.' || p.charAt(j - 1) == s.charAt(i - 1))) {\nf[i][j] = f[i - 1][j - 1];\n}\n}\n}\nreturn f[m][n];\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} s\n* @param {string} p\n* @return {boolean}\n*/\nvar isMatch = function (s, p) {\nconst m = s.length;\nconst n = p.length;\nconst f = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));\nconst dfs = (i, j) => {\nif (j >= n) {\nreturn i === m;\n}\nif (f[i][j]) {\nreturn f[i][j] === 1;\n}\nlet res = -1;\nif (j + 1 < n && p[j + 1] === '*') {\nif (dfs(i, j + 2) || (i < m && (s[i] === p[j] || p[j] === '.') && dfs(i + 1, j))) {\nres = 1;\n}\n} else if (i < m && (s[i] === p[j] || p[j] === '.') && dfs(i + 1, j + 1)) {\nres = 1;\n}\nf[i][j] = res;\nreturn res === 1;\n};\nreturn dfs(0, 0);\n};\n", "\n/**\n* @param {string} s\n* @param {string} p\n* @return {boolean}\n*/\nvar isMatch = function (s, p) {\nconst m = s.length;\nconst n = p.length;\nconst f = Array.from({ length: m + 1 }, () => Array(n + 1).fill(false));\nf[0][0] = true;\nfor (let i = 0; i <= m; ++i) {\nfor (let j = 1; j <= n; ++j) {\nif (p[j - 1] === '*') {\nf[i][j] = f[i][j - 2];\nif (i && (p[j - 2] === '.' || p[j - 2] === s[i - 1])) {\nf[i][j] |= f[i - 1][j];\n}\n} else if (i && (p[j - 1] === '.' || p[j - 1] === s[i - 1])) {\nf[i][j] = f[i - 1][j - 1];\n}\n}\n}\nreturn f[m][n];\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nbool isMatch(string s, string p) {\nint m = s.size(), n = p.size();\nint f[m + 1][n + 1];\nmemset(f, 0, sizeof f);\nfunction<bool(int, int)> dfs = [&](int i, int j) -> bool {\nif (j >= n) {\nreturn i == m;\n}\nif (f[i][j]) {\nreturn f[i][j] == 1;\n}\nint res = -1;\nif (j + 1 < n && p[j + 1] == '*') {\nif (dfs(i, j + 2) or (i < m and (s[i] == p[j] or p[j] == '.') and dfs(i + 1, j))) {\nres = 1;\n}\n} else if (i < m and (s[i] == p[j] or p[j] == '.') and dfs(i + 1, j + 1)) {\nres = 1;\n}\nf[i][j] = res;\nreturn res == 1;\n};\nreturn dfs(0, 0);\n}\n};\n", "\nclass Solution {\npublic:\nbool isMatch(string s, string p) {\nint m = s.size(), n = p.size();\nbool f[m + 1][n + 1];\nmemset(f, false, sizeof f);\nf[0][0] = true;\nfor (int i = 0; i <= m; ++i) {\nfor (int j = 1; j <= n; ++j) {\nif (p[j - 1] == '*') {\nf[i][j] = f[i][j - 2];\nif (i && (p[j - 2] == '.' || p[j - 2] == s[i - 1])) {\nf[i][j] |= f[i - 1][j];\n}\n} else if (i && (p[j - 1] == '.' || p[j - 1] == s[i - 1])) {\nf[i][j] = f[i - 1][j - 1];\n}\n}\n}\nreturn f[m][n];\n}\n};\n"]}, {"leetCodeID": "0023", "level": "hard", "question_description": "You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\nMerge all the linked-lists into one sorted linked-list and return it.", "examples": ["Example 1:\nInput: lists = [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]\nExplanation: The linked-lists are:\n[\n1-&gt;4-&gt;5,\n1-&gt;3-&gt;4,\n2-&gt;6\n]\nmerging them into one sorted list:\n1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6\n", "Example 2:\nInput: lists = []\nOutput: []\n", "Example 3:\nInput: lists = [[]]\nOutput: []\n"], "constraints": "\nConstraints:\nk == lists.length\n0 <= k <= 104\n0 <= lists[i].length <= 500\n-104 <= lists[i][j] <= 104\nlists[i] is sorted in ascending order.\nThe sum of lists[i].length will not exceed 104.\n", "java_context": "\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode() {}\n*     ListNode(int val) { this.val = val; }\n*     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n* }\n*/\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for singly-linked list.\n* function ListNode(val, next) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.next = (next===undefined ? null : next)\n* }\n*/\n/**\n* @param {ListNode[]} lists\n* @return {ListNode}\n*/\nvar mergeKLists = function (lists) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for singly-linked list.\n* public class ListNode {\n*     int val;\n*     ListNode next;\n*     ListNode() {}\n*     ListNode(int val) { this.val = val; }\n*     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n* }\n*/\nclass Solution {\npublic ListNode mergeKLists(ListNode[] lists) {\nPriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\nfor (ListNode head : lists) {\nif (head != null) {\npq.offer(head);\n}\n}\nListNode dummy = new ListNode();\nListNode cur = dummy;\nwhile (!pq.isEmpty()) {\nListNode node = pq.poll();\nif (node.next != null) {\npq.offer(node.next);\n}\ncur.next = node;\ncur = cur.next;\n}\nreturn dummy.next;\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for singly-linked list.\n* function ListNode(val, next) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.next = (next===undefined ? null : next)\n* }\n*/\n/**\n* @param {ListNode[]} lists\n* @return {ListNode}\n*/\nvar mergeKLists = function (lists) {\nconst pq = new MinPriorityQueue({ priority: node => node.val });\nfor (const head of lists) {\nif (head) {\npq.enqueue(head);\n}\n}\nconst dummy = new ListNode();\nlet cur = dummy;\nwhile (!pq.isEmpty()) {\nconst node = pq.dequeue().element;\ncur.next = node;\ncur = cur.next;\nif (node.next) {\npq.enqueue(node.next);\n}\n}\nreturn dummy.next;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for singly-linked list.\n* struct ListNode {\n*     int val;\n*     ListNode *next;\n*     ListNode() : val(0), next(nullptr) {}\n*     ListNode(int x) : val(x), next(nullptr) {}\n*     ListNode(int x, ListNode *next) : val(x), next(next) {}\n* };\n*/\nclass Solution {\npublic:\nListNode* mergeKLists(vector<ListNode*>& lists) {\nauto cmp = [](ListNode* a, ListNode* b) { return a->val > b->val; };\npriority_queue<ListNode*, vector<ListNode*>, decltype(cmp)> pq;\nfor (auto head : lists) {\nif (head) {\npq.push(head);\n}\n}\nListNode* dummy = new ListNode();\nListNode* cur = dummy;\nwhile (!pq.empty()) {\nListNode* node = pq.top();\npq.pop();\nif (node->next) {\npq.push(node->next);\n}\ncur->next = node;\ncur = cur->next;\n}\nreturn dummy->next;\n}\n};\n"]}, {"leetCodeID": "0032", "level": "hard", "question_description": "Given a string containing just the characters &#39;(&#39; and &#39;)&#39;, return the length of the longest valid (well-formed) parentheses substring.", "examples": ["Example 1:\nInput: s = &quot;(()&quot;\nOutput: 2\nExplanation: The longest valid parentheses substring is &quot;()&quot;.\n", "Example 2:\nInput: s = &quot;)()())&quot;\nOutput: 4\nExplanation: The longest valid parentheses substring is &quot;()()&quot;.\n", "Example 3:\nInput: s = &quot;&quot;\nOutput: 0\n"], "constraints": "\nConstraints:\n0 <= s.length <= 3 * 104\ns[i] is &#39;(&#39;, or &#39;)&#39;.\n", "java_context": "\nclass Solution {\n    public int longestValidParentheses(String s) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} s\n* @return {number}\n*/\nvar longestValidParentheses = function (s) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int longestValidParentheses(string s) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int longestValidParentheses(String s) {\nint n = s.length();\nint[] f = new int[n + 1];\nint ans = 0;\nfor (int i = 2; i <= n; ++i) {\nif (s.charAt(i - 1) == ')') {\nif (s.charAt(i - 2) == '(') {\nf[i] = f[i - 2] + 2;\n} else {\nint j = i - f[i - 1] - 1;\nif (j > 0 && s.charAt(j - 1) == '(') {\nf[i] = f[i - 1] + 2 + f[j - 1];\n}\n}\nans = Math.max(ans, f[i]);\n}\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} s\n* @return {number}\n*/\nvar longestValidParentheses = function (s) {\nconst n = s.length;\nconst f = new Array(n + 1).fill(0);\nfor (let i = 2; i <= n; ++i) {\nif (s[i - 1] === ')') {\nif (s[i - 2] === '(') {\nf[i] = f[i - 2] + 2;\n} else {\nconst j = i - f[i - 1] - 1;\nif (j && s[j - 1] === '(') {\nf[i] = f[i - 1] + 2 + f[j - 1];\n}\n}\n}\n}\nreturn Math.max(...f);\n};\n", "\n/**\n* @param {string} s\n* @return {number}\n*/\nvar longestValidParentheses = function (s) {\nlet ans = 0;\nconst stack = [-1];\nfor (i = 0; i < s.length; i++) {\nif (s.charAt(i) === '(') {\nstack.push(i);\n} else {\nstack.pop();\nif (stack.length === 0) {\nstack.push(i);\n} else {\nans = Math.max(ans, i - stack[stack.length - 1]);\n}\n}\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint longestValidParentheses(string s) {\nint n = s.size();\nint f[n + 1];\nmemset(f, 0, sizeof(f));\nfor (int i = 2; i <= n; ++i) {\nif (s[i - 1] == ')') {\nif (s[i - 2] == '(') {\nf[i] = f[i - 2] + 2;\n} else {\nint j = i - f[i - 1] - 1;\nif (j && s[j - 1] == '(') {\nf[i] = f[i - 1] + 2 + f[j - 1];\n}\n}\n}\n}\nreturn *max_element(f, f + n + 1);\n}\n};\n"]}, {"leetCodeID": "0124", "level": "hard", "question_description": "A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.\nThe path sum of a path is the sum of the node&#39;s values in the path.\nGiven the root of a binary tree, return the maximum path sum of any non-empty path.", "examples": [], "constraints": "\nConstraints:\nThe number of nodes in the tree is in the range [1, 3 * 104].\n-1000 <= Node.val <= 1000\n", "java_context": "\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\n    private int ans = -1001;\n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {number}\n*/\nvar maxPathSum = function (root) {\n    // your code\n};", "cpp_context": "\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\n    int maxPathSum(TreeNode* root) {\n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode() {}\n*     TreeNode(int val) { this.val = val; }\n*     TreeNode(int val, TreeNode left, TreeNode right) {\n*         this.val = val;\n*         this.left = left;\n*         this.right = right;\n*     }\n* }\n*/\nclass Solution {\nprivate int ans = -1001;\n\npublic int maxPathSum(TreeNode root) {\ndfs(root);\nreturn ans;\n}\n\nprivate int dfs(TreeNode root) {\nif (root == null) {\nreturn 0;\n}\nint left = Math.max(0, dfs(root.left));\nint right = Math.max(0, dfs(root.right));\nans = Math.max(ans, root.val + left + right);\nreturn root.val + Math.max(left, right);\n}\n}\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val, left, right) {\n*     this.val = (val===undefined ? 0 : val)\n*     this.left = (left===undefined ? null : left)\n*     this.right = (right===undefined ? null : right)\n* }\n*/\n/**\n* @param {TreeNode} root\n* @return {number}\n*/\nvar maxPathSum = function (root) {\nlet ans = -1001;\nconst dfs = root => {\nif (!root) {\nreturn 0;\n}\nconst left = Math.max(0, dfs(root.left));\nconst right = Math.max(0, dfs(root.right));\nans = Math.max(ans, left + right + root.val);\nreturn Math.max(left, right) + root.val;\n};\ndfs(root);\nreturn ans;\n};\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n*     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n*     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n* };\n*/\nclass Solution {\npublic:\nint maxPathSum(TreeNode* root) {\nint ans = -1001;\nfunction<int(TreeNode*)> dfs = [&](TreeNode* root) {\nif (!root) {\nreturn 0;\n}\nint left = max(0, dfs(root->left));\nint right = max(0, dfs(root->right));\nans = max(ans, left + right + root->val);\nreturn root->val + max(left, right);\n};\ndfs(root);\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0154", "level": "hard", "question_description": "Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,4,4,5,6,7] might become:\n[4,5,6,7,0,1,4] if it was rotated 4 times.\n[0,1,4,4,5,6,7] if it was rotated 7 times.\nNotice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].\nGiven the sorted rotated array nums that may contain duplicates, return the minimum element of this array.\nYou must decrease the overall operation steps as much as possible.", "examples": ["Example 1:Input: nums = [1,3,5]\nOutput: 1\n", "Example 2:Input: nums = [2,2,2,0,1]\nOutput: 0\n"], "constraints": "\nConstraints:\nn == nums.length\n1 <= n <= 5000\n-5000 <= nums[i] <= 5000\nnums is sorted and rotated between 1 and n times.\n", "java_context": "\nclass Solution {\n    public int findMin(int[] nums) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar findMin = function (nums) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int findMin(vector<int>& nums) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int findMin(int[] nums) {\nint left = 0, right = nums.length - 1;\nwhile (left < right) {\nint mid = (left + right) >> 1;\nif (nums[mid] > nums[right]) {\nleft = mid + 1;\n} else if (nums[mid] < nums[right]) {\nright = mid;\n} else {\n--right;\n}\n}\nreturn nums[left];\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @return {number}\n*/\nvar findMin = function (nums) {\nlet left = 0,\nright = nums.length - 1;\nwhile (left < right) {\nconst mid = (left + right) >> 1;\nif (nums[mid] > nums[right]) {\nleft = mid + 1;\n} else if (nums[mid] < nums[right]) {\nright = mid;\n} else {\n--right;\n}\n}\nreturn nums[left];\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint findMin(vector<int>& nums) {\nint left = 0, right = nums.size() - 1;\nwhile (left < right) {\nint mid = (left + right) >> 1;\nif (nums[mid] > nums[right])\nleft = mid + 1;\nelse if (nums[mid] < nums[right])\nright = mid;\nelse\n--right;\n}\nreturn nums[left];\n}\n};\n"]}, {"leetCodeID": "0239", "level": "hard", "question_description": "You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\nReturn the max sliding window.", "examples": ["Example 1:\nInput: nums = [1,3,-1,-3,5,3,6,7], k = 3\nOutput: [3,3,5,5,6,7]\nExplanation:\nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n1 [3  -1  -3] 5  3  6  7       3\n1  3 [-1  -3  5] 3  6  7       5\n1  3  -1 [-3  5  3] 6  7       5\n1  3  -1  -3 [5  3  6] 7       6\n1  3  -1  -3  5 [3  6  7]      7\n", "Example 2:\nInput: nums = [1], k = 1\nOutput: [1]\n"], "constraints": "\nConstraints:\n1 <= nums.length <= 105\n-104 <= nums[i] <= 104\n1 <= k <= nums.length\n", "java_context": "\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} nums\n* @param {number} k\n* @return {number[]}\n*/\nvar maxSlidingWindow = function (nums, k) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int[] maxSlidingWindow(int[] nums, int k) {\nPriorityQueue<int[]> q\n= new PriorityQueue<>((a, b) -> a[0] == b[0] ? a[1] - b[1] : b[0] - a[0]);\nint n = nums.length;\nfor (int i = 0; i < k - 1; ++i) {\nq.offer(new int[] {nums[i], i});\n}\nint[] ans = new int[n - k + 1];\nfor (int i = k - 1, j = 0; i < n; ++i) {\nq.offer(new int[] {nums[i], i});\nwhile (q.peek()[1] <= i - k) {\nq.poll();\n}\nans[j++] = q.peek()[0];\n}\nreturn ans;\n}\n}\n", "\nclass Solution {\npublic int[] maxSlidingWindow(int[] nums, int k) {\nint n = nums.length;\nint[] ans = new int[n - k + 1];\nDeque<Integer> q = new ArrayDeque<>();\nfor (int i = 0, j = 0; i < n; ++i) {\nif (!q.isEmpty() && i - k + 1 > q.peekFirst()) {\nq.pollFirst();\n}\nwhile (!q.isEmpty() && nums[q.peekLast()] <= nums[i]) {\nq.pollLast();\n}\nq.offer(i);\nif (i >= k - 1) {\nans[j++] = nums[q.peekFirst()];\n}\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} nums\n* @param {number} k\n* @return {number[]}\n*/\nvar maxSlidingWindow = function (nums, k) {\nlet ans = [];\nlet q = [];\nfor (let i = 0; i < nums.length; ++i) {\nif (q && i - k + 1 > q[0]) {\nq.shift();\n}\nwhile (q && nums[q[q.length - 1]] <= nums[i]) {\nq.pop();\n}\nq.push(i);\nif (i >= k - 1) {\nans.push(nums[q[0]]);\n}\n}\nreturn ans;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> maxSlidingWindow(vector<int>& nums, int k) {\npriority_queue<pair<int, int>> q;\nint n = nums.size();\nfor (int i = 0; i < k - 1; ++i) {\nq.push({nums[i], -i});\n}\nvector<int> ans;\nfor (int i = k - 1; i < n; ++i) {\nq.push({nums[i], -i});\nwhile (-q.top().second <= i - k) {\nq.pop();\n}\nans.emplace_back(q.top().first);\n}\nreturn ans;\n}\n};\n", "\nclass Solution {\npublic:\nvector<int> maxSlidingWindow(vector<int>& nums, int k) {\ndeque<int> q;\nvector<int> ans;\nfor (int i = 0; i < nums.size(); ++i) {\nif (!q.empty() && i - k + 1 > q.front()) {\nq.pop_front();\n}\nwhile (!q.empty() && nums[q.back()] <= nums[i]) {\nq.pop_back();\n}\nq.push_back(i);\nif (i >= k - 1) {\nans.emplace_back(nums[q.front()]);\n}\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "0295", "level": "hard", "question_description": "The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.\nFor example, for arr = [2,3,4], the median is 3.\nFor example, for arr = [2,3], the median is (2 + 3) / 2 = 2.5.\nImplement the MedianFinder class:\nMedianFinder() initializes the MedianFinder object.\nvoid addNum(int num) adds the integer num from the data stream to the data structure.\ndouble findMedian() returns the median of all elements so far. Answers within 10-5 of the actual answer will be accepted.", "examples": ["Example 1:\nInput\n[&quot;MedianFinder&quot;, &quot;addNum&quot;, &quot;addNum&quot;, &quot;findMedian&quot;, &quot;addNum&quot;, &quot;findMedian&quot;]\n[[], [1], [2], [], [3], []]\nOutput\n[null, null, null, 1.5, null, 2.0]\n\nExplanation\nMedianFinder medianFinder = new MedianFinder();\nmedianFinder.addNum(1);    // arr = [1]\nmedianFinder.addNum(2);    // arr = [1, 2]\nmedianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)\nmedianFinder.addNum(3);    // arr[1, 2, 3]\nmedianFinder.findMedian(); // return 2.0\n"], "constraints": "\nConstraints:\n-105 <= num <= 105\nThere will be at least one element in the data structure before calling findMedian.\nAt most 5 * 104 calls will be made to addNum and findMedian.\n", "java_context": "    \n        // your code\n    }\n}", "js_context": "\n/**\n* initialize your data structure here.\n*/\nvar MedianFinder = function () {\n    // your code\n};", "cpp_context": "    \n        // your code\n    }\n};", "java_solutions": ["\nclass MedianFinder {\nprivate PriorityQueue<Integer> q1 = new PriorityQueue<>();\nprivate PriorityQueue<Integer> q2 = new PriorityQueue<>(Collections.reverseOrder());\n\n/** initialize your data structure here. */\npublic MedianFinder() {\n}\n\npublic void addNum(int num) {\nq1.offer(num);\nq2.offer(q1.poll());\nif (q2.size() - q1.size() > 1) {\nq1.offer(q2.poll());\n}\n}\n\npublic double findMedian() {\nif (q2.size() > q1.size()) {\nreturn q2.peek();\n}\nreturn (q1.peek() + q2.peek()) * 1.0 / 2;\n}\n}\n\n/**\n* Your MedianFinder object will be instantiated and called as such:\n* MedianFinder obj = new MedianFinder();\n* obj.addNum(num);\n* double param_2 = obj.findMedian();\n*/\n"], "js_solutions": ["\n/**\n* initialize your data structure here.\n*/\nvar MedianFinder = function () {\nthis.val = [];\n};\n\n/**\n* @param {number} num\n* @return {void}\n*/\nMedianFinder.prototype.addNum = function (num) {\nlet left = 0;\nlet right = this.val.length;\nwhile (left < right) {\nlet mid = left + ~~((right - left) / 2);\nif (num > this.val[mid]) {\nleft = mid + 1;\n} else {\nright = mid;\n}\n}\nthis.val.splice(left, 0, num);\n};\n\n/**\n* @return {number}\n*/\nMedianFinder.prototype.findMedian = function () {\nlet mid = ~~(this.val.length / 2);\nreturn this.val.length % 2 ? this.val[mid] : (this.val[mid - 1] + this.val[mid]) / 2;\n};\n"], "cpp_solutions": ["\nclass MedianFinder {\npublic:\n/** initialize your data structure here. */\nMedianFinder() {\n}\n\nvoid addNum(int num) {\nq1.push(num);\nq2.push(q1.top());\nq1.pop();\nif (q2.size() - q1.size() > 1) {\nq1.push(q2.top());\nq2.pop();\n}\n}\n\ndouble findMedian() {\nif (q2.size() > q1.size()) {\nreturn q2.top();\n}\nreturn (double) (q1.top() + q2.top()) / 2;\n}\n\nprivate:\npriority_queue<int, vector<int>, greater<int>> q1;\npriority_queue<int> q2;\n};\n\n/**\n* Your MedianFinder object will be instantiated and called as such:\n* MedianFinder* obj = new MedianFinder();\n* obj->addNum(num);\n* double param_2 = obj->findMedian();\n*/\n"]}, {"leetCodeID": "0297", "level": "hard", "question_description": "Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\nDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\nClarification: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.", "examples": ["Example 1:\n\n\nInput: root = [1,2,3,null,null,4,5]\nOutput: [1,2,3,null,null,4,5]\n\n\nExample 2:\nInput: root = []\nOutput: []\n"], "constraints": "\nConstraints:\nThe number of nodes in the tree is in the range [0, 104].\n-1000 <= Node.val <= 1000\n", "java_context": "    \n        // your code\n    }\n}", "js_context": "\n/**\n* Definition for a binary tree node.\n* function TreeNode(val) {\n*     this.val = val;\n*     this.left = this.right = null;\n* }\n*/\n\n/**\n* Encodes a tree to a single string.\n*\n* @param {TreeNode} root\n* @return {string}\n*/\nvar serialize = function (root) {\nreturn rserialize(root, '');\n};\n\n/**\n* Decodes your encoded data to tree.\n*\n* @param {string} data\n* @return {TreeNode}\n*/\nvar deserialize = function (data) {\n    // your code\n};", "cpp_context": "    \n        // your code\n    }\n};", "java_solutions": ["\n/**\n* Definition for a binary tree node.\n* public class TreeNode {\n*     int val;\n*     TreeNode left;\n*     TreeNode right;\n*     TreeNode(int x) { val = x; }\n* }\n*/\npublic class Codec {\nprivate static final String NULL = \"#\";\nprivate static final String SEP = \",\";\n\n// Encodes a tree to a single string.\npublic String serialize(TreeNode root) {\nif (root == null) {\nreturn \"\";\n}\nStringBuilder sb = new StringBuilder();\npreorder(root, sb);\nreturn sb.toString();\n}\n\nprivate void preorder(TreeNode root, StringBuilder sb) {\nif (root == null) {\nsb.append(NULL + SEP);\nreturn;\n}\nsb.append(root.val + SEP);\npreorder(root.left, sb);\npreorder(root.right, sb);\n}\n\n// Decodes your encoded data to tree.\npublic TreeNode deserialize(String data) {\nif (data == null || \"\".equals(data)) {\nreturn null;\n}\nList<String> vals = new LinkedList<>();\nfor (String x : data.split(SEP)) {\nvals.add(x);\n}\nreturn deserialize(vals);\n}\n\nprivate TreeNode deserialize(List<String> vals) {\nString first = vals.remove(0);\nif (NULL.equals(first)) {\nreturn null;\n}\nTreeNode root = new TreeNode(Integer.parseInt(first));\nroot.left = deserialize(vals);\nroot.right = deserialize(vals);\nreturn root;\n}\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec ser = new Codec();\n// Codec deser = new Codec();\n// TreeNode ans = deser.deserialize(ser.serialize(root));\n"], "js_solutions": ["\n/**\n* Definition for a binary tree node.\n* function TreeNode(val) {\n*     this.val = val;\n*     this.left = this.right = null;\n* }\n*/\n\n/**\n* Encodes a tree to a single string.\n*\n* @param {TreeNode} root\n* @return {string}\n*/\nvar serialize = function (root) {\nreturn rserialize(root, '');\n};\n\n/**\n* Decodes your encoded data to tree.\n*\n* @param {string} data\n* @return {TreeNode}\n*/\nvar deserialize = function (data) {\nconst dataArray = data.split(',');\nreturn rdeserialize(dataArray);\n};\n\nconst rserialize = (root, str) => {\nif (root === null) {\nstr += '#,';\n} else {\nstr += root.val + '' + ',';\nstr = rserialize(root.left, str);\nstr = rserialize(root.right, str);\n}\nreturn str;\n};\n\nconst rdeserialize = dataList => {\nif (dataList[0] === '#') {\ndataList.shift();\nreturn null;\n}\n\nconst root = new TreeNode(parseInt(dataList[0]));\ndataList.shift();\nroot.left = rdeserialize(dataList);\nroot.right = rdeserialize(dataList);\n\nreturn root;\n};\n\n/**\n* Your functions will be called as such:\n* deserialize(serialize(root));\n*/\n"], "cpp_solutions": ["\n/**\n* Definition for a binary tree node.\n* struct TreeNode {\n*     int val;\n*     TreeNode *left;\n*     TreeNode *right;\n*     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\n* };\n*/\nclass Codec {\npublic:\n// Encodes a tree to a single string.\nstring serialize(TreeNode* root) {\nif (!root) return \"\";\nstring s = \"\";\npreorder(root, s);\nreturn s;\n}\n\nvoid preorder(TreeNode* root, string& s) {\nif (!root)\ns += \"# \";\nelse {\ns += to_string(root->val) + \" \";\npreorder(root->left, s);\npreorder(root->right, s);\n}\n}\n\n// Decodes your encoded data to tree.\nTreeNode* deserialize(string data) {\nif (data == \"\") return nullptr;\nstringstream ss(data);\nreturn deserialize(ss);\n}\n\nTreeNode* deserialize(stringstream& ss) {\nstring first;\nss >> first;\nif (first == \"#\") return nullptr;\nTreeNode* root = new TreeNode(stoi(first));\nroot->left = deserialize(ss);\nroot->right = deserialize(ss);\nreturn root;\n}\n};\n\n// Your Codec object will be instantiated and called as such:\n// Codec ser, deser;\n// TreeNode* ans = deser.deserialize(ser.serialize(root));\n"]}, {"leetCodeID": "0741", "level": "hard", "question_description": "You are given an n x n grid representing a field of cherries, each cell is one of three possible integers.\n0 means the cell is empty, so you can pass through,\n1 means the cell contains a cherry that you can pick up and pass through, or\n-1 means the cell contains a thorn that blocks your way.\nReturn the maximum number of cherries you can collect by following the rules below:\nStarting at the position (0, 0) and reaching (n - 1, n - 1) by moving right or down through valid path cells (cells with value 0 or 1).\nAfter reaching (n - 1, n - 1), returning to (0, 0) by moving left or up through valid path cells.\nWhen passing through a path cell containing a cherry, you pick it up, and the cell becomes an empty cell 0.\nIf there is no valid path between (0, 0) and (n - 1, n - 1), then no cherries can be collected.", "examples": ["Example 1:\n\n\nInput: grid = [[0,1,-1],[1,0,-1],[1,1,1]]\nOutput: 5\nExplanation: The player started at (0, 0) and went down, down, right right to reach (2, 2).\n4 cherries were picked up during this single trip, and the matrix becomes [[0,1,-1],[0,0,-1],[0,0,0]].\nThen, the player went left, up, up, left to return home, picking up one more cherry.\nThe total number of cherries picked up is 5, and this is the maximum possible.\n\n\nExample 2:\nInput: grid = [[1,1,-1],[1,-1,1],[-1,1,1]]\nOutput: 0\n"], "constraints": "\nConstraints:\nn == grid.length\nn == grid[i].length\n1 <= n <= 50\ngrid[i][j] is -1, 0, or 1.\ngrid[0][0] != -1\ngrid[n - 1][n - 1] != -1\n", "java_context": "\nclass Solution {\n    public int cherryPickup(int[][] grid) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[][]} grid\n* @return {number}\n*/\nvar cherryPickup = function (grid) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int cherryPickup(vector<vector<int>>& grid) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int cherryPickup(int[][] grid) {\nint n = grid.length;\nint[][][] f = new int[n * 2][n][n];\nf[0][0][0] = grid[0][0];\nfor (int k = 1; k < n * 2 - 1; ++k) {\nfor (int i1 = 0; i1 < n; ++i1) {\nfor (int i2 = 0; i2 < n; ++i2) {\nint j1 = k - i1, j2 = k - i2;\nf[k][i1][i2] = Integer.MIN_VALUE;\nif (j1 < 0 || j1 >= n || j2 < 0 || j2 >= n || grid[i1][j1] == -1\n|| grid[i2][j2] == -1) {\ncontinue;\n}\nint t = grid[i1][j1];\nif (i1 != i2) {\nt += grid[i2][j2];\n}\nfor (int x1 = i1 - 1; x1 <= i1; ++x1) {\nfor (int x2 = i2 - 1; x2 <= i2; ++x2) {\nif (x1 >= 0 && x2 >= 0) {\nf[k][i1][i2] = Math.max(f[k][i1][i2], f[k - 1][x1][x2] + t);\n}\n}\n}\n}\n}\n}\nreturn Math.max(0, f[n * 2 - 2][n - 1][n - 1]);\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[][]} grid\n* @return {number}\n*/\nvar cherryPickup = function (grid) {\nconst n = grid.length;\nconst f = Array.from({ length: n * 2 - 1 }, () =>\nArray.from({ length: n }, () => Array.from({ length: n }, () => -Infinity)),\n);\nf[0][0][0] = grid[0][0];\nfor (let k = 1; k < n * 2 - 1; ++k) {\nfor (let i1 = 0; i1 < n; ++i1) {\nfor (let i2 = 0; i2 < n; ++i2) {\nconst [j1, j2] = [k - i1, k - i2];\nif (\nj1 < 0 ||\nj1 >= n ||\nj2 < 0 ||\nj2 >= n ||\ngrid[i1][j1] == -1 ||\ngrid[i2][j2] == -1\n) {\ncontinue;\n}\nconst t = grid[i1][j1] + (i1 != i2 ? grid[i2][j2] : 0);\nfor (let x1 = i1 - 1; x1 <= i1; ++x1) {\nfor (let x2 = i2 - 1; x2 <= i2; ++x2) {\nif (x1 >= 0 && x2 >= 0) {\nf[k][i1][i2] = Math.max(f[k][i1][i2], f[k - 1][x1][x2] + t);\n}\n}\n}\n}\n}\n}\nreturn Math.max(0, f[n * 2 - 2][n - 1][n - 1]);\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint cherryPickup(vector<vector<int>>& grid) {\nint n = grid.size();\nvector<vector<vector<int>>> f(n << 1, vector<vector<int>>(n, vector<int>(n, -1e9)));\nf[0][0][0] = grid[0][0];\nfor (int k = 1; k < n * 2 - 1; ++k) {\nfor (int i1 = 0; i1 < n; ++i1) {\nfor (int i2 = 0; i2 < n; ++i2) {\nint j1 = k - i1, j2 = k - i2;\nif (j1 < 0 || j1 >= n || j2 < 0 || j2 >= n || grid[i1][j1] == -1 || grid[i2][j2] == -1) {\ncontinue;\n}\nint t = grid[i1][j1];\nif (i1 != i2) {\nt += grid[i2][j2];\n}\nfor (int x1 = i1 - 1; x1 <= i1; ++x1) {\nfor (int x2 = i2 - 1; x2 <= i2; ++x2) {\nif (x1 >= 0 && x2 >= 0) {\nf[k][i1][i2] = max(f[k][i1][i2], f[k - 1][x1][x2] + t);\n}\n}\n}\n}\n}\n}\nreturn max(0, f[n * 2 - 2][n - 1][n - 1]);\n}\n};\n"]}, {"leetCodeID": "0927", "level": "hard", "question_description": "You are given an array arr which consists of only zeros and ones, divide the array into three non-empty parts such that all of these parts represent the same binary value.\nIf it is possible, return any [i, j] with i + 1 &lt; j, such that:\narr[0], arr[1], ..., arr[i] is the first part,\narr[i + 1], arr[i + 2], ..., arr[j - 1] is the second part, and\narr[j], arr[j + 1], ..., arr[arr.length - 1] is the third part.\nAll three parts have equal binary values.\nIf it is not possible, return [-1, -1].\nNote that the entire part is used when considering what binary value it represents. For example, [1,1,0] represents 6 in decimal, not 3. Also, leading zeros are allowed, so [0,1,1] and [1,1] represent the same value.", "examples": ["Example 1:Input: arr = [1,0,1,0,1]\nOutput: [0,3]\n", "Example 2:Input: arr = [1,1,0,1,1]\nOutput: [-1,-1]\n", "Example 3:Input: arr = [1,1,0,0,1]\nOutput: [0,2]\n"], "constraints": "\nConstraints:\n3 <= arr.length <= 3 * 104\narr[i] is 0 or 1\n", "java_context": "\nclass Solution {\n    private int[] arr;\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[]} arr\n* @return {number[]}\n*/\nvar threeEqualParts = function (arr) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    vector<int> threeEqualParts(vector<int>& arr) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\nprivate int[] arr;\n\npublic int[] threeEqualParts(int[] arr) {\nthis.arr = arr;\nint cnt = 0;\nint n = arr.length;\nfor (int v : arr) {\ncnt += v;\n}\nif (cnt % 3 != 0) {\nreturn new int[] {-1, -1};\n}\nif (cnt == 0) {\nreturn new int[] {0, n - 1};\n}\ncnt /= 3;\n\nint i = find(1), j = find(cnt + 1), k = find(cnt * 2 + 1);\nfor (; k < n && arr[i] == arr[j] && arr[j] == arr[k]; ++i, ++j, ++k) {\n}\nreturn k == n ? new int[] {i - 1, j} : new int[] {-1, -1};\n}\n\nprivate int find(int x) {\nint s = 0;\nfor (int i = 0; i < arr.length; ++i) {\ns += arr[i];\nif (s == x) {\nreturn i;\n}\n}\nreturn 0;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[]} arr\n* @return {number[]}\n*/\nvar threeEqualParts = function (arr) {\nfunction find(x) {\nlet s = 0;\nfor (let i = 0; i < n; ++i) {\ns += arr[i];\nif (s == x) {\nreturn i;\n}\n}\nreturn 0;\n}\nconst n = arr.length;\nlet cnt = 0;\nfor (const v of arr) {\ncnt += v;\n}\nif (cnt % 3) {\nreturn [-1, -1];\n}\nif (cnt == 0) {\nreturn [0, n - 1];\n}\ncnt = Math.floor(cnt / 3);\nlet [i, j, k] = [find(1), find(cnt + 1), find(cnt * 2 + 1)];\nfor (; k < n && arr[i] == arr[j] && arr[j] == arr[k]; ++i, ++j, ++k) {}\nreturn k == n ? [i - 1, j] : [-1, -1];\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nvector<int> threeEqualParts(vector<int>& arr) {\nint n = arr.size();\nint cnt = accumulate(arr.begin(), arr.end(), 0);\nif (cnt % 3) return {-1, -1};\nif (!cnt) return {0, n - 1};\ncnt /= 3;\n\nauto find = [&](int x) {\nint s = 0;\nfor (int i = 0; i < n; ++i) {\ns += arr[i];\nif (s == x) return i;\n}\nreturn 0;\n};\nint i = find(1), j = find(cnt + 1), k = find(cnt * 2 + 1);\nfor (; k < n && arr[i] == arr[j] && arr[j] == arr[k]; ++i, ++j, ++k) {}\nreturn k == n ? vector<int>{i - 1, j} : vector<int>{-1, -1};\n}\n};\n"]}, {"leetCodeID": "1183", "level": "hard", "question_description": "Consider a matrix M with dimensions width * height, such that every cell has value 0 or 1, and any square sub-matrix of M of size sideLength * sideLength has at most maxOnes ones.\nReturn the maximum possible number of ones that the matrix M can have.", "examples": ["Example 1:\nInput: width = 3, height = 3, sideLength = 2, maxOnes = 1\nOutput: 4\nExplanation:\nIn a 3*3 matrix, no 2*2 sub-matrix can have more than 1 one.\nThe best solution that has 4 ones is:\n[1,0,1]\n[0,0,0]\n[1,0,1]\n", "Example 2:\nInput: width = 3, height = 3, sideLength = 2, maxOnes = 2\nOutput: 6\nExplanation:\n[1,0,1]\n[1,0,1]\n[1,0,1]\n"], "constraints": "\nConstraints:\n1 <= width, height <= 100\n1 <= sideLength <= width, height\n0 <= maxOnes <= sideLength * sideLength\n", "java_context": "\nclass Solution {\n    public int maximumNumberOfOnes(int width, int height, int sideLength, int maxOnes) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number} width\n* @param {number} height\n* @param {number} sideLength\n* @param {number} maxOnes\n* @return {number}\n*/\nvar maximumNumberOfOnes = function (width, height, sideLength, maxOnes) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int maximumNumberOfOnes(int width, int height, int sideLength, int maxOnes) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int maximumNumberOfOnes(int width, int height, int sideLength, int maxOnes) {\nint x = sideLength;\nint[] cnt = new int[x * x];\nfor (int i = 0; i < width; ++i) {\nfor (int j = 0; j < height; ++j) {\nint k = (i % x) * x + (j % x);\n++cnt[k];\n}\n}\nArrays.sort(cnt);\nint ans = 0;\nfor (int i = 0; i < maxOnes; ++i) {\nans += cnt[cnt.length - i - 1];\n}\nreturn ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number} width\n* @param {number} height\n* @param {number} sideLength\n* @param {number} maxOnes\n* @return {number}\n*/\nvar maximumNumberOfOnes = function (width, height, sideLength, maxOnes) {\nconst x = sideLength;\nconst cnt = new Array(x * x).fill(0);\nfor (let i = 0; i < width; ++i) {\nfor (let j = 0; j < height; ++j) {\nconst k = (i % x) * x + (j % x);\n++cnt[k];\n}\n}\ncnt.sort((a, b) => b - a);\nreturn cnt.slice(0, maxOnes).reduce((a, b) => a + b, 0);\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint maximumNumberOfOnes(int width, int height, int sideLength, int maxOnes) {\nint x = sideLength;\nvector<int> cnt(x * x);\nfor (int i = 0; i < width; ++i) {\nfor (int j = 0; j < height; ++j) {\nint k = (i % x) * x + (j % x);\n++cnt[k];\n}\n}\nsort(cnt.rbegin(), cnt.rend());\nint ans = 0;\nfor (int i = 0; i < maxOnes; ++i) {\nans += cnt[i];\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1210", "level": "hard", "question_description": "In an n*n grid, there is a snake that spans 2 cells and starts moving from the top left corner at (0, 0) and (0, 1). The grid has empty cells represented by zeros and blocked cells represented by ones. The snake wants to reach the lower right corner at (n-1, n-2) and (n-1, n-1).\nIn one move the snake can:\nMove one cell to the right if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\nMove down one cell if there are no blocked cells there. This move keeps the horizontal/vertical position of the snake as it is.\nRotate clockwise if it&#39;s in a horizontal position and the two cells under it are both empty. In that case the snake moves from (r, c) and (r, c+1) to (r, c) and (r+1, c).\nRotate counterclockwise if it&#39;s in a vertical position and the two cells to its right are both empty. In that case the snake moves from (r, c) and (r+1, c) to (r, c) and (r, c+1).\nReturn the minimum number of moves to reach the target.\nIf there is no way to reach the target, return -1.", "examples": ["Example 1:\n\n\nInput: grid = [[0,0,0,0,0,1],\n[1,1,0,0,1,0],\n&nbsp;              [0,0,0,0,1,1],\n&nbsp;              [0,0,1,0,1,0],\n&nbsp;              [0,1,1,0,0,0],\n&nbsp;              [0,1,1,0,0,0]]\nOutput: 11\nExplanation:\nOne possible solution is [right, right, rotate clockwise, right, down, down, down, down, rotate counterclockwise, right, down].\n", "Example 2:\nInput: grid = [[0,0,1,1,1,1],\n&nbsp;              [0,0,0,0,1,1],\n&nbsp;              [1,1,0,0,0,1],\n&nbsp;              [1,1,1,0,0,1],\n&nbsp;              [1,1,1,0,0,1],\n&nbsp;              [1,1,1,0,0,0]]\nOutput: 9\n"], "constraints": "\nConstraints:\n2 <= n <= 100\n0 <= grid[i][j] <= 1\nIt is guaranteed that the snake starts at empty cells.\n", "java_context": "\nclass Solution {\n    private int n;\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[][]} grid\n* @return {number}\n*/\nvar minimumMoves = function (grid) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int minimumMoves(vector<vector<int>>& grid) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\nprivate int n;\nprivate int[][] grid;\nprivate boolean[][] vis;\nprivate Deque<int[]> q = new ArrayDeque<>();\n\npublic int minimumMoves(int[][] grid) {\nthis.grid = grid;\nn = grid.length;\nvis = new boolean[n * n][2];\nint[] target = {n * n - 2, n * n - 1};\nq.offer(new int[] {0, 1});\nvis[0][0] = true;\nint ans = 0;\nwhile (!q.isEmpty()) {\nfor (int k = q.size(); k > 0; --k) {\nvar p = q.poll();\nif (p[0] == target[0] && p[1] == target[1]) {\nreturn ans;\n}\nint i1 = p[0] / n, j1 = p[0] % n;\nint i2 = p[1] / n, j2 = p[1] % n;\n// \u5c1d\u8bd5\u5411\u53f3\u5e73\u79fb\uff08\u4fdd\u6301\u8eab\u4f53\u6c34\u5e73/\u5782\u76f4\u72b6\u6001\uff09\nmove(i1, j1 + 1, i2, j2 + 1);\n// \u5c1d\u8bd5\u5411\u4e0b\u5e73\u79fb\uff08\u4fdd\u6301\u8eab\u4f53\u6c34\u5e73/\u5782\u76f4\u72b6\u6001\uff09\nmove(i1 + 1, j1, i2 + 1, j2);\n// \u5f53\u524d\u5904\u4e8e\u6c34\u5e73\u72b6\u6001\uff0c\u4e14 grid[i1 + 1][j2] \u65e0\u969c\u788d\uff0c\u5c1d\u8bd5\u987a\u65f6\u9488\u65cb\u8f6c90\u00b0\nif (i1 == i2 && i1 + 1 < n && grid[i1 + 1][j2] == 0) {\nmove(i1, j1, i1 + 1, j1);\n}\n// \u5f53\u524d\u5904\u4e8e\u5782\u76f4\u72b6\u6001\uff0c\u4e14 grid[i2][j1 + 1] \u65e0\u969c\u788d\uff0c\u5c1d\u8bd5\u9006\u65f6\u9488\u65cb\u8f6c90\u00b0\nif (j1 == j2 && j1 + 1 < n && grid[i2][j1 + 1] == 0) {\nmove(i1, j1, i1, j1 + 1);\n}\n}\n++ans;\n}\nreturn -1;\n}\n\nprivate void move(int i1, int j1, int i2, int j2) {\nif (i1 >= 0 && i1 < n && j1 >= 0 && j1 < n && i2 >= 0 && i2 < n && j2 >= 0 && j2 < n) {\nint a = i1 * n + j1, b = i2 * n + j2;\nint status = i1 == i2 ? 0 : 1;\nif (!vis[a][status] && grid[i1][j1] == 0 && grid[i2][j2] == 0) {\nq.offer(new int[] {a, b});\nvis[a][status] = true;\n}\n}\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[][]} grid\n* @return {number}\n*/\nvar minimumMoves = function (grid) {\nconst n = grid.length;\nconst target = [n * n - 2, n * n - 1];\nconst q = [[0, 1]];\nconst vis = Array.from({ length: n * n }, () => Array(2).fill(false));\nvis[0][0] = true;\n\nconst move = (i1, j1, i2, j2) => {\nif (i1 >= 0 && i1 < n && j1 >= 0 && j1 < n && i2 >= 0 && i2 < n && j2 >= 0 && j2 < n) {\nconst a = i1 * n + j1;\nconst b = i2 * n + j2;\nconst status = i1 === i2 ? 0 : 1;\nif (!vis[a][status] && grid[i1][j1] == 0 && grid[i2][j2] == 0) {\nq.push([a, b]);\nvis[a][status] = true;\n}\n}\n};\n\nlet ans = 0;\nwhile (q.length) {\nfor (let k = q.length; k; --k) {\nconst p = q.shift();\nif (p[0] === target[0] && p[1] === target[1]) {\nreturn ans;\n}\nconst [i1, j1] = [~~(p[0] / n), p[0] % n];\nconst [i2, j2] = [~~(p[1] / n), p[1] % n];\n// \u5c1d\u8bd5\u5411\u53f3\u5e73\u79fb\uff08\u4fdd\u6301\u8eab\u4f53\u6c34\u5e73/\u5782\u76f4\u72b6\u6001\uff09\nmove(i1, j1 + 1, i2, j2 + 1);\n// \u5c1d\u8bd5\u5411\u4e0b\u5e73\u79fb\uff08\u4fdd\u6301\u8eab\u4f53\u6c34\u5e73/\u5782\u76f4\u72b6\u6001\uff09\nmove(i1 + 1, j1, i2 + 1, j2);\n// \u5f53\u524d\u5904\u4e8e\u6c34\u5e73\u72b6\u6001\uff0c\u4e14 grid[i1 + 1][j2] \u65e0\u969c\u788d\uff0c\u5c1d\u8bd5\u987a\u65f6\u9488\u65cb\u8f6c90\u00b0\nif (i1 == i2 && i1 + 1 < n && grid[i1 + 1][j2] == 0) {\nmove(i1, j1, i1 + 1, j1);\n}\n// \u5f53\u524d\u5904\u4e8e\u5782\u76f4\u72b6\u6001\uff0c\u4e14 grid[i2][j1 + 1] \u65e0\u969c\u788d\uff0c\u5c1d\u8bd5\u9006\u65f6\u9488\u65cb\u8f6c90\u00b0\nif (j1 == j2 && j1 + 1 < n && grid[i2][j1 + 1] == 0) {\nmove(i1, j1, i1, j1 + 1);\n}\n}\n++ans;\n}\nreturn -1;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint minimumMoves(vector<vector<int>>& grid) {\nint n = grid.size();\nauto target = make_pair(n * n - 2, n * n - 1);\nqueue<pair<int, int>> q;\nq.emplace(0, 1);\nbool vis[n * n][2];\nmemset(vis, 0, sizeof vis);\nvis[0][0] = true;\n\nauto move = [&](int i1, int j1, int i2, int j2) {\nif (i1 >= 0 && i1 < n && j1 >= 0 && j1 < n && i2 >= 0 && i2 < n && j2 >= 0 && j2 < n) {\nint a = i1 * n + j1, b = i2 * n + j2;\nint status = i1 == i2 ? 0 : 1;\nif (!vis[a][status] && grid[i1][j1] == 0 && grid[i2][j2] == 0) {\nq.emplace(a, b);\nvis[a][status] = true;\n}\n}\n};\n\nint ans = 0;\nwhile (!q.empty()) {\nfor (int k = q.size(); k; --k) {\nauto p = q.front();\nq.pop();\nif (p == target) {\nreturn ans;\n}\nauto [a, b] = p;\nint i1 = a / n, j1 = a % n;\nint i2 = b / n, j2 = b % n;\n// \u5c1d\u8bd5\u5411\u53f3\u5e73\u79fb\uff08\u4fdd\u6301\u8eab\u4f53\u6c34\u5e73/\u5782\u76f4\u72b6\u6001\uff09\nmove(i1, j1 + 1, i2, j2 + 1);\n// \u5c1d\u8bd5\u5411\u4e0b\u5e73\u79fb\uff08\u4fdd\u6301\u8eab\u4f53\u6c34\u5e73/\u5782\u76f4\u72b6\u6001\uff09\nmove(i1 + 1, j1, i2 + 1, j2);\n// \u5f53\u524d\u5904\u4e8e\u6c34\u5e73\u72b6\u6001\uff0c\u4e14 grid[i1 + 1][j2] \u65e0\u969c\u788d\uff0c\u5c1d\u8bd5\u987a\u65f6\u9488\u65cb\u8f6c90\u00b0\nif (i1 == i2 && i1 + 1 < n && grid[i1 + 1][j2] == 0) {\nmove(i1, j1, i1 + 1, j1);\n}\n// \u5f53\u524d\u5904\u4e8e\u5782\u76f4\u72b6\u6001\uff0c\u4e14 grid[i2][j1 + 1] \u65e0\u969c\u788d\uff0c\u5c1d\u8bd5\u9006\u65f6\u9488\u65cb\u8f6c90\u00b0\nif (j1 == j2 && j1 + 1 < n && grid[i2][j1 + 1] == 0) {\nmove(i1, j1, i1, j1 + 1);\n}\n}\n++ans;\n}\nreturn -1;\n}\n};\n"]}, {"leetCodeID": "1220", "level": "hard", "question_description": "Given an integer n, your task is to count how many strings of length n can be formed under the following rules:\nEach character is a lower case vowel (&#39;a&#39;, &#39;e&#39;, &#39;i&#39;, &#39;o&#39;, &#39;u&#39;)\nEach vowel &#39;a&#39; may only be followed by an &#39;e&#39;.\nEach vowel &#39;e&#39; may only be followed by an &#39;a&#39; or an &#39;i&#39;.\nEach vowel &#39;i&#39; may not be followed by another &#39;i&#39;.\nEach vowel &#39;o&#39; may only be followed by an &#39;i&#39; or a &#39;u&#39;.\nEach vowel &#39;u&#39; may only be followed by an &#39;a&#39;.\nSince the answer may be too large, return it modulo 10^9 + 7.", "examples": ["Example 1:\nInput: n = 1\nOutput: 5\nExplanation: All possible strings are: &quot;a&quot;, &quot;e&quot;, &quot;i&quot; , &quot;o&quot; and &quot;u&quot;.\n", "Example 2:\nInput: n = 2\nOutput: 10\nExplanation: All possible strings are: &quot;ae&quot;, &quot;ea&quot;, &quot;ei&quot;, &quot;ia&quot;, &quot;ie&quot;, &quot;io&quot;, &quot;iu&quot;, &quot;oi&quot;, &quot;ou&quot; and &quot;ua&quot;.\n", "Example 3:&nbsp;\nInput: n = 5\nOutput: 68"], "constraints": "\nConstraints:\n1 <= n <= 2 * 10^4\n", "java_context": "\nclass Solution {\n    public int countVowelPermutation(int n) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number} n\n* @return {number}\n*/\nvar countVowelPermutation = function (n) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int countVowelPermutation(int n) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int countVowelPermutation(int n) {\nlong[] f = new long[5];\nArrays.fill(f, 1);\nfinal int mod = (int) 1e9 + 7;\nfor (int i = 1; i < n; ++i) {\nlong[] g = new long[5];\ng[0] = (f[1] + f[2] + f[4]) % mod;\ng[1] = (f[0] + f[2]) % mod;\ng[2] = (f[1] + f[3]) % mod;\ng[3] = f[2];\ng[4] = (f[2] + f[3]) % mod;\nf = g;\n}\nlong ans = 0;\nfor (long x : f) {\nans = (ans + x) % mod;\n}\nreturn (int) ans;\n}\n}\n", "\nclass Solution {\nprivate final int mod = (int) 1e9 + 7;\n\npublic int countVowelPermutation(int n) {\nlong[][] a\n= {{0, 1, 0, 0, 0}, {1, 0, 1, 0, 0}, {1, 1, 0, 1, 1}, {0, 0, 1, 0, 1}, {1, 0, 0, 0, 0}};\nlong[][] res = pow(a, n - 1);\nlong ans = 0;\nfor (long x : res[0]) {\nans = (ans + x) % mod;\n}\nreturn (int) ans;\n}\n\nprivate long[][] mul(long[][] a, long[][] b) {\nint m = a.length, n = b[0].length;\nlong[][] c = new long[m][n];\nfor (int i = 0; i < m; ++i) {\nfor (int j = 0; j < n; ++j) {\nfor (int k = 0; k < b.length; ++k) {\nc[i][j] = (c[i][j] + a[i][k] * b[k][j]) % mod;\n}\n}\n}\nreturn c;\n}\n\nprivate long[][] pow(long[][] a, int n) {\nlong[][] res = new long[1][a.length];\nArrays.fill(res[0], 1);\nwhile (n > 0) {\nif ((n & 1) == 1) {\nres = mul(res, a);\n}\na = mul(a, a);\nn >>= 1;\n}\nreturn res;\n}\n}\n", "\nclass Solution {\npublic int countVowelPermutation(int n) {\nfinal int mod = 1000000007;\nlong countA = 1, countE = 1, countI = 1, countO = 1, countU = 1;\nfor (int length = 1; length < n; length++) {\n// Calculate the next counts for each vowel based on the previous counts\nlong nextCountA = countE;\nlong nextCountE = (countA + countI) % mod;\nlong nextCountI = (countA + countE + countO + countU) % mod;\nlong nextCountO = (countI + countU) % mod;\nlong nextCountU = countA;\n// Update the counts with the newly calculated values for the next length\ncountA = nextCountA;\ncountE = nextCountE;\ncountI = nextCountI;\ncountO = nextCountO;\ncountU = nextCountU;\n}\n// Calculate the total count of valid strings for length n\nlong totalCount = (countA + countE + countI + countO + countU) % mod;\nreturn (int) totalCount;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number} n\n* @return {number}\n*/\nvar countVowelPermutation = function (n) {\nconst mod = 1e9 + 7;\nconst f = Array(5).fill(1);\nfor (let i = 1; i < n; ++i) {\nconst g = Array(5).fill(0);\ng[0] = (f[1] + f[2] + f[4]) % mod;\ng[1] = (f[0] + f[2]) % mod;\ng[2] = (f[1] + f[3]) % mod;\ng[3] = f[2];\ng[4] = (f[2] + f[3]) % mod;\nf.splice(0, 5, ...g);\n}\nreturn f.reduce((a, b) => (a + b) % mod);\n};\n", "\n/**\n* @param {number} n\n* @return {number}\n*/\n\nconst mod = 1e9 + 7;\n\nvar countVowelPermutation = function (n) {\nconst a = [\n[0, 1, 0, 0, 0],\n[1, 0, 1, 0, 0],\n[1, 1, 0, 1, 1],\n[0, 0, 1, 0, 1],\n[1, 0, 0, 0, 0],\n];\nconst res = pow(a, n - 1);\nreturn res[0].reduce((a, b) => (a + b) % mod);\n};\n\nfunction mul(a, b) {\nconst [m, n] = [a.length, b[0].length];\nconst c = Array.from({ length: m }, () => Array.from({ length: n }, () => 0));\nfor (let i = 0; i < m; ++i) {\nfor (let j = 0; j < n; ++j) {\nfor (let k = 0; k < b.length; ++k) {\nc[i][j] =\n(c[i][j] + Number((BigInt(a[i][k]) * BigInt(b[k][j])) % BigInt(mod))) % mod;\n}\n}\n}\nreturn c;\n}\n\nfunction pow(a, n) {\nlet res = [[1, 1, 1, 1, 1]];\nwhile (n) {\nif (n & 1) {\nres = mul(res, a);\n}\na = mul(a, a);\nn >>>= 1;\n}\nreturn res;\n}\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint countVowelPermutation(int n) {\nusing ll = long long;\nvector<ll> f(5, 1);\nconst int mod = 1e9 + 7;\nfor (int i = 1; i < n; ++i) {\nvector<ll> g(5);\ng[0] = (f[1] + f[2] + f[4]) % mod;\ng[1] = (f[0] + f[2]) % mod;\ng[2] = (f[1] + f[3]) % mod;\ng[3] = f[2];\ng[4] = (f[2] + f[3]) % mod;\nf = move(g);\n}\nreturn accumulate(f.begin(), f.end(), 0LL) % mod;\n}\n};\n", "\nclass Solution {\npublic:\nint countVowelPermutation(int n) {\nvector<vector<ll>> a = {\n{0, 1, 0, 0, 0},\n{1, 0, 1, 0, 0},\n{1, 1, 0, 1, 1},\n{0, 0, 1, 0, 1},\n{1, 0, 0, 0, 0}};\nvector<vector<ll>> res = pow(a, n - 1);\nreturn accumulate(res[0].begin(), res[0].end(), 0LL) % mod;\n}\n\nprivate:\nusing ll = long long;\nconst int mod = 1e9 + 7;\n\nvector<vector<ll>> mul(vector<vector<ll>>& a, vector<vector<ll>>& b) {\nint m = a.size(), n = b[0].size();\nvector<vector<ll>> c(m, vector<ll>(n));\nfor (int i = 0; i < m; ++i) {\nfor (int j = 0; j < n; ++j) {\nfor (int k = 0; k < b.size(); ++k) {\nc[i][j] = (c[i][j] + a[i][k] * b[k][j]) % mod;\n}\n}\n}\nreturn c;\n}\n\nvector<vector<ll>> pow(vector<vector<ll>>& a, int n) {\nvector<vector<ll>> res;\nres.push_back({1, 1, 1, 1, 1});\nwhile (n) {\nif (n & 1) {\nres = mul(res, a);\n}\na = mul(a, a);\nn >>= 1;\n}\nreturn res;\n}\n};\n"]}, {"leetCodeID": "1601", "level": "hard", "question_description": "We have n buildings numbered from 0 to n - 1. Each building has a number of employees. It&#39;s transfer season, and some employees want to change the building they reside in.\nYou are given an array requests where requests[i] = [fromi, toi] represents an employee&#39;s request to transfer from building fromi to building toi.\nAll buildings are full, so a list of requests is achievable only if for each building, the net change in employee transfers is zero. This means the number of employees leaving is equal to the number of employees moving in. For example if n = 3 and two employees are leaving building 0, one is leaving building 1, and one is leaving building 2, there should be two employees moving to building 0, one employee moving to building 1, and one employee moving to building 2.\nReturn the maximum number of achievable requests.", "examples": ["Example 1:\n\n\nInput: n = 5, requests = [[0,1],[1,0],[0,1],[1,2],[2,0],[3,4]]\nOutput: 5\nExplantion: Let&#39;s see the requests:\nFrom building 0 we have employees x and y and both want to move to building 1.\nFrom building 1 we have employees a and b and they want to move to buildings 2 and 0 respectively.\nFrom building 2 we have employee z and they want to move to building 0.\nFrom building 3 we have employee c and they want to move to building 4.\nFrom building 4 we don&#39;t have any requests.\nWe can achieve the requests of users x and b by swapping their places.\nWe can achieve the requests of users y, a and z by swapping the places in the 3 buildings.\n\n\nExample 2:\n\n\nInput: n = 3, requests = [[0,0],[1,2],[2,1]]\nOutput: 3\nExplantion: Let&#39;s see the requests:\nFrom building 0 we have employee x and they want to stay in the same building 0.\nFrom building 1 we have employee y and they want to move to building 2.\nFrom building 2 we have employee z and they want to move to building 1.\nWe can achieve all the requests. \n\nExample 3:\nInput: n = 4, requests = [[0,3],[3,1],[1,2],[2,0]]\nOutput: 4\n"], "constraints": "\nConstraints:\n1 <= n <= 20\n1 <= requests.length <= 16\nrequests[i].length == 2\n0 <= fromi, toi < n\n", "java_context": "\nclass Solution {\n    private int m;\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number} n\n* @param {number[][]} requests\n* @return {number}\n*/\nvar maximumRequests = function (n, requests) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int maximumRequests(int n, vector<vector<int>>& requests) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\nprivate int m;\nprivate int n;\nprivate int[][] requests;\n\npublic int maximumRequests(int n, int[][] requests) {\nm = requests.length;\nthis.n = n;\nthis.requests = requests;\nint ans = 0;\nfor (int mask = 0; mask < 1 << m; ++mask) {\nint cnt = Integer.bitCount(mask);\nif (ans < cnt && check(mask)) {\nans = cnt;\n}\n}\nreturn ans;\n}\n\nprivate boolean check(int mask) {\nint[] cnt = new int[n];\nfor (int i = 0; i < m; ++i) {\nif ((mask >> i & 1) == 1) {\nint f = requests[i][0], t = requests[i][1];\n--cnt[f];\n++cnt[t];\n}\n}\nfor (int v : cnt) {\nif (v != 0) {\nreturn false;\n}\n}\nreturn true;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number} n\n* @param {number[][]} requests\n* @return {number}\n*/\nvar maximumRequests = function (n, requests) {\nconst m = requests.length;\nlet ans = 0;\nconst check = mask => {\nconst cnt = new Array(n).fill(0);\nfor (let i = 0; i < m; ++i) {\nif ((mask >> i) & 1) {\nconst [f, t] = requests[i];\n--cnt[f];\n++cnt[t];\n}\n}\nreturn cnt.every(v => v === 0);\n};\nfor (let mask = 0; mask < 1 << m; ++mask) {\nconst cnt = bitCount(mask);\nif (ans < cnt && check(mask)) {\nans = cnt;\n}\n}\nreturn ans;\n};\n\nfunction bitCount(i) {\ni = i - ((i >>> 1) & 0x55555555);\ni = (i & 0x33333333) + ((i >>> 2) & 0x33333333);\ni = (i + (i >>> 4)) & 0x0f0f0f0f;\ni = i + (i >>> 8);\ni = i + (i >>> 16);\nreturn i & 0x3f;\n}\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint maximumRequests(int n, vector<vector<int>>& requests) {\nint m = requests.size();\nint ans = 0;\nauto check = [&](int mask) -> bool {\nint cnt[n];\nmemset(cnt, 0, sizeof(cnt));\nfor (int i = 0; i < m; ++i) {\nif (mask >> i & 1) {\nint f = requests[i][0], t = requests[i][1];\n--cnt[f];\n++cnt[t];\n}\n}\nfor (int v : cnt) {\nif (v) {\nreturn false;\n}\n}\nreturn true;\n};\nfor (int mask = 0; mask < 1 << m; ++mask) {\nint cnt = __builtin_popcount(mask);\nif (ans < cnt && check(mask)) {\nans = cnt;\n}\n}\nreturn ans;\n}\n};\n"]}, {"leetCodeID": "1691", "level": "hard", "question_description": "Given n cuboids where the dimensions of the ith cuboid is cuboids[i] = [widthi, lengthi, heighti] (0-indexed). Choose a subset of cuboids and place them on each other.\nYou can place cuboid i on cuboid j if widthi &lt;= widthj and lengthi &lt;= lengthj and heighti &lt;= heightj. You can rearrange any cuboid&#39;s dimensions by rotating it to put it on another cuboid.\nReturn the maximum height of the stacked cuboids.", "examples": ["Example 1:\n\n\nInput: cuboids = [[50,45,20],[95,37,53],[45,23,12]]\nOutput: 190\nExplanation:\nCuboid 1 is placed on the bottom with the 53x37 side facing down with height 95.\nCuboid 0 is placed next with the 45x20 side facing down with height 50.\nCuboid 2 is placed next with the 23x12 side facing down with height 45.\nThe total height is 95 + 50 + 45 = 190.\n", "Example 2:\nInput: cuboids = [[38,25,45],[76,35,3]]\nOutput: 76\nExplanation:\nYou can&#39;t place any of the cuboids on the other.\nWe choose cuboid 1 and rotate it so that the 35x3 side is facing down and its height is 76.\n", "Example 3:\nInput: cuboids = [[7,11,17],[7,17,11],[11,7,17],[11,17,7],[17,7,11],[17,11,7]]\nOutput: 102\nExplanation:\nAfter rearranging the cuboids, you can see that all cuboids have the same dimension.\nYou can place the 11x7 side down on all cuboids so their heights are 17.\nThe maximum height of stacked cuboids is 6 * 17 = 102.\n"], "constraints": "\nConstraints:\nn == cuboids.length\n1 <= n <= 100\n1 <= widthi, lengthi, heighti <= 100\n", "java_context": "\nclass Solution {\n    public int maxHeight(int[][] cuboids) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[][]} cuboids\n* @return {number}\n*/\nvar maxHeight = function (cuboids) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int maxHeight(vector<vector<int>>& cuboids) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int maxHeight(int[][] cuboids) {\nfor (var c : cuboids) {\nArrays.sort(c);\n}\nArrays.sort(cuboids,\n(a, b) -> a[0] == b[0] ? (a[1] == b[1] ? a[2] - b[2] : a[1] - b[1]) : a[0] - b[0]);\nint n = cuboids.length;\nint[] f = new int[n];\nfor (int i = 0; i < n; ++i) {\nfor (int j = 0; j < i; ++j) {\nif (cuboids[j][1] <= cuboids[i][1] && cuboids[j][2] <= cuboids[i][2]) {\nf[i] = Math.max(f[i], f[j]);\n}\n}\nf[i] += cuboids[i][2];\n}\nreturn Arrays.stream(f).max().getAsInt();\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[][]} cuboids\n* @return {number}\n*/\nvar maxHeight = function (cuboids) {\nfor (const c of cuboids) {\nc.sort((a, b) => a - b);\n}\ncuboids.sort((a, b) => {\nif (a[0] !== b[0]) {\nreturn a[0] - b[0];\n}\nif (a[1] !== b[1]) {\nreturn a[1] - b[1];\n}\nreturn a[2] - b[2];\n});\nconst n = cuboids.length;\nconst f = Array(n).fill(0);\nfor (let i = 0; i < n; ++i) {\nfor (let j = 0; j < i; ++j) {\nconst ok = cuboids[j][1] <= cuboids[i][1] && cuboids[j][2] <= cuboids[i][2];\nif (ok) f[i] = Math.max(f[i], f[j]);\n}\nf[i] += cuboids[i][2];\n}\nreturn Math.max(...f);\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint maxHeight(vector<vector<int>>& cuboids) {\nfor (auto& c : cuboids) {\nsort(c.begin(), c.end());\n}\nsort(cuboids.begin(), cuboids.end());\nint n = cuboids.size();\nvector<int> f(n);\nfor (int i = 0; i < n; ++i) {\nfor (int j = 0; j < i; ++j) {\nif (cuboids[j][1] <= cuboids[i][1] && cuboids[j][2] <= cuboids[i][2]) {\nf[i] = max(f[i], f[j]);\n}\n}\nf[i] += cuboids[i][2];\n}\nreturn *max_element(f.begin(), f.end());\n}\n};\n"]}, {"leetCodeID": "1808", "level": "hard", "question_description": "You are given a positive integer primeFactors. You are asked to construct a positive integer n that satisfies the following conditions:\nThe number of prime factors of n (not necessarily distinct) is at most primeFactors.\nThe number of nice divisors of n is maximized. Note that a divisor of n is nice if it is divisible by every prime factor of n. For example, if n = 12, then its prime factors are [2,2,3], then 6 and 12 are nice divisors, while 3 and 4 are not.\nReturn the number of nice divisors of n. Since that number can be too large, return it modulo 109 + 7.\nNote that a prime number is a natural number greater than 1 that is not a product of two smaller natural numbers. The prime factors of a number n is a list of prime numbers such that their product equals n.", "examples": ["Example 1:\n\nInput: primeFactors = 5\n\nOutput: 6\n\nExplanation: 200 is a valid value of n.\n\nIt has 5 prime factors: [2,2,2,5,5], and it has 6 nice divisors: [10,20,40,50,100,200].\n\nThere is not other value of n that has at most 5 prime factors and more nice divisors.\n\n", "Example 2:\n\nInput: primeFactors = 8\n\nOutput: 18\n\n"], "constraints": "\nConstraints:\n1 <= primeFactors <= 109\n", "java_context": "\nclass Solution {\n    private final int mod = (int) 1e9 + 7;\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number} primeFactors\n* @return {number}\n*/\nvar maxNiceDivisors = function (primeFactors) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int maxNiceDivisors(int primeFactors) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\nprivate final int mod = (int) 1e9 + 7;\n\npublic int maxNiceDivisors(int primeFactors) {\nif (primeFactors < 4) {\nreturn primeFactors;\n}\nif (primeFactors % 3 == 0) {\nreturn qpow(3, primeFactors / 3);\n}\nif (primeFactors % 3 == 1) {\nreturn (int) (4L * qpow(3, primeFactors / 3 - 1) % mod);\n}\nreturn 2 * qpow(3, primeFactors / 3) % mod;\n}\n\nprivate int qpow(long a, long n) {\nlong ans = 1;\nfor (; n > 0; n >>= 1) {\nif ((n & 1) == 1) {\nans = ans * a % mod;\n}\na = a * a % mod;\n}\nreturn (int) ans;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number} primeFactors\n* @return {number}\n*/\nvar maxNiceDivisors = function (primeFactors) {\nif (primeFactors < 4) {\nreturn primeFactors;\n}\nconst mod = 1e9 + 7;\nconst qpow = (a, n) => {\nlet ans = 1;\nfor (; n; n >>= 1) {\nif (n & 1) {\nans = Number((BigInt(ans) * BigInt(a)) % BigInt(mod));\n}\na = Number((BigInt(a) * BigInt(a)) % BigInt(mod));\n}\nreturn ans;\n};\nconst k = Math.floor(primeFactors / 3);\nif (primeFactors % 3 === 0) {\nreturn qpow(3, k);\n}\nif (primeFactors % 3 === 1) {\nreturn (4 * qpow(3, k - 1)) % mod;\n}\nreturn (2 * qpow(3, k)) % mod;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint maxNiceDivisors(int primeFactors) {\nif (primeFactors < 4) {\nreturn primeFactors;\n}\nconst int mod = 1e9 + 7;\nauto qpow = [&](long long a, long long n) {\nlong long ans = 1;\nfor (; n; n >>= 1) {\nif (n & 1) {\nans = ans * a % mod;\n}\na = a * a % mod;\n}\nreturn (int) ans;\n};\nif (primeFactors % 3 == 0) {\nreturn qpow(3, primeFactors / 3);\n}\nif (primeFactors % 3 == 1) {\nreturn qpow(3, primeFactors / 3 - 1) * 4L % mod;\n}\nreturn qpow(3, primeFactors / 3) * 2 % mod;\n}\n};\n"]}, {"leetCodeID": "2132", "level": "hard", "question_description": "You are given an m x n binary matrix grid where each cell is either 0 (empty) or 1 (occupied).\nYou are then given stamps of size stampHeight x stampWidth. We want to fit the stamps such that they follow the given restrictions and requirements:\nCover all the empty cells.\nDo not cover any of the occupied cells.\nWe can put as many stamps as we want.\nStamps can overlap with each other.\nStamps are not allowed to be rotated.\nStamps must stay completely inside the grid.\nReturn true if it is possible to fit the stamps while following the given restrictions and requirements. Otherwise, return false.", "examples": [], "constraints": "\nConstraints:\nm == grid.length\nn == grid[r].length\n1 <= m, n <= 105\n1 <= m * n <= 2 * 105\ngrid[r][c] is either 0 or 1.\n1 <= stampHeight, stampWidth <= 105\n", "java_context": "\nclass Solution {\n    public boolean possibleToStamp(int[][] grid, int stampHeight, int stampWidth) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number[][]} grid\n* @param {number} stampHeight\n* @param {number} stampWidth\n* @return {boolean}\n*/\nvar possibleToStamp = function (grid, stampHeight, stampWidth) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    bool possibleToStamp(vector<vector<int>>& grid, int stampHeight, int stampWidth) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic boolean possibleToStamp(int[][] grid, int stampHeight, int stampWidth) {\nint m = grid.length, n = grid[0].length;\nint[][] s = new int[m + 1][n + 1];\nfor (int i = 1; i <= m; ++i) {\nfor (int j = 1; j <= n; ++j) {\ns[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + grid[i - 1][j - 1];\n}\n}\nint[][] d = new int[m + 2][n + 2];\nfor (int i = 1; i + stampHeight - 1 <= m; ++i) {\nfor (int j = 1; j + stampWidth - 1 <= n; ++j) {\nint x = i + stampHeight - 1, y = j + stampWidth - 1;\nif (s[x][y] - s[x][j - 1] - s[i - 1][y] + s[i - 1][j - 1] == 0) {\nd[i][j]++;\nd[i][y + 1]--;\nd[x + 1][j]--;\nd[x + 1][y + 1]++;\n}\n}\n}\nfor (int i = 1; i <= m; ++i) {\nfor (int j = 1; j <= n; ++j) {\nd[i][j] += d[i - 1][j] + d[i][j - 1] - d[i - 1][j - 1];\nif (grid[i - 1][j - 1] == 0 && d[i][j] == 0) {\nreturn false;\n}\n}\n}\nreturn true;\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number[][]} grid\n* @param {number} stampHeight\n* @param {number} stampWidth\n* @return {boolean}\n*/\nvar possibleToStamp = function (grid, stampHeight, stampWidth) {\nconst m = grid.length;\nconst n = grid[0].length;\nconst s = Array.from({ length: m + 1 }, () => Array(n + 1).fill(0));\nfor (let i = 1; i <= m; ++i) {\nfor (let j = 1; j <= n; ++j) {\ns[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + grid[i - 1][j - 1];\n}\n}\n\nconst d = Array.from({ length: m + 2 }, () => Array(n + 2).fill(0));\nfor (let i = 1; i + stampHeight - 1 <= m; ++i) {\nfor (let j = 1; j + stampWidth - 1 <= n; ++j) {\nconst [x, y] = [i + stampHeight - 1, j + stampWidth - 1];\nif (s[x][y] - s[x][j - 1] - s[i - 1][y] + s[i - 1][j - 1] === 0) {\nd[i][j]++;\nd[i][y + 1]--;\nd[x + 1][j]--;\nd[x + 1][y + 1]++;\n}\n}\n}\n\nfor (let i = 1; i <= m; ++i) {\nfor (let j = 1; j <= n; ++j) {\nd[i][j] += d[i - 1][j] + d[i][j - 1] - d[i - 1][j - 1];\nif (grid[i - 1][j - 1] === 0 && d[i][j] === 0) {\nreturn false;\n}\n}\n}\nreturn true;\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nbool possibleToStamp(vector<vector<int>>& grid, int stampHeight, int stampWidth) {\nint m = grid.size(), n = grid[0].size();\nvector<vector<int>> s(m + 1, vector<int>(n + 1));\nfor (int i = 1; i <= m; ++i) {\nfor (int j = 1; j <= n; ++j) {\ns[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + grid[i - 1][j - 1];\n}\n}\n\nvector<vector<int>> d(m + 2, vector<int>(n + 2));\nfor (int i = 1; i + stampHeight - 1 <= m; ++i) {\nfor (int j = 1; j + stampWidth - 1 <= n; ++j) {\nint x = i + stampHeight - 1, y = j + stampWidth - 1;\nif (s[x][y] - s[x][j - 1] - s[i - 1][y] + s[i - 1][j - 1] == 0) {\nd[i][j]++;\nd[i][y + 1]--;\nd[x + 1][j]--;\nd[x + 1][y + 1]++;\n}\n}\n}\n\nfor (int i = 1; i <= m; ++i) {\nfor (int j = 1; j <= n; ++j) {\nd[i][j] += d[i - 1][j] + d[i][j - 1] - d[i - 1][j - 1];\nif (grid[i - 1][j - 1] == 0 && d[i][j] == 0) {\nreturn false;\n}\n}\n}\nreturn true;\n}\n};\n"]}, {"leetCodeID": "2156", "level": "hard", "question_description": "The hash of a 0-indexed string s of length k, given integers p and m, is computed using the following function:\nhash(s, p, m) = (val(s[0]) * p0 + val(s[1]) * p1 + ... + val(s[k-1]) * pk-1) mod m.\nWhere val(s[i]) represents the index of s[i] in the alphabet from val(&#39;a&#39;) = 1 to val(&#39;z&#39;) = 26.\nYou are given a string s and the integers power, modulo, k, and hashValue. Return sub, the first substring of s of length k such that hash(sub, power, modulo) == hashValue.\nThe test cases will be generated such that an answer always exists.\nA substring is a contiguous non-empty sequence of characters within a string.", "examples": ["Example 1:\nInput: s = &quot;leetcode&quot;, power = 7, modulo = 20, k = 2, hashValue = 0\nOutput: &quot;ee&quot;\nExplanation: The hash of &quot;ee&quot; can be computed to be hash(&quot;ee&quot;, 7, 20) = (5 * 1 + 5 * 7) mod 20 = 40 mod 20 = 0.\n&quot;ee&quot; is the first substring of length 2 with hashValue 0. Hence, we return &quot;ee&quot;.\n", "Example 2:\nInput: s = &quot;fbxzaad&quot;, power = 31, modulo = 100, k = 3, hashValue = 32\nOutput: &quot;fbx&quot;\nExplanation: The hash of &quot;fbx&quot; can be computed to be hash(&quot;fbx&quot;, 31, 100) = (6 * 1 + 2 * 31 + 24 * 312) mod 100 = 23132 mod 100 = 32.\nThe hash of &quot;bxz&quot; can be computed to be hash(&quot;bxz&quot;, 31, 100) = (2 * 1 + 24 * 31 + 26 * 312) mod 100 = 25732 mod 100 = 32.\n&quot;fbx&quot; is the first substring of length 3 with hashValue 32. Hence, we return &quot;fbx&quot;.\nNote that &quot;bxz&quot; also has a hash of 32 but it appears later than &quot;fbx&quot;.\n"], "constraints": "\nConstraints:\n1 <= k <= s.length <= 2 * 104\n1 <= power, modulo <= 109\n0 <= hashValue < modulo\ns consists of lowercase English letters only.\nThe test cases are generated such that an answer always exists.\n", "java_context": "\nclass Solution {\n    public String subStrHash(String s, int power, int modulo, int k, int hashValue) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {string} s\n* @param {number} power\n* @param {number} modulo\n* @param {number} k\n* @param {number} hashValue\n* @return {string}\n*/\nvar subStrHash = function (s, power, modulo, k, hashValue) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    string subStrHash(string s, int power, int modulo, int k, int hashValue) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic String subStrHash(String s, int power, int modulo, int k, int hashValue) {\nlong h = 0, p = 1;\nint n = s.length();\nfor (int i = n - 1; i >= n - k; --i) {\nint val = s.charAt(i) - 'a' + 1;\nh = ((h * power % modulo) + val) % modulo;\nif (i != n - k) {\np = p * power % modulo;\n}\n}\nint j = n - k;\nfor (int i = n - k - 1; i >= 0; --i) {\nint pre = s.charAt(i + k) - 'a' + 1;\nint cur = s.charAt(i) - 'a' + 1;\nh = ((h - pre * p % modulo + modulo) * power % modulo + cur) % modulo;\nif (h == hashValue) {\nj = i;\n}\n}\nreturn s.substring(j, j + k);\n}\n}\n"], "js_solutions": ["\n/**\n* @param {string} s\n* @param {number} power\n* @param {number} modulo\n* @param {number} k\n* @param {number} hashValue\n* @return {string}\n*/\nvar subStrHash = function (s, power, modulo, k, hashValue) {\nlet h = BigInt(0),\np = BigInt(1);\nconst n = s.length;\nconst mod = BigInt(modulo);\nfor (let i = n - 1; i >= n - k; --i) {\nconst val = BigInt(s.charCodeAt(i) - 'a'.charCodeAt(0) + 1);\nh = (((h * BigInt(power)) % mod) + val) % mod;\nif (i !== n - k) {\np = (p * BigInt(power)) % mod;\n}\n}\nlet j = n - k;\nfor (let i = n - k - 1; i >= 0; --i) {\nconst pre = BigInt(s.charCodeAt(i + k) - 'a'.charCodeAt(0) + 1);\nconst cur = BigInt(s.charCodeAt(i) - 'a'.charCodeAt(0) + 1);\nh = ((((h - ((pre * p) % mod) + mod) * BigInt(power)) % mod) + cur) % mod;\nif (Number(h) === hashValue) {\nj = i;\n}\n}\nreturn s.substring(j, j + k);\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nstring subStrHash(string s, int power, int modulo, int k, int hashValue) {\nlong long h = 0, p = 1;\nint n = s.size();\nfor (int i = n - 1; i >= n - k; --i) {\nint val = s[i] - 'a' + 1;\nh = ((h * power % modulo) + val) % modulo;\nif (i != n - k) {\np = p * power % modulo;\n}\n}\nint j = n - k;\nfor (int i = n - k - 1; i >= 0; --i) {\nint pre = s[i + k] - 'a' + 1;\nint cur = s[i] - 'a' + 1;\nh = ((h - pre * p % modulo + modulo) * power % modulo + cur) % modulo;\nif (h == hashValue) {\nj = i;\n}\n}\nreturn s.substr(j, k);\n}\n};\n"]}, {"leetCodeID": "2493", "level": "hard", "question_description": "You are given a positive integer n representing the number of nodes in an undirected graph. The nodes are labeled from 1 to n.\nYou are also given a 2D integer array edges, where edges[i] = [ai, bi] indicates that there is a bidirectional edge between nodes ai and bi. Notice that the given graph may be disconnected.\nDivide the nodes of the graph into m groups (1-indexed) such that:\nEach node in the graph belongs to exactly one group.\nFor every pair of nodes in the graph that are connected by an edge [ai, bi], if ai belongs to the group with index x, and bi belongs to the group with index y, then |y - x| = 1.\nReturn the maximum number of groups (i.e., maximum m) into which you can divide the nodes. Return -1 if it is impossible to group the nodes with the given conditions.", "examples": ["Example 1:\n\n\nInput: n = 6, edges = [[1,2],[1,4],[1,5],[2,6],[2,3],[4,6]]\nOutput: 4\nExplanation: As shown in the image we:\n- Add node 5 to the first group.\n- Add node 1 to the second group.\n- Add nodes 2 and 4 to the third group.\n- Add nodes 3 and 6 to the fourth group.\nWe can see that every edge is satisfied.\nIt can be shown that that if we create a fifth group and move any node from the third or fourth group to it, at least on of the edges will not be satisfied.\n\n\nExample 2:\nInput: n = 3, edges = [[1,2],[2,3],[3,1]]\nOutput: -1\nExplanation: If we add node 1 to the first group, node 2 to the second group, and node 3 to the third group to satisfy the first two edges, we can see that the third edge will not be satisfied.\nIt can be shown that no grouping is possible.\n"], "constraints": "\nConstraints:\n1 <= n <= 500\n1 <= edges.length <= 104\nedges[i].length == 2\n1 <= ai, bi <= n\nai != bi\nThere is at most one edge between any pair of vertices.\n", "java_context": "\nclass Solution {\n    public int magnificentSets(int n, int[][] edges) {\n        // your code\n    }\n}", "js_context": "\n/**\n* @param {number} n\n* @param {number[][]} edges\n* @return {number}\n*/\nvar magnificentSets = function (n, edges) {\n    // your code\n};", "cpp_context": "\nclass Solution {\npublic:\n    int magnificentSets(int n, vector<vector<int>>& edges) {\n        // your code\n    }\n};", "java_solutions": ["\nclass Solution {\npublic int magnificentSets(int n, int[][] edges) {\nList<Integer>[] g = new List[n];\nArrays.setAll(g, k -> new ArrayList<>());\nfor (var e : edges) {\nint a = e[0] - 1, b = e[1] - 1;\ng[a].add(b);\ng[b].add(a);\n}\nint[] d = new int[n];\nint[] dist = new int[n];\nfor (int i = 0; i < n; ++i) {\nDeque<Integer> q = new ArrayDeque<>();\nq.offer(i);\nArrays.fill(dist, 0);\ndist[i] = 1;\nint mx = 1;\nint root = i;\nwhile (!q.isEmpty()) {\nint a = q.poll();\nroot = Math.min(root, a);\nfor (int b : g[a]) {\nif (dist[b] == 0) {\ndist[b] = dist[a] + 1;\nmx = Math.max(mx, dist[b]);\nq.offer(b);\n} else if (Math.abs(dist[b] - dist[a]) != 1) {\nreturn -1;\n}\n}\n}\nd[root] = Math.max(d[root], mx);\n}\nreturn Arrays.stream(d).sum();\n}\n}\n"], "js_solutions": ["\n/**\n* @param {number} n\n* @param {number[][]} edges\n* @return {number}\n*/\nvar magnificentSets = function (n, edges) {\nconst g = Array.from({ length: n }, () => []);\nfor (const [a, b] of edges) {\ng[a - 1].push(b - 1);\ng[b - 1].push(a - 1);\n}\nconst d = Array(n).fill(0);\nfor (let i = 0; i < n; ++i) {\nconst q = [i];\nconst dist = Array(n).fill(0);\ndist[i] = 1;\nlet mx = 1;\nlet root = i;\nwhile (q.length) {\nconst a = q.shift();\nroot = Math.min(root, a);\nfor (const b of g[a]) {\nif (dist[b] === 0) {\ndist[b] = dist[a] + 1;\nmx = Math.max(mx, dist[b]);\nq.push(b);\n} else if (Math.abs(dist[b] - dist[a]) !== 1) {\nreturn -1;\n}\n}\n}\nd[root] = Math.max(d[root], mx);\n}\nreturn d.reduce((a, b) => a + b);\n};\n"], "cpp_solutions": ["\nclass Solution {\npublic:\nint magnificentSets(int n, vector<vector<int>>& edges) {\nvector<int> g[n];\nfor (auto& e : edges) {\nint a = e[0] - 1, b = e[1] - 1;\ng[a].push_back(b);\ng[b].push_back(a);\n}\nvector<int> d(n);\nfor (int i = 0; i < n; ++i) {\nqueue<int> q{{i}};\nvector<int> dist(n);\ndist[i] = 1;\nint mx = 1;\nint root = i;\nwhile (q.size()) {\nint a = q.front();\nq.pop();\nroot = min(root, a);\nfor (int b : g[a]) {\nif (dist[b] == 0) {\ndist[b] = dist[a] + 1;\nmx = max(mx, dist[b]);\nq.push(b);\n} else if (abs(dist[b] - dist[a]) != 1) {\nreturn -1;\n}\n}\n}\nd[root] = max(d[root], mx);\n}\nreturn accumulate(d.begin(), d.end(), 0);\n}\n};\n"]}]